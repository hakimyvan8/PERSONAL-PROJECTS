(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.Kingly = {})));
}(this, (function (exports) { 'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  var SEP = '.';
  var TRANSITION_SYMBOL = "-->";
  var TRANSITION_LABEL_START_SYMBOL = ":";
  var HISTORY_STATE_NAME = "H";
  var HISTORY_PREFIX = 'history.'; // CONSTANTS

  var INIT_STATE = 'nok';
  var INIT_EVENT = 'init';
  var AUTO_EVENT = 'auto';
  var STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,
  // i.e. State

  var NO_STATE_UPDATE = []; // NOTE : this really cannot be anything else than a falsy value, beware

  var NO_OUTPUT = [];
  var ACTION_IDENTITY = function ACTION_IDENTITY() {
    return {
      outputs: NO_OUTPUT,
      updates: NO_STATE_UPDATE
    };
  };
  var SHALLOW = 'shallow';
  var DEEP = 'deep';
  var WRONG_EVENT_FORMAT_ERROR = "The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.";
  var CONTRACTS_EVAL = "CONTRACTS_EVAL";
  var OUTPUTS_MSG = "OUTPUTS_MSG";
  var INPUT_MSG = "INPUT_MSG";
  var WARN_MSG = 'WARN_MSG';
  var MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';
  var ERROR_MSG = 'ERROR_MSG';
  var INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';
  var INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';
  var DEBUG_MSG = 'DEBUG_MSG';
  var INIT_INPUT_MSG = 'INIT_INPUT_MSG';

  const PATH_ROOT = [0];
  const PRE_ORDER = "PRE_ORDER";

  ///// Utility functions
  // Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple
  // objects
  function clone(a) {
    return a === undefined ? undefined : JSON.parse(JSON.stringify(a))
  }

  function merge(objA, objB) {
    return Object.assign({}, objA, objB);
  }

  /**
   *
   * @param {Map} traversalState
   * @param subTree
   * @param {Array} subTreeChildren
   * @modifies {traversalState}
   */
  function updatePathInTraversalState(traversalState, subTree, subTreeChildren) {
    subTreeChildren.forEach((subTreeChild, index) => {
      const traversalStateParent = traversalState.get(subTree);
      // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back
      // the parent node into the children nodes to keep the original path for the parent node. So at any time, the
      // `path` value can be trusted to be accurately describing the location of the node in the tree
      const traversalStateChild = traversalState.get(subTreeChild);
      const currentChildPath = traversalStateChild && traversalStateChild.path;

      traversalState.set(
        subTreeChild,
        merge(traversalStateChild, {
          isAdded: true,
          isVisited: false,
          path: currentChildPath || traversalStateParent.path.concat(index)
        })
      );
    });
  }

  /**
   *
   * @param {Map} traversalState
   * @param tree
   * @modifies {traversalState}
   */
  function updateVisitInTraversalState(traversalState, tree) {
    traversalState.set(
      tree,
      merge(traversalState.get(tree), { isVisited: true })
    );
  }

  ///// Core API
  function visitTree(traversalSpecs, tree) {
    const { store, lenses, traverse } = traversalSpecs;
    const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;
    const { getChildren } = lenses;
    const { visit, seed: seedOrSeedConstructor } = traverse;
    const traversalState = new Map();
    // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make
    // sure we have an object that cannot be modified out of the scope of visitTree and collaborators
    const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);
    const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);

    let currentStore = empty;
    let visitAcc = seed;
    add([tree], currentStore);
    traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });

    while ( !isEmpty(currentStore) ) {
      const subTree = takeAndRemoveOne(currentStore);
      const subTreeChildren = getChildren(traversalState, subTree);

      add(subTreeChildren, currentStore);
      updatePathInTraversalState(traversalState, subTree, subTreeChildren);
      visitAcc = visit(visitAcc, traversalState, subTree);
      updateVisitInTraversalState(traversalState, subTree);
    }

    // Free the references to the tree/subtrees
    traversalState.clear();

    return visitAcc;
  }

  function breadthFirstTraverseTree(lenses, traverse, tree) {
    const { getChildren } = lenses;
    const traversalSpecs = {
      store: {
        empty: [],
        takeAndRemoveOne: store => store.shift(),
        isEmpty: store => store.length === 0,
        add: (subTrees, store) => store.push.apply(store, subTrees)
      },
      lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },
      traverse
    };

    return visitTree(traversalSpecs, tree);
  }

  function preorderTraverseTree(lenses, traverse, tree) {
    const { getChildren } = lenses;
    const traversalSpecs = {
      store: {
        empty: [],
        takeAndRemoveOne: store => store.shift(),
        isEmpty: store => store.length === 0,
        // NOTE : vs. bfs, only `add` changes
        add: (subTrees, store) => store.unshift(...subTrees)
      },
      lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },
      traverse
    };

    return visitTree(traversalSpecs, tree);
  }

  function postOrderTraverseTree(lenses, traverse, tree) {
    const { getChildren } = lenses;
    const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;
    const { seed, visit } = traverse;
    const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState);
    const decoratedLenses = {
      // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function
      // call in the recursive post-order traversal algorithm
      // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place
      getChildren: (traversalState, tree) =>
        predicate(tree, traversalState)
          ? []
          : getChildren(tree, traversalState).concat([tree])
    };
    const traversalSpecs = {
      store: {
        empty: [],
        takeAndRemoveOne: store => store.shift(),
        isEmpty: store => store.length === 0,
        add: (subTrees, store) => store.unshift(...subTrees)
      },
      lenses: decoratedLenses,
      traverse: {
        seed: seed,
        visit: (result, traversalState, tree) => {
          // Cases :
          // 1. label has been visited already : visit
          // 2. label has not been visited, and there are no children : visit
          // 3. label has not been visited, and there are children : don't visit, will do it later
          return predicate(tree, traversalState)
          ? visit(result, traversalState, tree)
            : result
        }
      }
    };

    return visitTree(traversalSpecs, tree);
  }

  // Object as a tree
  function isLeafLabel(label) {
    return objectTreeLenses.getChildren(label).length === 0
  }

  const objectTreeLenses = {
    isLeafLabel,
    getLabel: tree => {
      if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {
        return tree;
      }
      else {
        throw `getLabel > unexpected object tree value`
      }
    },
    getChildren: tree => {
      if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {
        let value = Object.values(tree)[0];
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          return Object.keys(value).map(prop => ({ [prop]: value[prop] }))
        }
        else {
          return []
        }
      }
      else {
        throw `getChildren > unexpected value`
      }
    },
    constructTree: (label, children) => {
      const labelKey = label && Object.keys(label) && Object.keys(label)[0];

      return children.length === 0
        ? label
        : {
        [labelKey]: Object.assign.apply(null, children)
      }
    },
  };

  function traverseObj(traverse, obj){
    const treeObj = {root : obj};
    const {strategy, seed, visit} = traverse;
    const traverseFn = {
      BFS : breadthFirstTraverseTree,
      PRE_ORDER : preorderTraverseTree,
      POST_ORDER: postOrderTraverseTree
    }[strategy] || preorderTraverseTree;
    const decoratedTraverse = {
      seed,
      visit : function visitAllButRoot(visitAcc, traversalState, tree){
        const {path} = traversalState.get(tree);

        return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)
        ? visitAcc
          : visit(visitAcc, traversalState, tree)
      }
    };

    const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);

    return traversedTreeObj
  }

  // Arrays as trees
  const arrayTreeLenses = {
    getLabel: tree => {
      return Array.isArray(tree) ? tree[0] : tree
    },
    getChildren: tree => {
      return Array.isArray(tree)  ? tree[1] : []
    },
    constructTree: (label, children) => {
      return children && Array.isArray(children) && children.length > 0 ? [label, children] : label
    },
  };

  var noop = function noop() {};
  var emptyConsole = {
    log: noop,
    warn: noop,
    info: noop,
    debug: noop,
    error: noop,
    trace: noop,
    group: noop,
    groupEnd: noop
  };
  var emptyTracer = noop;
  function isFunction(x) {
    return typeof x === 'function';
  }
  function isControlState(x) {
    return x && typeof x === 'string' || isHistoryControlState(x);
  }
  function isEvent(x) {
    return typeof x === 'undefined' || typeof x === 'string';
  }
  function isActionFactory(x) {
    return x && typeof x === 'function';
  }
  /**
   * Returns the name of the function as taken from its source definition.
   * For instance, function do_something(){} -> "do_something"
   * @param fn {Function}
   * @returns {String}
   */

  function get_fn_name(fn) {
    var tokens = /^[\s\r\n]*function[\s\r\n]*([^\(\s\r\n]*?)[\s\r\n]*\([^\)\s\r\n]*\)[\s\r\n]*\{((?:[^}]*\}?)+)\}\s*$/.exec(fn.toString());
    return tokens[1];
  }
  function wrap(str) {
    return ['-', str, '-'].join("");
  }
  function times$1(fn, n) {
    return Array.apply(null, {
      length: n
    }).map(Number.call, Number).map(fn);
  }
  function keys(obj) {
    return Object.keys(obj);
  }

  function is_history_transition(transition) {
    return transition.to.startsWith(HISTORY_PREFIX);
  }
  function is_entry_transition(transition) {
    return transition.event === INIT_EVENT;
  }
  function is_from_control_state(controlState) {
    return function (transition) {
      return transition.from === controlState;
    };
  }
  function is_to_history_control_state_of(controlState) {
    return function (transition) {
      return is_history_control_state_of(controlState, transition.to);
    };
  }
  function is_history_control_state_of(controlState, state) {
    return state.substring(HISTORY_PREFIX.length) === controlState;
  }
  function format_transition_label(_event, predicate, action) {
    var event = _event || '';
    return predicate && action ? "".concat(event, " [").concat(predicate.name, "] / ").concat(action.name) : predicate ? "".concat(event, " [").concat(predicate.name, "]}") : action ? "".concat(event, " / ").concat(action.name) : "".concat(event);
  }
  function format_history_transition_state_name(_ref) {
    var from = _ref.from,
        to = _ref.to;
    return "".concat(from, ".").concat(to.substring(HISTORY_PREFIX.length), ".").concat(HISTORY_STATE_NAME);
  }
  function get_all_transitions(transition) {
    var from = transition.from,
        event = transition.event,
        guards = transition.guards;
    return guards ? guards.map(function (_ref2) {
      var predicate = _ref2.predicate,
          to = _ref2.to,
          action = _ref2.action;
      return {
        from: from,
        event: event,
        predicate: predicate,
        to: to,
        action: action
      };
    }) : [transition];
  }
  /**
   * 'this_name' => 'this name'
   * @param {String} str
   * @returns {String}
   */

  function getDisplayName(str) {
    return str.replace(/_/g, ' ');
  }
  function getStatesType(statesTree) {
    var getLabel = objectTreeLenses.getLabel,
        isLeafLabel = objectTreeLenses.isLeafLabel;
    var traverse = {
      strategy: PRE_ORDER,
      seed: {},
      visit: function visit(acc, traversalState, tree) {
        var treeLabel = getLabel(tree);
        var controlState = Object.keys(treeLabel)[0]; // true iff control state is a compound state

        return isLeafLabel(treeLabel) ? (acc[controlState] = false, acc) : (acc[controlState] = true, acc);
      }
    };
    return traverseObj(traverse, statesTree);
  }
  function getStatesPath(statesTree) {
    var getLabel = objectTreeLenses.getLabel;
    var traverse = {
      strategy: PRE_ORDER,
      seed: {},
      visit: function visit(acc, traversalState, tree) {
        var pathStr = traversalState.get(tree).path.join('.');
        var treeLabel = getLabel(tree);
        var controlState = Object.keys(treeLabel)[0];
        return acc[controlState] = pathStr, acc;
      }
    };
    return traverseObj(traverse, statesTree);
  }
  function getStatesTransitionsMap(transitions) {
    // Map a control state to the transitions which it as origin
    return transitions.reduce(function (acc, transition) {
      var from = transition.from,
          event = transition.event; // NOTE: that should never be, but we need to be defensive here to keep semantics

      if (isHistoryControlState(from)) return acc;
      acc[from] = acc[from] || {};
      acc[from][event] = transition;
      return acc;
    }, {}) || {};
  }
  function getStateEventTransitionsMaps(transitions) {
    // Map a control state to the transitions which it as origin
    return transitions.reduce(function (acc, transition) {
      var from = transition.from,
          event = transition.event; // NOTE: that should never be, but we need to be defensive here to keep semantics

      if (isHistoryControlState(from)) return acc;
      acc[from] = acc[from] || {};
      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];
      return acc;
    }, {}) || {};
  }
  function getEventTransitionsMaps(transitions) {
    // Map an event to the origin control states of the transitions it triggers
    return transitions.reduce(function (acc, transition) {
      var from = transition.from,
          event = transition.event; // NOTE: that should never be, but we need to be defensive here to keep semantics

      if (isHistoryControlState(from)) return acc;
      acc[event] = acc[event] || {};
      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];
      return acc;
    }, {}) || {};
  }
  function getHistoryStatesMap(transitions) {
    return reduceTransitions(function (map, flatTransition, guardIndex, transitionIndex) {
      var from = flatTransition.from,
          event = flatTransition.event,
          to = flatTransition.to,
          action = flatTransition.action,
          predicate = flatTransition.predicate,
          gen = flatTransition.gen;

      if (isHistoryControlState(from)) {
        var underlyingControlState = getHistoryUnderlyingState(from);
        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));
      } else if (isHistoryControlState(to)) {
        var _underlyingControlState = getHistoryUnderlyingState(to);

        map.set(_underlyingControlState, (map.get(_underlyingControlState) || []).concat([flatTransition]));
      }

      return map;
    }, new Map(), transitions) || {};
  }
  function getTargetStatesMap(transitions) {
    return reduceTransitions(function (map, flatTransition, guardIndex, transitionIndex) {
      var to = flatTransition.to;
      map.set(to, (map.get(to) || []).concat([flatTransition]));
      return map;
    }, new Map(), transitions) || {};
  }
  function getAncestorMap(statesTree) {
    var getLabel = objectTreeLenses.getLabel,
        getChildren = objectTreeLenses.getChildren;
    var traverse = {
      strategy: PRE_ORDER,
      seed: {},
      visit: function visit(acc, traversalState, tree) {
        var treeLabel = getLabel(tree);
        var controlState = Object.keys(treeLabel)[0];
        var children = getChildren(tree);
        var childrenControlStates = children.map(function (tree) {
          return Object.keys(getLabel(tree))[0];
        });
        childrenControlStates.forEach(function (state) {
          acc[state] = acc[state] || [];
          acc[state] = acc[state].concat(controlState);
        });
        return acc;
      }
    };
    return traverseObj(traverse, statesTree);
  }
  function computeHistoryMaps(control_states) {
    if (Object.keys(control_states).length === 0) {
      throw "computeHistoryMaps : passed empty control states parameter?";
    }

    var getLabel = objectTreeLenses.getLabel;
    var traverse = {
      strategy: PRE_ORDER,
      seed: {
        stateList: [],
        stateAncestors: {}
      },
      visit: function visit(acc, traversalState, tree) {
        var treeLabel = getLabel(tree);
        var controlState = Object.keys(treeLabel)[0];
        acc.stateList = acc.stateList.concat(controlState); // NOTE : we don't have to worry about path having only one element
        // that case correspond to the root of the tree which is excluded from visiting

        var _traversalState$get = traversalState.get(tree),
            path = _traversalState$get.path;

        traversalState.set(JSON.stringify(path), controlState);
        var parentPath = path.slice(0, -1);

        if (parentPath.length === 1) {
          // That's the root
          traversalState.set(JSON.stringify(parentPath), INIT_STATE);
        } else {
          var parentControlState = traversalState.get(JSON.stringify(parentPath));
          acc.stateAncestors[controlState] = [parentControlState];

          var _path$reduce = path.reduce(function (acc, _) {
            var parentPath = acc.path.slice(0, -1);
            acc.path = parentPath;

            if (parentPath.length > 1) {
              var _parentControlState = traversalState.get(JSON.stringify(parentPath));

              acc.ancestors = acc.ancestors.concat(_parentControlState);
            }

            return acc;
          }, {
            ancestors: [],
            path: path
          }),
              ancestors = _path$reduce.ancestors;

          acc.stateAncestors[controlState] = ancestors;
        }

        return acc;
      }
    };

    var _traverseObj = traverseObj(traverse, control_states),
        stateList = _traverseObj.stateList,
        stateAncestors = _traverseObj.stateAncestors;

    return {
      stateList: stateList,
      stateAncestors: stateAncestors
    };
  }
  function reduceTransitions(reduceFn, seed, transitions) {
    var result = transitions.reduce(function (acc, transitionStruct, transitionIndex) {
      var from = transitionStruct.from,
          event = transitionStruct.event,
          to = transitionStruct.to,
          gen = transitionStruct.gen,
          action = transitionStruct.action,
          guards = transitionStruct.guards; // Edge case when no guards are defined

      if (!guards) {
        guards = gen ? [{
          to: to,
          action: action,
          gen: gen,
          predicate: undefined
        }] : [{
          to: to,
          action: action,
          predicate: undefined
        }];
      }

      return guards.reduce(function (acc, guard, guardIndex) {
        var to = guard.to,
            action = guard.action,
            gen = guard.gen,
            predicate = guard.predicate;
        return gen ? reduceFn(acc, {
          from: from,
          event: event,
          to: to,
          action: action,
          predicate: predicate,
          gen: gen
        }, guardIndex, transitionIndex) : reduceFn(acc, {
          from: from,
          event: event,
          to: to,
          action: action,
          predicate: predicate
        }, guardIndex, transitionIndex);
      }, acc);
    }, seed);
    return result;
  }
  /**
   * @description takes an output and turns it into an array
   * @param {*} output
   * @returns {*[]|null} if the output is null: null, if output is an array: output, else: [output]
   */

  function arrayizeOutput(output) {
    return output === NO_OUTPUT ? NO_OUTPUT : Array.isArray(output) ? output : [output];
  }
  function isHistoryControlState(to) {
    return _typeof(to) === 'object' && (DEEP in to || SHALLOW in to);
  }
  function getHistoryType(history) {
    return history[DEEP] ? DEEP : SHALLOW;
  }
  function getHistoryUnderlyingState(history) {
    return history[getHistoryType(history)];
  }
  /**
   * Creates a history object from a state list. The created history object represents the history states when no
   * control states have been entered or exited.
   * @param stateList
   * @returns {History}
   */

  function initHistoryDataStructure(stateList) {
    var _ref4;

    // NOTE : we update history in place, so we need two different objects here, even
    // when they start with the same value
    var initHistory = function initHistory() {
      return stateList.reduce(function (acc, state) {
        return acc[state] = '', acc;
      }, {});
    };

    return _ref4 = {}, _defineProperty(_ref4, DEEP, initHistory()), _defineProperty(_ref4, SHALLOW, initHistory()), _ref4;
  }
  /**
   * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the
   * `stateAncestors` which are the ancestors for the exited state.
   * @param {HistoryState} _history Contains deep history and shallow history for all
   * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function
   * `updateHistory` allows to update the history as transitions occur in the state machine.
   * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors
   * @returns {HistoryState}
   * @modifies history
   */

  function updateHistory(_history, stateAncestors, state_from_name) {
    var _history2;

    // 27.08.2020: Now that I expose history state I have to make sure that it is not mutated!!
    // We have a fixed format here, so we use native `assign` at deepest level
    var history = (_history2 = {}, _defineProperty(_history2, DEEP, Object.assign({}, _history[DEEP])), _defineProperty(_history2, SHALLOW, Object.assign({}, _history[SHALLOW])), _history2); // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)

    if (state_from_name === INIT_STATE) {
      return history;
    } else {
      // ancestors for the state which is exited
      var ancestors = stateAncestors[state_from_name] || [];
      ancestors.reduce(function (oldAncestor, newAncestor) {
        // set the exited state in the history of all ancestors
        history[DEEP][newAncestor] = state_from_name;
        history[SHALLOW][newAncestor] = oldAncestor;
        return newAncestor;
      }, state_from_name);
      return history;
    }
  }
  function findInitTransition(transitions) {
    return transitions.find(function (transition) {
      return transition.from === INIT_STATE && transition.event === INIT_EVENT;
    });
  }
  /**
   *
   * @param {function(...*): True | Error} contract Contract that either fulfills or returns an error
   * @param {Array<*>} arrayParams Parameters to be passed to the contract
   * @returns {undefined|{when, location, info, message}|Object} either true (fulfilled contract)
   * or an object with optional properties for diagnostic and tracing purposes
   * about the cause of the error if the contract is not fulfilled
   */

  function assert(contract, arrayParams) {
    var contractName = contract.name || "";
    var isFulfilledOrError = contract.apply(null, arrayParams);
    if (isFulfilledOrError === true) return void 0;else {
      return _objectSpread({}, isFulfilledOrError, {
        when: "Checking contract",
        message: [isFulfilledOrError.message, "failed contract ".concat(contractName)].join("\n"),
        info: isFulfilledOrError.info
      });
    }
  }
  function isActions(obj) {
    return obj && "updates" in obj && "outputs" in obj && Array.isArray(obj.outputs); // && Array.isArray(obj.updates)
    // !! does not have to be arrays. HAs to be anything that is accepted by updateState
  }
  /**
   * That is a Either contract, not a Boolean contract!
   * @param obj
   * @returns {boolean|Error}
   */

  function isEventStruct(obj) {
    var trueOrError;

    if (!obj || _typeof(obj) !== 'object') {
      trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);
      trueOrError.info = {
        event: obj,
        cause: "not an object!"
      };
    } else if (Object.keys(obj).length > 1) {
      trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);
      trueOrError.info = {
        event: obj,
        cause: "Event objects must have only one key which is the event name!"
      };
    } else trueOrError = true;

    return trueOrError;
  }
  function destructureEvent(obj) {
    var eventName = Object.keys(obj)[0];
    var eventData = obj[eventName];
    return {
      eventName: eventName,
      eventData: eventData
    };
  }
  function wrapUpdateStateFn(userProvidedUpdateStateFn, _ref9) {
    var throwKinglyError = _ref9.throwKinglyError,
        tracer = _ref9.tracer;
    return function (extendedState, updates) {
      var fnName = userProvidedUpdateStateFn.name || "";

      try {
        return userProvidedUpdateStateFn(extendedState, updates);
      } catch (e) {
        throwKinglyError({
          when: "Executing updateState function ".concat(fnName),
          location: "createStateMachine > wrappedUpdateState",
          info: {
            extendedState: extendedState,
            updates: updates
          },
          message: e.message,
          stack: e.stack
        });
      }
    };
  }
  function throwKinglyErrorFactory(console, tracer) {
    return function (obj) {
      throw new KinglyError(obj, console, tracer);
    };
  }
  var KinglyError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(KinglyError, _Error);

    function KinglyError(m, console, tracer) {
      var _this;

      _classCallCheck(this, KinglyError);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(KinglyError).call(this, m && m.message || ""));
      _this.name = "KinglyError";
      _this.stack = m && m.stack || _this.stack;
      _this.errors = m;

      var _ref10 = m || {},
          when = _ref10.when,
          location = _ref10.location,
          info = _ref10.info,
          message = _ref10.message;

      var fm = "At ".concat(location, ": ").concat(when, " => ").concat(message);
      var infoMsg = info ? "See extra info in console" : "";
      var fullMsg = [fm, infoMsg].join("\n"); // this.message = fullMsg;

      console && console.error(fullMsg);
      info && console && console.info(info);
      return _this;
    }

    return KinglyError;
  }(_wrapNativeSuper(Error));

  // S2. State names must be unique

  var noDuplicatedStates = {
    name: 'noDuplicatedStates',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings) {
      var getLabel = objectTreeLenses.getLabel;
      var traverse = {
        strategy: PRE_ORDER,
        seed: {
          duplicatedStates: [],
          statesHashMap: {}
        },
        visit: function visit(acc, traversalState, tree) {
          var duplicatedStates = acc.duplicatedStates,
              statesHashMap = acc.statesHashMap;
          var treeLabel = getLabel(tree);
          var controlState = Object.keys(treeLabel)[0];

          if (controlState in statesHashMap) {
            return {
              duplicatedStates: duplicatedStates.concat(controlState),
              statesHashMap: statesHashMap
            };
          } else {
            return {
              duplicatedStates: duplicatedStates,
              statesHashMap: (statesHashMap[controlState] = "", statesHashMap)
            };
          }
        }
      };

      var _traverseObj = traverseObj(traverse, fsmDef.states),
          duplicatedStates = _traverseObj.duplicatedStates;

      var isFulfilled = duplicatedStates.length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "State names must be unique! Found duplicated state names. Cf. log",
          info: {
            duplicatedStates: duplicatedStates
          }
        }
      };
    }
  }; // S1. State name cannot be a reserved state name (for now only INIT_STATE)

  var noReservedStates = {
    name: 'noReservedStates',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref) {
      var statesType = _ref.statesType;
      return {
        isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,
        blame: {
          message: "You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log",
          info: {
            reservedStates: [INIT_STATE],
            statesType: statesType
          }
        }
      };
    }
  }; // S4. At least one control state (other than the initial state) muat be declared

  var atLeastOneState = {
    name: 'atLeastOneState',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref2) {
      var statesType = _ref2.statesType;
      return {
        isFulfilled: Object.keys(statesType).length > 0,
        blame: {
          message: "Machine configuration must define at least one control state! Cf. log",
          info: {
            statesType: statesType
          }
        }
      };
    }
  }; // S5. check initial control state is a defined state in states

  var isInitialControlStateDeclared = {
    name: 'isInitialControlStateDeclared',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref3) {
      var initTransition = _ref3.initTransition,
          statesType = _ref3.statesType;
      var initialControlState = fsmDef.initialControlState,
          transitions = fsmDef.transitions;
      var stateList = Object.keys(statesType);

      if (initialControlState) {
        return {
          isFulfilled: stateList.indexOf(initialControlState) > -1,
          blame: {
            message: "Configured initial control state must be a declared state. Cf. log",
            info: {
              initialControlState: initialControlState,
              declaredStates: stateList
            }
          }
        };
      } else {
        return {
          isFulfilled: true,
          blame: void 0
        };
      }
    }
  }; // E0. `fsmDef.events` msut be an array of strings

  var eventsAreStrings = {
    name: 'eventsAreStrings',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings) {
      return {
        isFulfilled: fsmDef.events.every(function (x) {
          return typeof x === 'string';
        }),
        blame: {
          message: "Events must be an array of strings!",
          info: {
            events: fsmDef.events
          }
        }
      };
    }
  };
  var validInitialConfig = {
    name: 'validInitialConfig',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref4) {
      var initTransition = _ref4.initTransition;
      var initialControlState = fsmDef.initialControlState;

      if (initTransition && initialControlState) {
        return {
          isFulfilled: false,
          blame: {
            message: "Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!",
            info: {
              initialControlState: initialControlState,
              initTransition: initTransition
            }
          }
        };
      } else if (!initTransition && !initialControlState) {
        return {
          isFulfilled: false,
          blame: {
            message: "Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?",
            info: {
              initialControlState: initialControlState,
              initTransition: initTransition
            }
          }
        };
      } else return {
        isFulfilled: true,
        blame: void 0
      };
    }
  }; // T1. There must be configured at least one transition away from the initial state
  // T2. A transition away from the initial state can only be triggered by the initial event
  // T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history
  // state as target
  // T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We
  // can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and
  // debugging!. So enforce ACTIONS to be identity

  var validInitialTransition = {
    name: 'validInitialTransition',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref5) {
      var initTransition = _ref5.initTransition;
      var initialControlState = fsmDef.initialControlState,
          transitions = fsmDef.transitions;
      var initTransitions = transitions.reduce(function (acc, transition) {
        transition.from === INIT_STATE && acc.push(transition);
        return acc;
      }, []); // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!
      // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't
      // enforce the part of the contract which require to have no actions for initial transitions...

      var isFulfilled = initialControlState && !initTransition || !initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT && (isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY
      || areCconditionalTransitions(initTransition) // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)
      );
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Invalid configuration for initial transition! Cf. log",
          info: {
            initTransition: initTransition,
            initTransitions: initTransitions,
            initialControlState: initialControlState
          }
        }
      };
    }
  }; // T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound
  // state or A is the initial state

  var initEventOnlyInCompoundStates = {
    name: 'initEventOnlyInCompoundStates',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref6) {
      var statesTransitionsMap = _ref6.statesTransitionsMap,
          statesType = _ref6.statesType,
          statesPath = _ref6.statesPath;
      // The compound states below does not include the initial state by construction
      var atomicStates = Object.keys(statesType).filter(function (controlState) {
        return !statesType[controlState];
      });
      var atomicInitTransitions = atomicStates.map(function (atomicState) {
        return _defineProperty({}, atomicState, statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]);
      }).filter(function (obj) {
        return Object.values(obj)[0];
      });
      var hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0;
      return {
        isFulfilled: hasInitEventOnlyInCompoundStates,
        blame: {
          message: "Found at least one atomic state with an entry transition! That is forbidden! Cf. log",
          info: {
            initTransitions: atomicInitTransitions
          }
        }
      };
    }
  }; // T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined
  // T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which
  // does not have a history state as target
  // NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop
  // T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which
  // does not have the history state as target and has a target control state that is one of its substates (no
  // out-of-hierarchy INIT transitions)

  var validInitialTransitionForCompoundState = {
    name: 'validInitialTransitionForCompoundState',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref8) {
      var statesTransitionsMap = _ref8.statesTransitionsMap,
          statesType = _ref8.statesType,
          statesPath = _ref8.statesPath;
      // The compound states below does not include the initial state by construction
      var compoundStates = Object.keys(statesType).filter(function (controlState) {
        return statesType[controlState];
      });
      var compoundStatesInitTransitions = compoundStates.map(function (compoundState) {
        return statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT];
      });
      var allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);

      if (!allHaveInitTransitions) {
        return {
          isFulfilled: false,
          blame: {
            message: "Found at least one compound state without an entry transition! Cf. log",
            info: {
              hasEntryTransitions: compoundStates.map(function (state) {
                return _defineProperty({}, state, !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT]));
              })
            }
          }
        };
      }

      var allHaveValidInitTransitions = allHaveInitTransitions && compoundStatesInitTransitions.every(function (initTransition) {
        var guards = initTransition.guards,
            to = initTransition.to;

        if (!guards) {
          //  T7a
          return typeof to === 'string';
        } else {
          var targetStates = guards.map(function (guard) {
            return guard.to;
          });
          return targetStates.every(function (targetState) {
            return typeof targetState === 'string';
          });
        }
      });

      if (!allHaveValidInitTransitions) {
        return {
          isFulfilled: false,
          blame: {
            message: "Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log",
            info: {
              entryTransitions: compoundStatesInitTransitions
            }
          }
        };
      }
      var allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions && compoundStatesInitTransitions.every(function (initTransition) {
        var from = initTransition.from,
            guards = initTransition.guards,
            to = initTransition.to; // Don't forget to also eliminate the case when from = to
        // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the
        // other from declared states

        if (!guards) {
          return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from]);
        } else {
          var targetStates = guards.map(function (guard) {
            return guard.to;
          });
          return targetStates.every(function (to) {
            return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from]);
          });
        }
      });

      if (!allHaveTargetStatesWithinHierarchy) {
        return {
          isFulfilled: false,
          blame: {
            message: "Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! ",
            info: {
              states: fsmDef.states,
              statesPath: statesPath,
              entryTransitions: compoundStatesInitTransitions
            }
          }
        };
      }

      return {
        isFulfilled: true,
        blame: void 0
      };
    }
  }; // T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X
  // T24. Check that we have this implicitly : Compound states must not have eventless transitions
  // defined on them (would introduce ambiguity with the INIT transition).

  var validEventLessTransitions = {
    name: 'validEventLessTransitions',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref10) {
      var statesTransitionsMap = _ref10.statesTransitionsMap,
          statesType = _ref10.statesType,
          statesPath = _ref10.statesPath;
      // The compound states below does not include the initial state by construction
      var stateList = Object.keys(statesType);
      var failingOriginControlStates = stateList.map(function (state) {
        return _defineProperty({}, state, statesTransitionsMap[state] && "".concat(void 0) in statesTransitionsMap[state] && Object.keys(statesTransitionsMap[state]).length !== 1);
      }).filter(function (obj) {
        return Object.values(obj)[0] !== void 0 && Object.values(obj)[0];
      });
      var isFulfilled = failingOriginControlStates.length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Found at least one control state without both an eventless transition and a competing transition! Cf. log",
          info: {
            failingOriginControlStates: failingOriginControlStates
          }
        }
      };
    }
  }; // T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together
  // in a single array and there cannot be two transition rows showcasing A -ev-> * transitions

  var allStateTransitionsOnOneSingleRow = {
    name: 'allStateTransitionsOnOneSingleRow',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref12) {
      var stateEventTransitionsMaps = _ref12.stateEventTransitionsMaps;
      var originStateList = Object.keys(stateEventTransitionsMaps);
      var statesTransitionsInfo = originStateList.reduce(function (acc, state) {
        var events = Object.keys(stateEventTransitionsMaps[state]);
        var wrongEventConfig = events.filter(function (event) {
          return stateEventTransitionsMaps[state][event].length > 1;
        });

        if (wrongEventConfig.length > 0) {
          acc[state] = wrongEventConfig;
        }

        return acc;
      }, {});
      var isFulfilled = Object.keys(statesTransitionsInfo).length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log",
          info: {
            statesTransitionsInfo: statesTransitionsInfo
          }
        }
      };
    }
  }; // T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A
  // with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.
  // The event `ev` could trigger a transition towards either B or C

  var noConflictingTransitionsWithAncestorState = {
    name: 'noConflictingTransitionsWithAncestorState',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref13) {
      var stateEventTransitionsMaps = _ref13.stateEventTransitionsMaps,
          eventTransitionsMaps = _ref13.eventTransitionsMaps,
          ancestorMap = _ref13.ancestorMap;
      var eventList = Object.keys(eventTransitionsMaps).filter(function (ev) {
        return ev !== INIT_EVENT && ev !== void 0;
      });
      var eventTransitionsInfo = eventList.reduce(function (acc, event) {
        var states = Object.keys(eventTransitionsMaps[event]); // The wrongly configured states are those which have an ancestor also in the transition map for the same event

        var wrongStateConfig = states.filter(function (state) {
          return state !== INIT_STATE;
        }).map(function (state) {
          return ancestorMap[state] && _defineProperty({}, state, ancestorMap[state].find(function (ancestorState) {
            return states.indexOf(ancestorState) > -1;
          }));
        }) // removing cases : undefined and {[state]: undefined}
        .filter(function (obj) {
          return obj && Object.values(obj).filter(Boolean).length > 0;
        });

        if (wrongStateConfig.length > 0) {
          acc[event] = wrongStateConfig;
        }

        return acc;
      }, {});
      var isFulfilled = Object.keys(eventTransitionsInfo).length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log",
          info: {
            eventTransitionsInfo: eventTransitionsInfo
          }
        }
      };
    }
  }; // T16.a History states must be target states

  var isHistoryStatesTargetStates = {
    name: 'isHistoryStatesTargetStates',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref15) {
      _objectDestructuringEmpty(_ref15);

      var wrongHistoryStates = fsmDef.transitions.reduce(function (acc, transition) {
        return isHistoryControlState(transition.from) ? acc.concat(transition) : acc;
      }, []);
      var isFulfilled = Object.keys(wrongHistoryStates).length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log",
          info: {
            wrongHistoryStates: wrongHistoryStates
          }
        }
      };
    }
  }; // T16.b History states must be compound states

  var isHistoryStatesCompoundStates = {
    name: 'isHistoryStatesCompoundStates',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref16) {
      var stateEventTransitionsMaps = _ref16.stateEventTransitionsMaps,
          statesType = _ref16.statesType;
      var originStateList = Object.keys(stateEventTransitionsMaps);
      var wrongHistoryStates = originStateList.map(function (originState) {
        if (originState === INIT_STATE) return [];
        var events = Object.keys(stateEventTransitionsMaps[originState]);
        return events.reduce(function (acc, event) {
          // I should only ever have one transition, that is checked in another contract
          // !! if there are several transitions, we may have a false positive, but that is ok
          // When the other contract will fail and the issue will be solved, and app will be rerun,
          // this will be recomputed correctly
          var transition = stateEventTransitionsMaps[originState][event][0];
          var guards = transition.guards,
              to = transition.to;

          if (!guards) {
            // Reminder: statesType[controlState] === true iff controlState is compound state
            return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)] ? acc.concat(transition) : acc;
          } else {
            return guards.reduce(function (acc, guard) {
              var to = guard.to;
              return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)] ? acc.concat(transition) : acc;
            }, acc);
          }
        }, []);
      }).reduce(function (acc, x) {
        return acc.concat(x);
      }, []);
      var isFulfilled = Object.keys(wrongHistoryStates).length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log",
          info: {
            wrongHistoryStates: wrongHistoryStates,
            states: fsmDef.states
          }
        }
      };
    }
  }; // T17 An history state must refer to an existing state

  var isHistoryStatesExisting = {
    name: 'isHistoryStatesExisting',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref17) {
      var historyStatesMap = _ref17.historyStatesMap,
          statesType = _ref17.statesType;
      var invalidTransitions = Array.from(historyStatesMap.entries()).map(function (_ref18) {
        var _ref19 = _slicedToArray(_ref18, 2),
            historyState = _ref19[0],
            flatTransitions = _ref19[1];

        return !(historyState in statesType) && {
          historyState: historyState,
          flatTransitions: flatTransitions
        };
      }).filter(Boolean);
      var howMany = Object.keys(invalidTransitions).length;
      var isFulfilled = howMany === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Found ".concat(howMany, " history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition."),
          info: {
            invalidTransitions: invalidTransitions,
            states: fsmDef.states
          }
        }
      };
    }
  };
  function isInconditionalTransition(transition) {
    var from = transition.from,
        event = transition.event,
        guards = transition.guards,
        to = transition.to,
        action = transition.action;
    return typeof guards === "".concat(void 0) && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action);
  }
  function isValidGuard(guard) {
    var to = guard.to,
        predicate = guard.predicate,
        action = guard.action;
    return to && isControlState(to) && isFunction(predicate) && isActionFactory(action);
  }
  function areCconditionalTransitions(transition) {
    var from = transition.from,
        event = transition.event,
        guards = transition.guards,
        to = transition.to;
    return guards && Array.isArray(guards) && guards.length > 0 && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard);
  }
  var isValidFsmDef = {
    name: 'isValidFsmDef',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings) {
      var transitions = fsmDef.transitions,
          states = fsmDef.states,
          events = fsmDef.events,
          initialExtendedState = fsmDef.initialExtendedState;
      var isValidTransitions = transitions && Array.isArray(transitions);
      var isValidStates = states && _typeof(states) === 'object';
      var isValidEvents = events && Array.isArray(events);

      if (!isValidTransitions) {
        return {
          isFulfilled: false,
          blame: {
            message: "The transitions property for a machine definition must be an array!",
            info: {
              transitions: transitions
            }
          }
        };
      } else if (!isValidStates) {
        return {
          isFulfilled: false,
          blame: {
            message: "The states property for a machine definition must be an object!",
            info: {
              states: states
            }
          }
        };
      } else if (!isValidEvents) {
        return {
          isFulfilled: false,
          blame: {
            message: "The events property for a machine definition must be an array!",
            info: {
              events: events
            }
          }
        };
      } // NOTE : we do not deal with initialExtendedState, initialControlState and settings
      // this is done in other contracts
      else {
          return {
            isFulfilled: true,
            blame: void 0
          };
        }
    } // T18. Transitions have a valid format, and are either inconditional (no guards) or conditional
    // events are strings
    // guards are functions
    // action factories are functions

  };
  var haveTransitionsValidTypes = {
    name: 'haveTransitionsValidTypes',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings) {
      var transitions = fsmDef.transitions;
      var wrongTransitions = transitions.map(function (transition, transitionIndex) {
        return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {
          transition: transition,
          index: transitionIndex
        };
      }).filter(Boolean);
      var howMany = Object.keys(wrongTransitions).length;
      var isFulfilled = howMany === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "Found ".concat(howMany, " transitions with invalid format! Check logs for more details."),
          info: {
            wrongTransitions: wrongTransitions,
            transitions: transitions
          }
        }
      };
    }
  };
  var areEventsDeclared = {
    name: 'areEventsDeclared',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref20) {
      var eventTransitionsMaps = _ref20.eventTransitionsMaps;
      var eventList = Object.keys(eventTransitionsMaps);
      var declaredEventList = fsmDef.events;
      var eventsDeclaredButNotTriggeringTransitions = declaredEventList.map(function (declaredEvent) {
        return eventList.indexOf(declaredEvent) === -1 && declaredEvent;
      }).filter(Boolean);
      var eventsNotDeclaredButTriggeringTransitions = eventList.map(function (triggeringEvent) {
        return declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent;
      }).filter(Boolean) // Filtering out init events which must not be declared, being reserved events
      // Filtering out undefined events linked to eventless transitions
      .filter(function (ev) {
        return ev !== INIT_EVENT && ev !== 'undefined';
      });
      var isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0 && eventsNotDeclaredButTriggeringTransitions.length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "All declared events must be used in transitions. All events used in transition must be declared! Cf. log",
          info: {
            eventsDeclaredButNotTriggeringTransitions: eventsDeclaredButNotTriggeringTransitions,
            eventsNotDeclaredButTriggeringTransitions: eventsNotDeclaredButTriggeringTransitions
          }
        }
      };
    }
  };
  var areStatesDeclared = {
    name: 'areStatesDeclared',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref21) {
      var stateEventTransitionsMaps = _ref21.stateEventTransitionsMaps,
          targetStatesMap = _ref21.targetStatesMap,
          statesType = _ref21.statesType;
      var originStateList = Object.keys(stateEventTransitionsMaps);
      var targetStateList = Array.from(targetStatesMap.keys()).filter(function (x) {
        return _typeof(x) !== 'object';
      });
      var stateList = Object.keys([originStateList, targetStateList].reduce(function (acc, stateList) {
        stateList.forEach(function (state) {
          return acc[state] = true;
        });
        return acc;
      }, {}));
      var declaredStateList = Object.keys(statesType);
      var statesDeclaredButNotTriggeringTransitions = declaredStateList.map(function (declaredState) {
        return stateList.indexOf(declaredState) === -1 && declaredState;
      }).filter(Boolean);
      var statesNotDeclaredButTriggeringTransitions = stateList.map(function (stateInTransition) {
        return stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition;
      }).filter(Boolean);
      var isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0 && statesNotDeclaredButTriggeringTransitions.length === 0;
      return {
        isFulfilled: isFulfilled,
        blame: {
          message: "All declared states must be used in transitions. All states used in transition must be declared! Cf. log",
          info: {
            statesDeclaredButNotTriggeringTransitions: statesDeclaredButNotTriggeringTransitions,
            statesNotDeclaredButTriggeringTransitions: statesNotDeclaredButTriggeringTransitions
          }
        }
      };
    }
  }; // T25. SS1 - as of v0.13 settings is no longer mandatory

  var isValidSettings = {
    name: 'isValidSettings',
    shouldThrow: false,
    predicate: function predicate(fsmDef) {
      return {
        isFulfilled: true,
        blame: void 0
      };
    }
  }; // T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not

  var isInitialStateOriginState = {
    name: 'isInitialStateOriginState',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref22) {
      var targetStatesMap = _ref22.targetStatesMap;

      if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {
        return {
          isFulfilled: false,
          blame: {
            message: "Found at least one transition with the initial state as target state! CF. log",
            info: {
              targetStates: Array.from(targetStatesMap.keys()),
              transitions: fsmDef.transitions
            }
          }
        };
      } else {
        return {
          isFulfilled: true,
          blame: void 0
        };
      }
    }
  }; // T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of
  // little practical value, though being a possible source of ambiguity or infinite loops)
  // A -_> A impossible on compound states because there is A -INIT-> X
  // so only possibility is A -_> A with A atomic state

  var isValidSelfTransition = {
    name: 'isValidSelfTransition',
    shouldThrow: false,
    predicate: function predicate(fsmDef, settings, _ref23) {
      var targetStatesMap = _ref23.targetStatesMap,
          statesType = _ref23.statesType;
      var targetStates = Array.from(targetStatesMap.keys());
      var wrongSelfTransitions = targetStates.map(function (targetState) {
        var flatTransitions = targetStatesMap.get(targetState);
        return flatTransitions.map(function (flatTransition) {
          var from = flatTransition.from,
              event = flatTransition.event;

          if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {
            return {
              state: targetState,
              flatTransition: flatTransition
            };
          }
        }).filter(Boolean);
      }).filter(function (x) {
        return x.length > 0;
      });
      return {
        isFulfilled: wrongSelfTransitions.length === 0,
        blame: {
          message: "Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log",
          info: {
            wrongSelfTransitions: wrongSelfTransitions
          }
        }
      };
    }
  };
  var fsmContracts = {
    injected: function injected(fsmDef, settings) {
      return {
        statesType: getStatesType(fsmDef.states),
        initTransition: findInitTransition(fsmDef.transitions),
        statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),
        stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),
        eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),
        ancestorMap: getAncestorMap(fsmDef.states),
        statesPath: getStatesPath(fsmDef.states),
        historyStatesMap: getHistoryStatesMap(fsmDef.transitions),
        targetStatesMap: getTargetStatesMap(fsmDef.transitions)
      };
    },
    description: 'FSM structure',
    contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates]
  };
  /**
   * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may
   * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing
   * contract data structure include relevant information about the failing contract, in particular the contract name,
   * the associated error message and additional info expliciting the error message.
   * @param contractsDef
   * @param settings
   * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}
   */

  function makeContractHandler(contractsDef, settings) {
    var console = settings && settings.debug && settings.debug.console || emptyConsole;
    var trace = settings && settings.debug && settings.debug.trace || noop;
    var contractsDescription = contractsDef.description;
    return function checkContracts() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var failingContracts = [];
      var computedArgs = contractsDef.injected.apply(null, args);
      var isFulfilled = contractsDef.contracts.reduce(function (acc, contract) {
        var contractName = contract.name,
            predicate = contract.predicate,
            shouldThrow = contract.shouldThrow;
        var fullArgs = args.concat(computedArgs);

        var _predicate$apply = predicate.apply(null, fullArgs),
            isFulfilled = _predicate$apply.isFulfilled,
            blame = _predicate$apply.blame;

        var blameMessageHeader = "".concat(contractsDescription, " FAILS ").concat(contractName, "!");

        var _ref24 = blame || {},
            message = _ref24.message,
            info = _ref24.info;

        if (isFulfilled) return acc;else {
          failingContracts.push({
            name: contractName,
            message: message,
            info: info
          });
          console.error(blameMessageHeader);
          console.error([contractName, message].join(': '));
          console.debug('Supporting error data:', info);
          if (shouldThrow) throw new Error([blameMessageHeader, "check console for information!"].join('\n'));else {
            return false;
          }
        }
      }, true);
      var contractsEval = {
        isFulfilled: isFulfilled,
        failingContracts: failingContracts
      };
      trace(_defineProperty({}, CONTRACTS_EVAL, contractsEval));
      return contractsEval;
    };
  } // @ts-ignore error here is due to variable number of arguments, not worth spending time there


  var fsmContractChecker = function fsmContractChecker(fsmDef, settings, fsmContracts) {
    return makeContractHandler(fsmContracts, settings)(fsmDef, settings);
  };
  function runContracts(_ref25, checkContracts, _ref26) {
    var fsmDef = _ref25.fsmDef,
        settings = _ref25.settings;
    var throwKinglyError = _ref26.throwKinglyError,
        tracer = _ref26.tracer;

    if (checkContracts) {
      var _fsmContractChecker = fsmContractChecker(fsmDef, settings, checkContracts),
          failingContracts = _fsmContractChecker.failingContracts;

      try {
        if (failingContracts.length > 0) throwKinglyError({
          when: "Attempting to create a Kingly machine",
          location: "createStateMachine",
          info: {
            fsmDef: fsmDef,
            settings: settings,
            failingContracts: failingContracts
          },
          message: "I found that one or more Kingly contracts are violated!"
        });
      } catch (e) {
        // Do not break the program, errors should be passed to console and dev tool
        tracer({
          type: MACHINE_CREATION_ERROR_MSG,
          trace: {
            info: e.errors,
            message: e.message,
            machineState: {
              cs: void 0,
              es: void 0,
              hs: void 0
            }
          }
        });
        return e;
      }
    }
  } // Terminology
  // . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`
  // For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,
  // guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition
  // uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be
  // referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.
  // . We write A < B if A is a substate of B, with the implication that B is hence a compound state
  // . We write A !< B if A is a direct substate of B
  // . We write A. !< B if A is a substate of B, and A is also an atomic state
  // . We write A -ev-> B to denote a transition from A to B triggered by `ev`
  // Behaviour
  // B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly
  // returning to the same state)
  // ENFORCED by T13, T4, T10, necessary for generative testing
  // B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress
  // the state machine.
  // NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird
  // ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice
  // B8. It is possible to reach any states
  // NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal

  function alwaysTrue() {
    return true;
  }
  /**
   * @description Processes the hierarchically nested states and returns miscellaneous objects derived from it:
   * `is_group_state`: Hash matching keys (state names) to whether that state is a nested state
   * `hash_states`: Hierarchically nested object whose properties are the nested states.
   * - Nested states inherit (prototypal inheritance) from the containing state.
   * - Holds a `history` property which holds a `last_seen_state` property which holds the latest
   * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a
   * state in another branch, then `last_seen_state` will be set to C for A, B and C
   * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root
   * state
   * `states` {Object<String,Boolean>} : Hash which maps every state name with itself
   * `states.history` {Object<String,Function>} : Hash which maps every state name with a function
   * whose name is the state name
   * @param states
   * @returns {{hashStates: {}, isGroupState: Object<String,Boolean>}}
   */

  function buildNestedStateStructure(states) {
    var root_name = "State";
    var hashStates = {};
    var isGroupState = {}; // Add the starting state

    states = {
      nok: states
    }; ////////
    // Helper functions

    function build_state_reducer(states, curr_constructor) {
      keys(states).forEach(function (state_name) {
        var state_config = states[state_name]; // The hierarchical state mechanism is implemented by reusing the standard Javascript
        // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as
        // prototype So when an event handler (transition) is put on A, that event handler will be
        // visible in B and C

        hashStates[state_name] = new curr_constructor();
        hashStates[state_name].name = state_name;
        var parent_name = hashStates[state_name].parent_name = get_fn_name(curr_constructor);
        hashStates[state_name].root_name = root_name;

        if (_typeof(state_config) === "object") {
          isGroupState[state_name] = true;

          var curr_constructor_new = function curr_constructor_new() {};

          curr_constructor_new.displayName = state_name;
          curr_constructor_new.prototype = hashStates[state_name];
          build_state_reducer(state_config, curr_constructor_new);
        }
      });
    }

    function State() {}

    State.prototype = {
      current_state_name: INIT_STATE
    };
    hashStates[INIT_STATE] = new State();
    hashStates[STATE_PROTOTYPE_NAME] = new State();
    build_state_reducer(states, State);
    return {
      hashStates: hashStates,
      isGroupState: isGroupState
    };
  }

  function normalizeTransitions(fsmDef) {
    var initialControlState = fsmDef.initialControlState,
        transitions = fsmDef.transitions;
    var initTransition = findInitTransition(transitions);

    if (initialControlState) {
      return transitions.concat([{
        from: INIT_STATE,
        event: INIT_EVENT,
        to: initialControlState,
        action: ACTION_IDENTITY
      }]);
    } else if (initTransition) {
      return transitions;
    }
  }
  /**
   *
   * @param {FSM_Def} fsmDef
   * @param {FSM_Settings} [settings]
   * @returns {Error | Stateful_FSM}
   */

  function createStateMachine(fsmDef, settings) {
    var res = createStateMachineAPIs(fsmDef, settings);
    if (res instanceof Error) return res;else return res.withProtectedState;
  }
  /**
   *
   * @param {FSM_Def} fsmDef
   * @param {FSM_Settings} settings
   * @returns {Error | Pure_FSM}
   */

  function createPureStateMachine(fsmDef, settings) {
    var res = createStateMachineAPIs(fsmDef, settings);
    if (res instanceof Error) return res;else return res.withPureInterface;
  }
  /**
   * @description Creates an instance of state machine from a set of states, transitions,
   * and accepted events. The initial extended state for the machine is included
   * in the machine definition.
   * @param {FSM_Def} fsmDef
   * @param {FSM_Settings} settings
   * @return {{withProtectedState: Stateful_FSM, withPureInterface: Pure_FSM}|Error}
   */

  function createStateMachineAPIs(fsmDef, settings) {
    var controlStates = fsmDef.states,
        events = fsmDef.events,
        initialExtendedState = fsmDef.initialExtendedState,
        userProvidedUpdateStateFn = fsmDef.updateState;

    var _ref = settings || {},
        debug = _ref.debug,
        devTool = _ref.devTool,
        displayName = _ref.displayName;

    var checkContracts = debug && debug.checkContracts || void 0;
    var console = debug && debug.console || emptyConsole;
    var tracer = devTool && devTool.tracer || emptyTracer;
    var throwKinglyError = throwKinglyErrorFactory(console, tracer); // Check contracts if the API user wants to,
    // but don't throw errors, return them and possibly log them

    if (checkContracts) {
      var e = runContracts({
        fsmDef: fsmDef,
        settings: settings
      }, checkContracts, {
        throwKinglyError: throwKinglyError,
        tracer: tracer
      });
      if (e instanceof Error) return e;
    } // Wrap user-provided update state function to capture errors


    var wrappedUpdateState = wrapUpdateStateFn(userProvidedUpdateStateFn, {
      throwKinglyError: throwKinglyError,
      tracer: tracer
    }); // We also massage the shape of the user-provided transitions,
    // unifying the two ways of providing an initial state for the machine

    var transitions = normalizeTransitions(fsmDef); // Create auxiliary data structures to quickly answer common queries:
    // - is `stateName` a state that has an initial transition configured
    //   (top-level, or compound state) : `isInitState[stateName]`
    // - is `stateName` a transient state, i.e. with an configured
    //   initial or eventless transitions: `isAutoState[stateName]`
    // - is `stateName` a compound state: `isGroupState[stateName]`
    // - what computation to run in `stateName`:
    //   `hashStates[stateName][event]` has the event handler for `event`
    //    NOTE: we use JS prototypal inheritance to make this work even when
    //    A < ... < B. and the event handler in configured on parent A, and not on B
    //    When the machine is in state B, it must answer to the event as A would

    var hashStatesStruct = buildNestedStateStructure(controlStates); // @type {Object<state_name,boolean>}

    var isInitState$$1 = {}; // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined
    // that would be init transitions + eventless transitions

    var isAutoState = {}; // @type {Object<state_name,boolean>}

    var isGroupState = hashStatesStruct.isGroupState;
    var hashStates = hashStatesStruct.hashStates; // Fill in the auxiliary data structures

    transitions.forEach(function (transition) {
      var from = transition.from,
          to = transition.to,
          action = transition.action,
          event = transition.event,
          arr_predicate = transition.guards; // CASE: ZERO OR ONE condition set

      if (!arr_predicate) arr_predicate = [{
        predicate: void 0,
        to: to,
        action: action
      }]; // CASE: transition has a init event
      // NOTE: there should ever only be one, but we don't enforce it here

      if (event === INIT_EVENT) {
        isInitState$$1[from] = true;
      }

      var from_proto = hashStates[from]; // CASE: automatic transitions: no events - likely a transient state with only conditions

      if (!event) {
        event = AUTO_EVENT;
        isAutoState[from] = true;
      } // CASE: automatic transitions : init event automatically fired upon entering a grouping state


      if (isGroupState[from] && isInitState$$1[from]) {
        isAutoState[from] = true;
      } // NTH: this seriously needs refactoring, that is one line in ramda


      from_proto[event] = arr_predicate.reduce(function (acc, guard, index) {
        var action = guard.action || ACTION_IDENTITY;
        var actionName = action.name || action.displayName || "";

        var condition_checking_fn = function (guard, settings) {
          var condition_suffix = ""; // We add the `current_state` because the current control state might be different from
          // the `from` field here This is the case for instance when we are in a substate, but
          // through prototypal inheritance it is the handler of the prototype which is called

          var condition_checking_fn = function condition_checking_fn(extendedState_, event_data, current_state) {
            from = current_state || from;
            var predicate = guard.predicate || alwaysTrue;
            var predicateName = predicate.name || predicate.displayName || "<anonymous>";
            var to = guard.to;

            var shouldTransitionBeTaken = function (extendedState, event_data, settings) {
              try {
                return predicate(extendedState, event_data, settings);
              } catch (e) {
                throwKinglyError({
                  when: "Executing predicate function ".concat(predicateName),
                  location: "createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken",
                  info: {
                    extendedState: extendedState,
                    event: event,
                    event_data: event_data,
                    settings: settings,
                    guard: guard,
                    from: from,
                    to: to,
                    index: index
                  },
                  message: ["Error occurred while processing event ".concat(event, " with target state ").concat(to), e.message].join("\n"),
                  stack: e.stack
                });
              }
            }(extendedState_, event_data, settings);

            if (typeof shouldTransitionBeTaken !== "boolean") {
              throwKinglyError({
                when: "Executing predicate function ".concat(predicateName),
                location: "createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult",
                info: {
                  event: event,
                  guard: guard,
                  from: from,
                  to: to,
                  index: index,
                  shouldTransitionBeTaken: shouldTransitionBeTaken
                },
                message: "Guard index ".concat(index, " with name ").concat(predicateName, " did not return a boolean!")
              });
            }

            if (shouldTransitionBeTaken) {
              // CASE : guard for transition is fulfilled so we can execute the actions...
              console.info("IN STATE ", from);

              if (guard.predicate) {
                tracer({
                  type: DEBUG_MSG,
                  trace: {
                    message: "The guard ".concat(predicateName, " is fulfilled"),
                    info: {
                      eventData: event_data,
                      from: from,
                      action: actionName,
                      to: to
                    },
                    machineState: {
                      cs: current_state,
                      es: extendedState_,
                      hs: history
                    }
                  }
                });
                console.info("CASE: guard ".concat(predicate.name, " for transition is fulfilled"));
              } else {
                tracer({
                  type: DEBUG_MSG,
                  trace: {
                    message: "Evaluating transition with no guards",
                    info: {
                      eventData: event_data,
                      from: from,
                      action: actionName,
                      to: to
                    },
                    machineState: {
                      cs: current_state,
                      es: extendedState,
                      hs: history
                    }
                  }
                });
                console.info("CASE: unguarded transition");
              }

              console.info("THEN : we execute the action " + actionName);

              var actionResult = function (extendedState, eventData, settings) {
                try {
                  return action(extendedState, eventData, settings);
                } catch (e) {
                  throwKinglyError({
                    when: "Executing action factory ".concat(actionName),
                    location: "createStateMachine > event handler > condition_checking_fn",
                    info: {
                      extendedState: extendedState,
                      event: event,
                      event_data: event_data,
                      settings: settings,
                      guard: guard,
                      from: from,
                      to: to,
                      index: index,
                      action: action
                    },
                    message: e.message,
                    stack: e.stack
                  });
                }
              }(extendedState_, event_data, settings);

              if (!isActions(actionResult)) {
                throwKinglyError({
                  when: "Executing action factory ".concat(actionName),
                  location: "createStateMachine > event handler > condition_checking_fn",
                  info: {
                    extendedState: extendedState,
                    event: event,
                    event_data: event_data,
                    settings: settings,
                    guard: guard,
                    from: from,
                    to: to,
                    index: index,
                    action: action,
                    actionResult: actionResult
                  },
                  message: "Action factory returned a value that does not have the expected shape!"
                });
              }

              var updates = actionResult.updates,
                  outputs = actionResult.outputs; // Leave the current state

              leaveState(from, extendedState_, hashStates); // Update the extendedState before entering the next state

              extendedState = wrappedUpdateState(extendedState_, updates); // ...and enter the next state (can be different from `to` if we have nesting state group)

              var newControlState = enterNextState(to, updates, hashStates);
              console.info("ENTERING NEXT STATE: ", cs);
              console.info("with extended state: ", extendedState); // allows for chaining and stop chaining guard

              return {
                stop: true,
                outputs: outputs
              };
            } else {
              // CASE : guard for transition is not fulfilled
              tracer({
                type: DEBUG_MSG,
                trace: {
                  message: guard.predicate ? "The guard ".concat(predicateName, " is not fulfilled!") : "Evaluated and skipped transition",
                  info: {
                    eventData: event_data,
                    settings: settings,
                    guard: guard,
                    from: from,
                    to: to,
                    index: index,
                    action: actionName
                  },
                  machineState: {
                    cs: current_state,
                    es: extendedState,
                    hs: history
                  }
                }
              });
              return {
                stop: false,
                outputs: null
              };
            }
          };

          condition_checking_fn.displayName = from + condition_suffix;
          return condition_checking_fn;
        }(guard, settings);

        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {
          var condition_checked = acc(extendedState_, event_data, current_state);
          return condition_checked.stop ? condition_checked : condition_checking_fn(extendedState_, event_data, current_state);
        };
      }, function dummy() {
        return {
          stop: false,
          outputs: null
        };
      });
    }); // Setting up the initial state of the machine in closure
    // That is the control state, history state, and extended state
    // NOTE: the user-provided update function by contract cannot update in place
    // There is thus no need to clone the initial extended state.

    var _computeHistoryMaps = computeHistoryMaps(controlStates),
        stateList = _computeHistoryMaps.stateList,
        stateAncestors = _computeHistoryMaps.stateAncestors;

    var history = initHistoryDataStructure(stateList);
    var extendedState = initialExtendedState;
    var cs = INIT_STATE; // Run the machine's initial transition

    try {
      start();
    } catch (e) {
      // Do not break the program, errors should be passed to console and dev tool
      tracer({
        type: MACHINE_CREATION_ERROR_MSG,
        trace: {
          message: e.message,
          info: {
            fsmDef: fsmDef,
            settings: settings,
            error: e
          },
          machineState: {
            cs: INIT_STATE,
            es: extendedState,
            hs: history
          }
        }
      });
      console && console.error("An error occurred when starting the machine", e);
      return e;
    }

    var fsmAPIs = {
      /**
       * @description This function encapsulates the behavior of a state machine. The function receives the input to be
       *   processed by the machine, and outputs the results of the machine computation. In the general case, the machine
       *   computes an array of values. The array can be empty, and when not, it may contain null values. The machine may
       *   also return null (in csae of an input that the machine is not configured to react to) instead of returning an
       *   array.
       * @param {*} input
       * @returns {FSM_Outputs|Error}
       * @throws if an error is produced that is not an error recognized by Kingly. This generally means an unexpected
       *   exception has occurred.
       */
      withProtectedState: function fsm(input) {
        try {
          var _destructureEvent = destructureEvent(input),
              eventName = _destructureEvent.eventName,
              eventData = _destructureEvent.eventData;

          tracer({
            type: INPUT_MSG,
            trace: {
              info: {
                eventName: eventName,
                eventData: eventData
              },
              machineState: {
                cs: cs,
                es: extendedState,
                hs: history
              }
            }
          });
          var outputs = sendEvent(input, false);
          debug && console.info("OUTPUTS:", outputs);
          tracer({
            type: OUTPUTS_MSG,
            trace: {
              outputs: outputs,
              machineState: {
                cs: cs,
                es: extendedState,
                hs: history
              }
            }
          });
          return outputs;
        } catch (e) {
          if (e instanceof KinglyError) {
            // We don't break the program, but we can't continue as if nothing happened: we return the error
            tracer({
              type: ERROR_MSG,
              trace: {
                error: e,
                message: "An error ocurred while running an input through the machine!",
                machineState: {
                  cs: cs,
                  es: extendedState,
                  hs: history
                }
              }
            });
            return e;
          } else {
            tracer({
              type: ERROR_MSG,
              trace: {
                error: e,
                message: "An unknown error ocurred while running an input through the machine!",
                machineState: {
                  cs: cs,
                  es: extendedState,
                  hs: history
                }
              }
            });
            console.error("yyield > unexpected error!", e); // We should only catch the errors we are responsible for!

            throw e;
          }
        }
      },

      /**
       * @description This function encapsulates the behavior of a state machine but requires to be passed both the
       *   machine internal state and an input from which to compute the machine outputs. According to the parameter
       *   passed as internal state, the machine may: 1. (undefined) compute outputs from the last state of the machine,
       *   1. (null) compute outputs, restarting from its initial state, 3. (truthy) compute outputs from the given state
       *   of the machine
       * @param {*} input
       * @param {FSM_Internal_State} fsmState
       * @returns {{outputs: FSM_Outputs|Error, fsmState: FSM_Internal_State}}
       */
      withPureInterface: function compute(input, fsmState) {
        if (fsmState === void 0) ; else if (fsmState === null) {
          // Reinitialize the machine
          extendedState = initialExtendedState;
          history = initHistoryDataStructure(stateList);
          hashStates[INIT_STATE].current_state_name = INIT_STATE;
          start();
        } else {
          // Reset the state (available in closure) of the state machine
          var _cs = fsmState.cs,
              hs = fsmState.hs,
              es = fsmState.es;
          extendedState = es;
          history = hs;
          cs = _cs;
        } // run the machine


        var outputs = fsmAPIs.withProtectedState(input); // NOTE: history does not need to be cloned here! We do not update the
        // history in place => No risk of accidentally modifying the history
        // of another machine
        // TODO: We should however definitely clone `extendedState` How to modify the API?
        // Require a clone function in settings? with a default of JSON.stringify?
        // or we shift the responsibility on the API user to do the cloning?
        // Good: faster in the default case, simpler library too, no cloning when not needed
        // Bad: library user can forget, so footgun...
        // ADR: API that forces to signal a clone function, which can be DEFAULT_CLONE

        return {
          outputs: outputs,
          fsmState: {
            cs: cs,
            hs: history,
            es: extendedState
          }
        };
      }
    };
    return fsmAPIs; // Auxiliary functions
    //

    /**
     *
     * @param {function(...*): True | Error} contract
     * @param {Array<*>} arrayParams
     * @returns {undefined}
     * @throws KinglyError in case of one or more failing contracts
     */

    function assertContract(contract, arrayParams) {
      var hasFailed = assert(contract, arrayParams);

      if (checkContracts && hasFailed) {
        throwKinglyError(hasFailed);
      }

      return void 0;
    }
    /**
     * @description process an input (aka event) according to the machine specifications.
     * @param {LabelledEvent} event_struct input to be processed by the machine
     * @param {Boolean} isInternalEvent should be true iff the event is sent by Kingly, not by the
     * API user. API user should always leave this undefined.
     * This works around an edge case discovered through testing.
     * With the fix implemented here, API users that send an INIT_EVENT will have it ignored.
     * INIT_EVENT is reserved and API users should not use it. This fix is for robustness purposes.
     * @returns {FSM_Outputs|null}
     */


    function sendEvent(event_struct, isInternalEvent) {
      assertContract(isEventStruct, [event_struct]);

      var _destructureEvent2 = destructureEvent(event_struct),
          eventName = _destructureEvent2.eventName,
          eventData = _destructureEvent2.eventData;

      console.group("send event " + eventName || "");
      console.log(event_struct); // Edge case to deal with: INIT_EVENT sent and the current state is the initial state
      // This is a side-effect of our implementation that leverages JS prototypes.
      // The INIT_STATE is a super-state of all states in the machine. Hence sending an INIT_EVENT
      // would always execute the INIT transition by prototypal delegation.
      // This led to a bug where an API user would maliciously send the reserved INIT_EVENT,
      // thus resetting the machine in its initial state, with an unpredictable extended state!
      // That, in turn, results from a **design mistake** that I will not correct here, which consisted
      // in letting API users configure an initial control state, OR initial INIT_EVENT transitions.
      // ADR: the impact is small, the fix is ok. API users have more flexibility at the
      // cost of implementation complexity. But next time, pick simplicity over flexibility.

      if (!isInternalEvent && eventName === INIT_EVENT && cs !== INIT_STATE) {
        tracer({
          type: WARN_MSG,
          trace: {
            info: {
              eventName: eventName,
              eventData: eventData
            },
            message: "The external event INIT_EVENT can only be sent when starting the machine!",
            machineState: {
              cs: cs,
              es: extendedState,
              hs: history
            }
          }
        });
        console.warn("The external event INIT_EVENT can only be sent when starting the machine!");
        console.groupEnd();
        return null;
      }

      var outputs = processEvent(hashStatesStruct.hashStates, eventName, eventData, extendedState);
      console.groupEnd();
      return outputs;
    }

    function processEvent(hashStates, event, eventData, extendedState) {
      var oldCurrentState = cs;
      var eventHandler = hashStates[oldCurrentState][event]; // CASE : There is a transition associated to that event

      if (eventHandler) {
        console.log("found event handler!");
        console.info("WHEN EVENT ", event, eventData); // The transition is evaluated:
        // - no guards are satisfied => outputs = null
        // - guards satisfied => outputs an array, possibly containing a null value

        /** OUT: this event handler modifies the in-closure machine state (extendedState, cs, history state) */

        var _eventHandler = eventHandler(extendedState, eventData, oldCurrentState),
            stop = _eventHandler.stop,
            rawOutputs = _eventHandler.outputs;

        var newControlState = cs;
        debug && !stop && console.warn("No guards have been fulfilled! We recommend to configure guards explicitly to" + " cover the full state space!");
        var outputs = arrayizeOutput(rawOutputs); // Two cases here:
        // 1. Init handlers, when present on the new control state, must be acted on immediately
        // This allows for sequence of init events in various state levels
        // For instance, L1:init -> L2:init -> L3:init -> L4: stateX
        // In this case, eventData will be passed on every INIT_EVENT
        // 2. eventless transitions
        // NOTE : the inside guard is to defend against loops occuring when an AUTO transition fails to advance and stays
        // in the same control state!! But by contract that should never happen: all AUTO transitions should advance!

        if (isAutoState[newControlState]) {
          if (newControlState !== oldCurrentState) {
            var auto_event = isInitState$$1[newControlState] ? INIT_EVENT : AUTO_EVENT;
            tracer({
              type: INTERNAL_INPUT_MSG,
              trace: {
                info: {
                  eventName: auto_event,
                  eventData: eventData
                },
                event: _defineProperty({}, auto_event, eventData),
                machineState: {
                  cs: cs,
                  es: extendedState,
                  hs: history
                }
              }
            });
            var nextOutputs = sendEvent(_defineProperty({}, auto_event, eventData), true);
            tracer({
              type: INTERNAL_OUTPUTS_MSG,
              trace: {
                outputs: nextOutputs,
                machineState: {
                  cs: cs,
                  es: extendedState,
                  hs: history
                }
              }
            });
            return [].concat(outputs).concat(nextOutputs);
          } else {
            // We found an eventless transition that returns to the same control state!
            // This is forbidden as this may generate infinite loops on that stationary control state
            // We throw in that case, as this is a breach of contract, one which we should
            // detect at configuration time.
            console.error("Eventless transitions (event |".concat(event, "| in state |").concat(cs, "|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops."));
            tracer({
              type: ERROR_MSG,
              trace: {
                info: {
                  received: _defineProperty({}, event, eventData)
                },
                message: "Eventless transitions (event |".concat(event, "| in state |").concat(cs, "|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops."),
                machineState: {
                  cs: cs,
                  es: extendedState,
                  hs: history
                }
              }
            });
          }
        } else return outputs;
      } // CASE : There is no transition associated to that event from that state
      else {
          console.warn("There is no transition associated to the event |".concat(event, "| in state |").concat(cs, "|!"));
          tracer({
            type: WARN_MSG,
            trace: {
              info: {
                received: _defineProperty({}, event, eventData)
              },
              message: "There is no transition associated to the event |".concat(event, "| in state |").concat(cs, "|!"),
              machineState: {
                cs: cs,
                es: extendedState,
                hs: history
              }
            }
          });
          return null;
        }
    }

    function leaveState(from, extendedState, hash_states) {
      history = updateHistory(history, stateAncestors, hash_states[from].name);
      console.info("left state", wrap(from));
    }

    function enterNextState(to, updatedExtendedState, hash_states) {
      var targetStateName; // CASE: history state (H)

      if (isHistoryControlState(to)) {
        var historyType = to[DEEP] ? DEEP : to[SHALLOW] ? SHALLOW : void 0;
        var historyTarget = to[historyType]; // Contract: history state MUST be associated to compound state (else there is no history to be had)

        if (!isInitState$$1[historyTarget]) {
          var message = "Configured a history state unrelated to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration";
          debug && console && console.error(message);
          throwKinglyError({
            message: message
          });
        } // Edge case: If there is no history for the compound state, then we evaluate the
        // initial transition for that compound state, i.e. we set that state as target state


        targetStateName = history[historyType][historyTarget] || historyTarget;
      } // CASE: not a history state
      else if (to) {
          targetStateName = hash_states[to].name;
        } // Dead branch: should never happen
        else {
            throwKinglyError({
              message: "enter_state : unknown case! Not a state name, and not a history state to enter!"
            });
          }

      cs = targetStateName;
      tracer({
        type: DEBUG_MSG,
        trace: {
          message: isHistoryControlState(to) ? "Entering history state for ".concat(to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]) : "Entering state ".concat(to),
          machineState: {
            cs: cs,
            es: extendedState,
            hs: history
          }
        }
      });
      debug && console.info("AND TRANSITION TO STATE", targetStateName);
      return targetStateName;
    }

    function start() {
      tracer({
        type: INIT_INPUT_MSG,
        trace: {
          info: {
            eventName: INIT_EVENT,
            eventData: initialExtendedState
          },
          event: _defineProperty({}, INIT_EVENT, initialExtendedState),
          machineState: {
            cs: cs,
            es: extendedState,
            hs: history
          }
        }
      });
      return sendEvent(_defineProperty({}, INIT_EVENT, initialExtendedState), true);
    }
  }
  /**
   * @typedef {Object} WebComponentFactoryParams
   * @property {String} name Name for the web component. Must include at least one hyphen per custom
   * components' specification
   * @property {Subject} eventHandler A factory function which returns a subject, i.e. an object which
   * implements the `Observer` and `Observable` interface
   * @property {Stateful_FSM} fsm An executable machine, i.e. a function which accepts machine inputs
   * @property {Object.<CommandName, CommandHandler>} commandHandlers
   * @property {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an
   *   effect moniker to a function performing the corresponding effect.
   * @property {{initialEvent, terminalEvent, NO_ACTION}} options
   */

  /**
   * @param {WebComponentFactoryParams} webComponentFactoryParams
   */

  function makeWebComponentFromFsm(_ref2) {
    var name = _ref2.name,
        eventHandler = _ref2.eventHandler,
        fsm = _ref2.fsm,
        commandHandlers = _ref2.commandHandlers,
        effectHandlers = _ref2.effectHandlers,
        options = _ref2.options;

    var FsmComponent =
    /*#__PURE__*/
    function (_HTMLElement) {
      _inherits(FsmComponent, _HTMLElement);

      function FsmComponent() {
        var _this;

        _classCallCheck(this, FsmComponent);

        if (name.split('-').length <= 1) throw "makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!";
        _this = _possibleConstructorReturn(this, _getPrototypeOf(FsmComponent).call(this));

        var el = _assertThisInitialized(_this);

        _this.eventSubject = eventHandler;
        _this.options = Object.assign({}, options);
        var NO_ACTION = _this.options.NO_ACTION || null; // Set up execution of commands

        _this.eventSubject.subscribe({
          next: function next(eventStruct) {
            var actions = fsm(eventStruct);

            if (actions instanceof Error) {
              // NOTE: we do not throw here, the web component will fail but
              // the rest of the page may go on. We log and swallow the errors
              console && console.log(actions);
            } else if (actions === NO_ACTION) return;else {
              actions.forEach(function (action) {
                if (action === NO_ACTION) return;
                var command = action.command,
                    params = action.params;
                commandHandlers[command](_this.eventSubject.next, params, effectHandlers, el);
              });
            }
          }
        });

        return _this;
      }

      _createClass(FsmComponent, [{
        key: "connectedCallback",
        value: function connectedCallback() {
          this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);
        }
      }, {
        key: "disconnectedCallback",
        value: function disconnectedCallback() {
          this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);
          this.eventSubject.complete();
        }
      }, {
        key: "attributeChangedCallback",
        value: function attributeChangedCallback(name, oldValue, newValue) {// There are no attributes
        }
      }], [{
        key: "observedAttributes",
        get: function get() {
          // There are no attributes
          return [];
        }
      }]);

      return FsmComponent;
    }(_wrapNativeSuper(HTMLElement));

    return customElements.define(name, FsmComponent);
  }
  function historyState(historyType, controlState) {
    return _defineProperty({}, historyType, controlState);
  }

  function generateStatePlantUmlHeader(state, optDisplayName) {
    return optDisplayName ? "state \"".concat(optDisplayName, "\" as ").concat(state, " <<NoContent>>") : "state \"".concat(getDisplayName(state), "\" as ").concat(state, " <<NoContent>>");
  }
  /**
   * Converts a transducer definition to a textual format for interpretation by PlantUml tools
   * @param {FSM_Def} fsmDef
   * @param {*} settings
   */


  function toPlantUml(fsmDef, settings) {
    var states = fsmDef.states,
        transitions = fsmDef.transitions;
    var getChildren = objectTreeLenses.getChildren,
        getLabel = objectTreeLenses.getLabel;

    var stringify = function stringify(path) {
      return path.join(SEP);
    };

    var getChildrenNumber = function getChildrenNumber(tree, traversalState) {
      return getChildren(tree, traversalState).length;
    };

    var traverse = {
      seed: function seed() {
        return Map;
      },
      visit: function visit(pathMap, traversalState, tree) {
        var _traversalState$get = traversalState.get(tree),
            path = _traversalState$get.path;

        var treeLabel = getLabel(tree);
        var controlState = Object.keys(treeLabel)[0];
        var childrenTranslation = times$1(function (index) {
          return pathMap.get(stringify(path.concat(index)));
        }, getChildrenNumber(tree, traversalState));
        var translation = stateToPlantUML(controlState, childrenTranslation, transitions);
        pathMap.set(stringify(path), translation);
        return pathMap;
      }
    };
    var translationMap = postOrderTraverseTree(objectTreeLenses, traverse, _defineProperty({}, INIT_STATE, states));
    var mappedTree = translationMap.get('0');
    translationMap.clear();
    return mappedTree;
  }
  /**
   * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and
   * its nested hierarchy
   * @param {ControlState} controlState
   * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state
   * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs
   * CONTRACT : All control states must have different names...
   */

  function stateToPlantUML(controlState, childrenTranslation, transitions) {
    return ["".concat(generateStatePlantUmlHeader(controlState, ''), " {"), childrenTranslation.join('\n'), format_history_states(controlState, transitions), format_entry_transitions(controlState, transitions), "}", translate_transitions(controlState, transitions)].filter(function (x) {
      return x !== '\n' && x !== '';
    }).join('\n');
  }

  function format_history_states(controlState, transitions) {
    // creates the history states as orig.dest.H
    // e.g.  state "H" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>
    var historyStatesObj = transitions.reduce(function (accTranslation, transition) {
      var allTransitions = get_all_transitions(transition);
      return allTransitions.filter(is_history_transition).filter(is_to_history_control_state_of(controlState)).reduce(function (acc, transition) {
        acc[format_history_transition_state_name(transition)] = void 0;
        return acc;
      }, accTranslation);
    }, {});
    var historyStates = Object.keys(historyStatesObj);
    return historyStates.map(function (historyState) {
      return "".concat(generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME));
    }).join('\n');
  }

  function translate_transitions(controlState, transitions) {
    var historyTransitionTranslation = format_history_transitions(controlState, transitions);
    var standardTransitionTranslation = format_standard_transitions(controlState, transitions);
    return [historyTransitionTranslation, standardTransitionTranslation].filter(Boolean).join('\n');
  }

  function format_standard_transitions(controlState, transitions) {
    // The only transition from initial state are INIT transitions and that's already taken care of elsewhere
    if (controlState === INIT_STATE) return '';else return transitions.map(function (transition) {
      var allTransitions = get_all_transitions(transition);
      return allTransitions.filter(is_from_control_state(controlState)).filter(function (transition) {
        return !is_entry_transition(transition);
      }).filter(function (transition) {
        return !is_history_transition(transition);
      }).map(function (_ref) {
        var from = _ref.from,
            event = _ref.event,
            predicate = _ref.predicate,
            to = _ref.to,
            action = _ref.action;
        return [from, TRANSITION_SYMBOL, to, TRANSITION_LABEL_START_SYMBOL, format_transition_label(event, predicate, action)].join(' ');
      }).join('\n');
    }) // necessary because [].join('\n') is "" so I need to take those out to avoid unnecessary '\n' down the road
    .filter(Boolean).join('\n');
  }

  function format_entry_transitions(controlState, transitions) {
    var translation = transitions.reduce(function (accTranslation, transition) {
      var allTransitions = get_all_transitions(transition);
      return allTransitions.filter(is_entry_transition).filter(is_from_control_state(controlState)).reduce(function (acc, transition) {
        var from = transition.from,
            to = transition.to,
            predicate = transition.predicate,
            action = transition.action;
        acc.push("[*] ".concat(TRANSITION_SYMBOL, " ").concat(to, " ").concat(TRANSITION_LABEL_START_SYMBOL, " ").concat(format_transition_label("", predicate, action)));
        return acc;
      }, accTranslation);
    }, []);
    return translation.join('\n');
  }

  function format_history_transitions(controlState, transitions) {
    return transitions.map(function (transition) {
      var allTransitions = get_all_transitions(transition);
      return allTransitions.filter(is_from_control_state(controlState)).filter(is_history_transition).map(function (_ref2) {
        var from = _ref2.from,
            event = _ref2.event,
            predicate = _ref2.predicate,
            to = _ref2.to,
            action = _ref2.action;
        return [from, TRANSITION_SYMBOL, format_history_transition_state_name({
          from: from,
          to: to
        }), TRANSITION_LABEL_START_SYMBOL, format_transition_label(event, predicate, action)].join(' ');
      }).join('\n');
    }).filter(Boolean).join('\n');
  }

  function toDagreVisualizerFormat(fsmDef) {
    // only thing to do here is to replace functions (guards and actions) by their name, and keep only
    // the states and transitions properties
    // ah no I also need to turn the states obj tree into an array-based tree... grrr
    var states = fsmDef.states,
        transitions = fsmDef.transitions;
    var getLabel = objectTreeLenses.getLabel,
        getChildren = objectTreeLenses.getChildren;
    var constructTree = arrayTreeLenses.constructTree;

    var getChildrenNumber = function getChildrenNumber(tree, traversalState) {
      return getChildren(tree, traversalState).length;
    };

    var stringify = function stringify(path) {
      return path.join(SEP);
    };

    var traverse = {
      seed: function seed() {
        return Map;
      },
      visit: function visit(pathMap, traversalState, tree) {
        var _traversalState$get2 = traversalState.get(tree),
            path = _traversalState$get2.path;

        var treeLabel = getLabel(tree);
        var controlState = Object.keys(treeLabel)[0];
        var children = times$1(function (index) {
          return pathMap.get(stringify(path.concat(index)));
        }, getChildrenNumber(tree, traversalState));
        pathMap.set(stringify(path), constructTree(controlState, children));
        return pathMap;
      }
    };

    var _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, _defineProperty({}, INIT_STATE, states));

    var translatedStates = _translatedStates.get('0');

    var translatedTransitions = transitions.map(function (transition) {
      var from = transition.from,
          to = transition.to,
          event = transition.event,
          guards = transition.guards,
          action = transition.action;

      if (guards) {
        var translatedGuards = guards.map(function (guard) {
          var predicate = guard.predicate,
              to = guard.to,
              action = guard.action;
          return {
            predicate: predicate.name,
            to: to,
            action: action.name
          };
        });
        return {
          from: from,
          event: event,
          guards: translatedGuards
        };
      } else {
        // case {from, to event, action}
        return {
          from: from,
          to: to,
          event: event,
          action: action.name || 'no action name?'
        };
      }
    });
    return JSON.stringify({
      states: translatedStates,
      transitions: translatedTransitions
    });
  }

  // TODO : export only the two/three functions part of the API! might require updating tests imports

  exports.createStateMachine = createStateMachine;
  exports.createPureStateMachine = createPureStateMachine;
  exports.makeWebComponentFromFsm = makeWebComponentFromFsm;
  exports.historyState = historyState;
  exports.ACTION_IDENTITY = ACTION_IDENTITY;
  exports.INIT_EVENT = INIT_EVENT;
  exports.INIT_STATE = INIT_STATE;
  exports.SHALLOW = SHALLOW;
  exports.DEEP = DEEP;
  exports.NO_STATE_UPDATE = NO_STATE_UPDATE;
  exports.NO_OUTPUT = NO_OUTPUT;
  exports.computeHistoryMaps = computeHistoryMaps;
  exports.initHistoryDataStructure = initHistoryDataStructure;
  exports.fsmContracts = fsmContracts;
  exports.toPlantUml = toPlantUml;
  exports.toDagreVisualizerFormat = toDagreVisualizerFormat;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=kingly.umd.js.map
