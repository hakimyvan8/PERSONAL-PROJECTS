{"version":3,"sources":["..\\node_modules\\process\\browser.js","..\\node_modules\\qunitjs\\qunit\\qunit.js","_tree.specs.js"],"names":["process","module","exports","cachedSetTimeout","cachedClearTimeout","defaultSetTimout","Error","defaultClearTimeout","setTimeout","e","clearTimeout","runTimeout","fun","call","runClearTimeout","marker","queue","draining","currentQueue","queueIndex","cleanUpNextTick","length","concat","drainQueue","timeout","len","run","nextTick","args","Array","arguments","i","push","Item","array","prototype","apply","title","browser","env","argv","version","versions","noop","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","name","binding","cwd","chdir","dir","umask","QUnit","global","Date","now","getTime","window","defined","document","undefined","sessionStorage","x","setItem","removeItem","fileName","sourceFromStacktrace","replace","globalStartCalled","runStarted","toString","Object","hasOwn","hasOwnProperty","diff","a","b","j","result","slice","splice","inArray","elem","indexOf","objectValues","obj","key","val","vals","is","extend","undefOnly","prop","objectType","match","type","isNaN","toLowerCase","extractStacktrace","offset","stack","include","split","test","shift","join","sourceURL","line","error","err","config","blocking","reorder","altertitle","collapse","scrolltop","maxDepth","requireExpects","urlConfig","modules","moduleStack","currentModule","tests","callbacks","loggingCallbacks","registerLoggingCallbacks","l","callbackNames","registerLoggingCallback","loggingCallback","callback","runLoggingCallbacks","verifyLoggingCallbacks","userCallback","console","warn","onErrorFnPrev","onerror","filePath","linerNr","ret","current","ignoreGlobalErrors","pushFailure","validTest","isLocal","location","protocol","testEnvironment","executeNow","moduleFns","setup","beforeEach","teardown","afterEach","createModule","setHook","setCurrentModule","pop","parentModule","moduleName","moduleId","generateHash","asyncTest","skip","only","start","count","globalStartAlreadyCalled","autostart","pageLoaded","semaphore","resumeProcessing","stop","pauseProcessing","load","stats","all","bad","moduleStats","started","updateRate","filter","begin","modulesLog","totalTests","Test","last","next","depth","usedAsync","done","testTimeout","runtime","passed","autorun","previousModule","failed","total","hookName","focused","priorityCount","unitSampler","settings","assertions","testName","testId","async","expected","assert","Assert","before","pollution","saveGlobal","promise","callbackStarted","notrycatch","runTest","message","resolvePromise","after","checkPollution","queueHook","hook","runHook","callHook","hooks","handler","processHooks","finish","skipped","source","duration","reset","priority","valid","synchronize","reverse","getItem","seed","pushResult","resultInfo","details","actual","negative","phase","then","regexFilter","exec","fullName","moduleChainNameMatch","testModule","testModuleName","moduleChainIdMatch","stringFilter","exclude","pattern","flags","regex","RegExp","charAt","fixture","getElementById","innerHTML","currentTest","hex","hash","str","charCodeAt","index","unitSamplerGenerator","Math","floor","sample","parseInt","noglobals","newGlobals","deletedGlobals","old","newTest","testContext","expect","asserts","popped","acceptCallCount","currentAssert","ok","dump","parse","notOk","equal","notEqual","propEqual","equiv","notPropEqual","deepEqual","notDeepEqual","strictEqual","notStrictEqual","block","expectedType","expectedOutput","errorString","constructor","raises","resultErrorString","substring","callers","parents","parentsB","getProto","getPrototypeOf","__proto__","useStrictEquality","valueOf","compareConstructors","protoA","protoB","getRegExpFlags","regexp","caller","loop","aCircular","bCircular","innerEquiv","innerEq","outerEq","size","forEach","aVal","bVal","aKey","bKey","eq","aProperties","bProperties","sort","typeEquiv","quote","literal","o","pre","arr","post","s","separator","base","indent","inner","up","down","reName","objType","res","parser","parserType","inStack","typeOf","parsers","setInterval","nodeType","item","multiline","HTML","extra","chr","indentChar","setParser","unknown","fn","nodelist","object","map","keys","nonEnumerableProperties","node","open","close","tag","nodeName","attrs","attributes","nodeValue","functionArgs","String","fromCharCode","functionCode","attribute","string","date","number","jsDump","applyCurrent","define","amd","urlParams","getUrlParams","random","id","label","tooltip","option","param","value","params","search","decodeURIComponent","init","appendInterface","collapseNext","unfilteredUrl","setUrl","modulesList","escapeText","addEvent","addEventListener","attachEvent","event","target","srcElement","addEvents","elems","hasClass","className","addClass","toggleClass","force","removeClass","set","trim","getUrlConfigHtml","escaped","escapedTooltip","selection","urlConfigHtml","toolbarChanged","updatedUrl","field","options","selectedIndex","checked","defaultValue","history","replaceState","arrValue","querystring","encodeURIComponent","host","pathname","applyUrlParams","selectedModule","toolbarUrlConfigContainer","urlConfigContainer","createElement","getElementsByTagName","toolbarLooseFilter","input","button","appendChild","ev","preventDefault","toolbarModuleFilterHtml","moduleFilterHtml","toolbarModuleFilter","toolbar","moduleFilter","setAttribute","lastChild","appendToolbar","appendHeader","header","appendBanner","banner","appendTestResults","parentNode","removeChild","insertBefore","storeFixture","appendFilteredTest","appendUserAgent","userAgent","createTextNode","navigator","qunit","appendTestsList","z","moduleObj","appendTest","rerunTrigger","testBlock","assertList","getNameHtml","href","localeCompare","hidepassed","html","scrollTo","nameHtml","testStart","running","stripHtml","log","assertLi","showDiff","testItem","testDone","testTitle","time","good","testCounts","sourceName","firstChild","notPhantom","p","major","phantom","readyState","DiffMatchPatch","DIFF_DELETE","DIFF_INSERT","DIFF_EQUAL","DiffMain","text1","text2","optChecklines","deadline","checklines","commonlength","commonprefix","commonsuffix","diffs","diffCommonPrefix","diffCommonSuffix","diffCompute","unshift","diffCleanupMerge","diffCleanupEfficiency","changes","equalities","equalitiesLength","lastequality","pointer","preIns","preDel","postIns","postDel","diffPrettyHtml","op","data","pointermid","pointermax","pointermin","pointerstart","min","pointerend","longtext","shorttext","hm","text1A","text2A","text1B","text2B","midCommon","diffsA","diffsB","diffHalfMatch","diffLineMode","diffBisect","dmp","hm1","hm2","diffHalfMatchI","bestCommon","prefixLength","suffixLength","bestLongtextA","bestLongtextB","bestShorttextA","bestShorttextB","ceil","linearray","countInsert","countDelete","textInsert","textDelete","diffLinesToChars","chars1","chars2","lineArray","diffCharsToLines","diffCleanupSemantic","text1Length","text2Length","maxD","vOffset","vLength","v1","v2","delta","front","k1start","k1end","k2start","k2end","k2Offset","k1Offset","x1","x2","y1","y2","d","k1","k2","diffBisectSplit","y","text1a","text1b","text2a","text2b","diffsb","lengthInsertions2","lengthDeletions2","lengthInsertions1","lengthDeletions1","deletion","insertion","overlapLength1","overlapLength2","max","diffCommonOverlap","textLength","best","found","lineHash","diffLinesToCharsMunge","text","chars","lineStart","lineEnd","lineArrayLength","diffPointer","position","n","output","PATH_ROOT","POST_ORDER","PRE_ORDER","BFS","clone","JSON","stringify","merge","objA","objB","assign","times","Number","updatePathInTraversalState","traversalState","subTree","subTreeChildren","subTreeChild","traversalStateParent","get","traversalStateChild","currentChildPath","path","isAdded","isVisited","updateVisitInTraversalState","tree","visitTree","traversalSpecs","store","lenses","traverse","emptyOrEmptyConstructor","empty","add","takeAndRemoveOne","isEmpty","getChildren","getLabel","setTree","visit","seedOrSeedConstructor","Map","currentStore","visitAcc","clear","breadthFirstTraverseTree","subTrees","preorderTraverseTree","postOrderTraverseTree","isLeaf","predicate","decoratedLenses","reduceTree","strategy","strategies","forEachInTree","action","treeTraveerse","accumulator","mapOverTree","mapFn","constructTree","getChildrenNumber","pathMap","mappedLabel","mappedChildren","mappedTree","pruneWhen","pruneLenses","prunedTree","exec_test","traces","sep","makeChildCursor","parentCursor","childIndex","makeParentCursor","childCursor","cursor","children","mapOverHashTree"],"mappings":"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AA9B;;AAEA3C,QAAQqD,SAAR,GAAoB,UAAUC,IAAV,EAAgB;AAAE,WAAO,EAAP;AAAW,CAAjD;;AAEAtD,QAAQuD,OAAR,GAAkB,UAAUD,IAAV,EAAgB;AAC9B,UAAM,IAAIhD,KAAJ,CAAU,kCAAV,CAAN;AACH,CAFD;;AAIAN,QAAQwD,GAAR,GAAc,YAAY;AAAE,WAAO,GAAP;AAAY,CAAxC;AACAxD,QAAQyD,KAAR,GAAgB,UAAUC,GAAV,EAAe;AAC3B,UAAM,IAAIpD,KAAJ,CAAU,gCAAV,CAAN;AACH,CAFD;AAGAN,QAAQ2D,KAAR,GAAgB,YAAW;AAAE,WAAO,CAAP;AAAW,CAAxC;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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","file":"_tree.specs.7c66778e.map","sourcesContent":["// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*!\n * QUnit 1.23.1\n * https://qunitjs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2016-04-12T17:29Z\n */\n\n( function( global ) {\n\nvar QUnit = {};\n\nvar Date = global.Date;\nvar now = Date.now || function() {\n\treturn new Date().getTime();\n};\n\nvar setTimeout = global.setTimeout;\nvar clearTimeout = global.clearTimeout;\n\n// Store a local window from the global to allow direct references.\nvar window = global.window;\n\nvar defined = {\n\tdocument: window && window.document !== undefined,\n\tsetTimeout: setTimeout !== undefined,\n\tsessionStorage: ( function() {\n\t\tvar x = \"qunit-test-string\";\n\t\ttry {\n\t\t\tsessionStorage.setItem( x, x );\n\t\t\tsessionStorage.removeItem( x );\n\t\t\treturn true;\n\t\t} catch ( e ) {\n\t\t\treturn false;\n\t\t}\n\t}() )\n};\n\nvar fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\nvar globalStartCalled = false;\nvar runStarted = false;\n\nvar toString = Object.prototype.toString,\n\thasOwn = Object.prototype.hasOwnProperty;\n\n// Returns a new Array with the elements that are in a but not in b\nfunction diff( a, b ) {\n\tvar i, j,\n\t\tresult = a.slice();\n\n\tfor ( i = 0; i < result.length; i++ ) {\n\t\tfor ( j = 0; j < b.length; j++ ) {\n\t\t\tif ( result[ i ] === b[ j ] ) {\n\t\t\t\tresult.splice( i, 1 );\n\t\t\t\ti--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n// From jquery.js\nfunction inArray( elem, array ) {\n\tif ( array.indexOf ) {\n\t\treturn array.indexOf( elem );\n\t}\n\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\n\t\tif ( array[ i ] === elem ) {\n\t\t\treturn i;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\n/**\n * Makes a clone of an object using only Array or Object as base,\n * and copies over the own enumerable properties.\n *\n * @param {Object} obj\n * @return {Object} New object with only the own properties (recursively).\n */\nfunction objectValues ( obj ) {\n\tvar key, val,\n\t\tvals = QUnit.is( \"array\", obj ) ? [] : {};\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tval = obj[ key ];\n\t\t\tvals[ key ] = val === Object( val ) ? objectValues( val ) : val;\n\t\t}\n\t}\n\treturn vals;\n}\n\nfunction extend( a, b, undefOnly ) {\n\tfor ( var prop in b ) {\n\t\tif ( hasOwn.call( b, prop ) ) {\n\n\t\t\t// Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\n\t\t\t// This block runs on every environment, so `global` is being used instead of `window`\n\t\t\t// to avoid errors on node.\n\t\t\tif ( prop !== \"constructor\" || a !== global ) {\n\t\t\t\tif ( b[ prop ] === undefined ) {\n\t\t\t\t\tdelete a[ prop ];\n\t\t\t\t} else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\n\t\t\t\t\ta[ prop ] = b[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a;\n}\n\nfunction objectType( obj ) {\n\tif ( typeof obj === \"undefined\" ) {\n\t\treturn \"undefined\";\n\t}\n\n\t// Consider: typeof null === object\n\tif ( obj === null ) {\n\t\treturn \"null\";\n\t}\n\n\tvar match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\n\t\ttype = match && match[ 1 ];\n\n\tswitch ( type ) {\n\t\tcase \"Number\":\n\t\t\tif ( isNaN( obj ) ) {\n\t\t\t\treturn \"nan\";\n\t\t\t}\n\t\t\treturn \"number\";\n\t\tcase \"String\":\n\t\tcase \"Boolean\":\n\t\tcase \"Array\":\n\t\tcase \"Set\":\n\t\tcase \"Map\":\n\t\tcase \"Date\":\n\t\tcase \"RegExp\":\n\t\tcase \"Function\":\n\t\tcase \"Symbol\":\n\t\t\treturn type.toLowerCase();\n\t}\n\tif ( typeof obj === \"object\" ) {\n\t\treturn \"object\";\n\t}\n}\n\n// Safe object type checking\nfunction is( type, obj ) {\n\treturn QUnit.objectType( obj ) === type;\n}\n\n// Doesn't support IE6 to IE9, it will return undefined on these browsers\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\nfunction extractStacktrace( e, offset ) {\n\toffset = offset === undefined ? 4 : offset;\n\n\tvar stack, include, i;\n\n\tif ( e.stack ) {\n\t\tstack = e.stack.split( \"\\n\" );\n\t\tif ( /^error$/i.test( stack[ 0 ] ) ) {\n\t\t\tstack.shift();\n\t\t}\n\t\tif ( fileName ) {\n\t\t\tinclude = [];\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) !== -1 ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tinclude.push( stack[ i ] );\n\t\t\t}\n\t\t\tif ( include.length ) {\n\t\t\t\treturn include.join( \"\\n\" );\n\t\t\t}\n\t\t}\n\t\treturn stack[ offset ];\n\n\t// Support: Safari <=6 only\n\t} else if ( e.sourceURL ) {\n\n\t\t// Exclude useless self-reference for generated Error objects\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// For actual exceptions, this is useful\n\t\treturn e.sourceURL + \":\" + e.line;\n\t}\n}\n\nfunction sourceFromStacktrace( offset ) {\n\tvar error = new Error();\n\n\t// Support: Safari <=7 only, IE <=10 - 11 only\n\t// Not all browsers generate the `stack` property for `new Error()`, see also #636\n\tif ( !error.stack ) {\n\t\ttry {\n\t\t\tthrow error;\n\t\t} catch ( err ) {\n\t\t\terror = err;\n\t\t}\n\t}\n\n\treturn extractStacktrace( error, offset );\n}\n\n/**\n * Config object: Maintain internal state\n * Later exposed as QUnit.config\n * `config` initialized at top of scope\n */\nvar config = {\n\n\t// The queue of tests to run\n\tqueue: [],\n\n\t// Block until document ready\n\tblocking: true,\n\n\t// By default, run previously failed tests first\n\t// very useful in combination with \"Hide passed tests\" checked\n\treorder: true,\n\n\t// By default, modify document.title when suite is done\n\taltertitle: true,\n\n\t// HTML Reporter: collapse every test except the first failing test\n\t// If false, all failing tests will be expanded\n\tcollapse: true,\n\n\t// By default, scroll to top of the page when suite is done\n\tscrolltop: true,\n\n\t// Depth up-to which object will be dumped\n\tmaxDepth: 5,\n\n\t// When enabled, all tests must call expect()\n\trequireExpects: false,\n\n\t// Placeholder for user-configurable form-exposed URL parameters\n\turlConfig: [],\n\n\t// Set of all modules.\n\tmodules: [],\n\n\t// Stack of nested modules\n\tmoduleStack: [],\n\n\t// The first unnamed module\n\tcurrentModule: {\n\t\tname: \"\",\n\t\ttests: []\n\t},\n\n\tcallbacks: {}\n};\n\n// Push a loose unnamed module to the modules collection\nconfig.modules.push( config.currentModule );\n\nvar loggingCallbacks = {};\n\n// Register logging callbacks\nfunction registerLoggingCallbacks( obj ) {\n\tvar i, l, key,\n\t\tcallbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\n\t\t\t\"moduleStart\", \"moduleDone\" ];\n\n\tfunction registerLoggingCallback( key ) {\n\t\tvar loggingCallback = function( callback ) {\n\t\t\tif ( objectType( callback ) !== \"function\" ) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"QUnit logging methods require a callback function as their first parameters.\"\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tconfig.callbacks[ key ].push( callback );\n\t\t};\n\n\t\t// DEPRECATED: This will be removed on QUnit 2.0.0+\n\t\t// Stores the registered functions allowing restoring\n\t\t// at verifyLoggingCallbacks() if modified\n\t\tloggingCallbacks[ key ] = loggingCallback;\n\n\t\treturn loggingCallback;\n\t}\n\n\tfor ( i = 0, l = callbackNames.length; i < l; i++ ) {\n\t\tkey = callbackNames[ i ];\n\n\t\t// Initialize key collection of logging callback\n\t\tif ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\n\t\t\tconfig.callbacks[ key ] = [];\n\t\t}\n\n\t\tobj[ key ] = registerLoggingCallback( key );\n\t}\n}\n\nfunction runLoggingCallbacks( key, args ) {\n\tvar i, l, callbacks;\n\n\tcallbacks = config.callbacks[ key ];\n\tfor ( i = 0, l = callbacks.length; i < l; i++ ) {\n\t\tcallbacks[ i ]( args );\n\t}\n}\n\n// DEPRECATED: This will be removed on 2.0.0+\n// This function verifies if the loggingCallbacks were modified by the user\n// If so, it will restore it, assign the given callback and print a console warning\nfunction verifyLoggingCallbacks() {\n\tvar loggingCallback, userCallback;\n\n\tfor ( loggingCallback in loggingCallbacks ) {\n\t\tif ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\n\n\t\t\tuserCallback = QUnit[ loggingCallback ];\n\n\t\t\t// Restore the callback function\n\t\t\tQUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\n\n\t\t\t// Assign the deprecated given callback\n\t\t\tQUnit[ loggingCallback ]( userCallback );\n\n\t\t\tif ( global.console && global.console.warn ) {\n\t\t\t\tglobal.console.warn(\n\t\t\t\t\t\"QUnit.\" + loggingCallback + \" was replaced with a new value.\\n\" +\n\t\t\t\t\t\"Please, check out the documentation on how to apply logging callbacks.\\n\" +\n\t\t\t\t\t\"Reference: https://api.qunitjs.com/category/callbacks/\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n}\n\n( function() {\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\t// `onErrorFnPrev` initialized at top of scope\n\t// Preserve other handlers\n\tvar onErrorFnPrev = window.onerror;\n\n\t// Cover uncaught exceptions\n\t// Returning true will suppress the default browser handler,\n\t// returning false will let it run.\n\twindow.onerror = function( error, filePath, linerNr ) {\n\t\tvar ret = false;\n\t\tif ( onErrorFnPrev ) {\n\t\t\tret = onErrorFnPrev( error, filePath, linerNr );\n\t\t}\n\n\t\t// Treat return value as window.onerror itself does,\n\t\t// Only do our handling if not suppressed.\n\t\tif ( ret !== true ) {\n\t\t\tif ( QUnit.config.current ) {\n\t\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t} else {\n\t\t\t\tQUnit.test( \"global failure\", extend( function() {\n\t\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\n\t\t\t\t}, { validTest: true } ) );\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ret;\n\t};\n}() );\n\n// Figure out if we're running the tests from a server or not\nQUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\n\n// Expose the current QUnit version\nQUnit.version = \"1.23.1\";\n\nextend( QUnit, {\n\n\t// Call on start of module test to prepend name to all tests\n\tmodule: function( name, testEnvironment, executeNow ) {\n\t\tvar module, moduleFns;\n\t\tvar currentModule = config.currentModule;\n\n\t\tif ( arguments.length === 2 ) {\n\t\t\tif ( objectType( testEnvironment ) === \"function\" ) {\n\t\t\t\texecuteNow = testEnvironment;\n\t\t\t\ttestEnvironment = undefined;\n\t\t\t}\n\t\t}\n\n\t\t// DEPRECATED: handles setup/teardown functions,\n\t\t// beforeEach and afterEach should be used instead\n\t\tif ( testEnvironment && testEnvironment.setup ) {\n\t\t\ttestEnvironment.beforeEach = testEnvironment.setup;\n\t\t\tdelete testEnvironment.setup;\n\t\t}\n\t\tif ( testEnvironment && testEnvironment.teardown ) {\n\t\t\ttestEnvironment.afterEach = testEnvironment.teardown;\n\t\t\tdelete testEnvironment.teardown;\n\t\t}\n\n\t\tmodule = createModule();\n\n\t\tmoduleFns = {\n\t\t\tbeforeEach: setHook( module, \"beforeEach\" ),\n\t\t\tafterEach: setHook( module, \"afterEach\" )\n\t\t};\n\n\t\tif ( objectType( executeNow ) === \"function\" ) {\n\t\t\tconfig.moduleStack.push( module );\n\t\t\tsetCurrentModule( module );\n\t\t\texecuteNow.call( module.testEnvironment, moduleFns );\n\t\t\tconfig.moduleStack.pop();\n\t\t\tmodule = module.parentModule || currentModule;\n\t\t}\n\n\t\tsetCurrentModule( module );\n\n\t\tfunction createModule() {\n\t\t\tvar parentModule = config.moduleStack.length ?\n\t\t\t\tconfig.moduleStack.slice( -1 )[ 0 ] : null;\n\t\t\tvar moduleName = parentModule !== null ?\n\t\t\t\t[ parentModule.name, name ].join( \" > \" ) : name;\n\t\t\tvar module = {\n\t\t\t\tname: moduleName,\n\t\t\t\tparentModule: parentModule,\n\t\t\t\ttests: [],\n\t\t\t\tmoduleId: generateHash( moduleName )\n\t\t\t};\n\n\t\t\tvar env = {};\n\t\t\tif ( parentModule ) {\n\t\t\t\textend( env, parentModule.testEnvironment );\n\t\t\t\tdelete env.beforeEach;\n\t\t\t\tdelete env.afterEach;\n\t\t\t}\n\t\t\textend( env, testEnvironment );\n\t\t\tmodule.testEnvironment = env;\n\n\t\t\tconfig.modules.push( module );\n\t\t\treturn module;\n\t\t}\n\n\t\tfunction setCurrentModule( module ) {\n\t\t\tconfig.currentModule = module;\n\t\t}\n\n\t},\n\n\t// DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\n\tasyncTest: asyncTest,\n\n\ttest: test,\n\n\tskip: skip,\n\n\tonly: only,\n\n\t// DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\n\t// In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\n\tstart: function( count ) {\n\t\tvar globalStartAlreadyCalled = globalStartCalled;\n\n\t\tif ( !config.current ) {\n\t\t\tglobalStartCalled = true;\n\n\t\t\tif ( runStarted ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context while already started\" );\n\t\t\t} else if ( globalStartAlreadyCalled || count > 1 ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context too many times\" );\n\t\t\t} else if ( config.autostart ) {\n\t\t\t\tthrow new Error( \"Called start() outside of a test context when \" +\n\t\t\t\t\t\"QUnit.config.autostart was true\" );\n\t\t\t} else if ( !config.pageLoaded ) {\n\n\t\t\t\t// The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\n\t\t\t\tconfig.autostart = true;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// If a test is running, adjust its semaphore\n\t\t\tconfig.current.semaphore -= count || 1;\n\n\t\t\t// If semaphore is non-numeric, throw error\n\t\t\tif ( isNaN( config.current.semaphore ) ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t\"Called start() with a non-numeric decrement.\",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Don't start until equal number of stop-calls\n\t\t\tif ( config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Throw an Error if start is called more often than stop\n\t\t\tif ( config.current.semaphore < 0 ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\n\t\t\t\tQUnit.pushFailure(\n\t\t\t\t\t\"Called start() while already started (test's semaphore was 0 already)\",\n\t\t\t\t\tsourceFromStacktrace( 2 )\n\t\t\t\t);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tresumeProcessing();\n\t},\n\n\t// DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\n\tstop: function( count ) {\n\n\t\t// If there isn't a test running, don't allow QUnit.stop() to be called\n\t\tif ( !config.current ) {\n\t\t\tthrow new Error( \"Called stop() outside of a test context\" );\n\t\t}\n\n\t\t// If a test is running, adjust its semaphore\n\t\tconfig.current.semaphore += count || 1;\n\n\t\tpauseProcessing();\n\t},\n\n\tconfig: config,\n\n\tis: is,\n\n\tobjectType: objectType,\n\n\textend: extend,\n\n\tload: function() {\n\t\tconfig.pageLoaded = true;\n\n\t\t// Initialize the configuration options\n\t\textend( config, {\n\t\t\tstats: { all: 0, bad: 0 },\n\t\t\tmoduleStats: { all: 0, bad: 0 },\n\t\t\tstarted: 0,\n\t\t\tupdateRate: 1000,\n\t\t\tautostart: true,\n\t\t\tfilter: \"\"\n\t\t}, true );\n\n\t\tconfig.blocking = false;\n\n\t\tif ( config.autostart ) {\n\t\t\tresumeProcessing();\n\t\t}\n\t},\n\n\tstack: function( offset ) {\n\t\toffset = ( offset || 0 ) + 2;\n\t\treturn sourceFromStacktrace( offset );\n\t}\n} );\n\nregisterLoggingCallbacks( QUnit );\n\nfunction begin() {\n\tvar i, l,\n\t\tmodulesLog = [];\n\n\t// If the test run hasn't officially begun yet\n\tif ( !config.started ) {\n\n\t\t// Record the time of the test run's beginning\n\t\tconfig.started = now();\n\n\t\tverifyLoggingCallbacks();\n\n\t\t// Delete the loose unnamed module if unused.\n\t\tif ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\n\t\t\tconfig.modules.shift();\n\t\t}\n\n\t\t// Avoid unnecessary information by not logging modules' test environments\n\t\tfor ( i = 0, l = config.modules.length; i < l; i++ ) {\n\t\t\tmodulesLog.push( {\n\t\t\t\tname: config.modules[ i ].name,\n\t\t\t\ttests: config.modules[ i ].tests\n\t\t\t} );\n\t\t}\n\n\t\t// The test run is officially beginning now\n\t\trunLoggingCallbacks( \"begin\", {\n\t\t\ttotalTests: Test.count,\n\t\t\tmodules: modulesLog\n\t\t} );\n\t}\n\n\tconfig.blocking = false;\n\tprocess( true );\n}\n\nfunction process( last ) {\n\tfunction next() {\n\t\tprocess( last );\n\t}\n\tvar start = now();\n\tconfig.depth = ( config.depth || 0 ) + 1;\n\n\twhile ( config.queue.length && !config.blocking ) {\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 ||\n\t\t\t\t( ( now() - start ) < config.updateRate ) ) {\n\t\t\tif ( config.current ) {\n\n\t\t\t\t// Reset async tracking for each phase of the Test lifecycle\n\t\t\t\tconfig.current.usedAsync = false;\n\t\t\t}\n\t\t\tconfig.queue.shift()();\n\t\t} else {\n\t\t\tsetTimeout( next, 13 );\n\t\t\tbreak;\n\t\t}\n\t}\n\tconfig.depth--;\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\n\t\tdone();\n\t}\n}\n\nfunction pauseProcessing() {\n\tconfig.blocking = true;\n\n\tif ( config.testTimeout && defined.setTimeout ) {\n\t\tclearTimeout( config.timeout );\n\t\tconfig.timeout = setTimeout( function() {\n\t\t\tif ( config.current ) {\n\t\t\t\tconfig.current.semaphore = 0;\n\t\t\t\tQUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\n\t\t\t} else {\n\t\t\t\tthrow new Error( \"Test timed out\" );\n\t\t\t}\n\t\t\tresumeProcessing();\n\t\t}, config.testTimeout );\n\t}\n}\n\nfunction resumeProcessing() {\n\trunStarted = true;\n\n\t// A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\n\tif ( defined.setTimeout ) {\n\t\tsetTimeout( function() {\n\t\t\tif ( config.current && config.current.semaphore > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( config.timeout ) {\n\t\t\t\tclearTimeout( config.timeout );\n\t\t\t}\n\n\t\t\tbegin();\n\t\t}, 13 );\n\t} else {\n\t\tbegin();\n\t}\n}\n\nfunction done() {\n\tvar runtime, passed;\n\n\tconfig.autorun = true;\n\n\t// Log the last module results\n\tif ( config.previousModule ) {\n\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\tname: config.previousModule.name,\n\t\t\ttests: config.previousModule.tests,\n\t\t\tfailed: config.moduleStats.bad,\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\ttotal: config.moduleStats.all,\n\t\t\truntime: now() - config.moduleStats.started\n\t\t} );\n\t}\n\tdelete config.previousModule;\n\n\truntime = now() - config.started;\n\tpassed = config.stats.all - config.stats.bad;\n\n\trunLoggingCallbacks( \"done\", {\n\t\tfailed: config.stats.bad,\n\t\tpassed: passed,\n\t\ttotal: config.stats.all,\n\t\truntime: runtime\n\t} );\n}\n\nfunction setHook( module, hookName ) {\n\tif ( module.testEnvironment === undefined ) {\n\t\tmodule.testEnvironment = {};\n\t}\n\n\treturn function( callback ) {\n\t\tmodule.testEnvironment[ hookName ] = callback;\n\t};\n}\n\nvar focused = false;\nvar priorityCount = 0;\nvar unitSampler;\n\nfunction Test( settings ) {\n\tvar i, l;\n\n\t++Test.count;\n\n\textend( this, settings );\n\tthis.assertions = [];\n\tthis.semaphore = 0;\n\tthis.usedAsync = false;\n\tthis.module = config.currentModule;\n\tthis.stack = sourceFromStacktrace( 3 );\n\n\t// Register unique strings\n\tfor ( i = 0, l = this.module.tests; i < l.length; i++ ) {\n\t\tif ( this.module.tests[ i ].name === this.testName ) {\n\t\t\tthis.testName += \" \";\n\t\t}\n\t}\n\n\tthis.testId = generateHash( this.module.name, this.testName );\n\n\tthis.module.tests.push( {\n\t\tname: this.testName,\n\t\ttestId: this.testId\n\t} );\n\n\tif ( settings.skip ) {\n\n\t\t// Skipped tests will fully ignore any sent callback\n\t\tthis.callback = function() {};\n\t\tthis.async = false;\n\t\tthis.expected = 0;\n\t} else {\n\t\tthis.assert = new Assert( this );\n\t}\n}\n\nTest.count = 0;\n\nTest.prototype = {\n\tbefore: function() {\n\t\tif (\n\n\t\t\t// Emit moduleStart when we're switching from one module to another\n\t\t\tthis.module !== config.previousModule ||\n\n\t\t\t\t// They could be equal (both undefined) but if the previousModule property doesn't\n\t\t\t\t// yet exist it means this is the first test in a suite that isn't wrapped in a\n\t\t\t\t// module, in which case we'll just emit a moduleStart event for 'undefined'.\n\t\t\t\t// Without this, reporters can get testStart before moduleStart  which is a problem.\n\t\t\t\t!hasOwn.call( config, \"previousModule\" )\n\t\t) {\n\t\t\tif ( hasOwn.call( config, \"previousModule\" ) ) {\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", {\n\t\t\t\t\tname: config.previousModule.name,\n\t\t\t\t\ttests: config.previousModule.tests,\n\t\t\t\t\tfailed: config.moduleStats.bad,\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\n\t\t\t\t\ttotal: config.moduleStats.all,\n\t\t\t\t\truntime: now() - config.moduleStats.started\n\t\t\t\t} );\n\t\t\t}\n\t\t\tconfig.previousModule = this.module;\n\t\t\tconfig.moduleStats = { all: 0, bad: 0, started: now() };\n\t\t\trunLoggingCallbacks( \"moduleStart\", {\n\t\t\t\tname: this.module.name,\n\t\t\t\ttests: this.module.tests\n\t\t\t} );\n\t\t}\n\n\t\tconfig.current = this;\n\n\t\tif ( this.module.testEnvironment ) {\n\t\t\tdelete this.module.testEnvironment.beforeEach;\n\t\t\tdelete this.module.testEnvironment.afterEach;\n\t\t}\n\t\tthis.testEnvironment = extend( {}, this.module.testEnvironment );\n\n\t\tthis.started = now();\n\t\trunLoggingCallbacks( \"testStart\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\ttestId: this.testId\n\t\t} );\n\n\t\tif ( !config.pollution ) {\n\t\t\tsaveGlobal();\n\t\t}\n\t},\n\n\trun: function() {\n\t\tvar promise;\n\n\t\tconfig.current = this;\n\n\t\tif ( this.async ) {\n\t\t\tQUnit.stop();\n\t\t}\n\n\t\tthis.callbackStarted = now();\n\n\t\tif ( config.notrycatch ) {\n\t\t\trunTest( this );\n\t\t\treturn;\n\t\t}\n\n\t\ttry {\n\t\t\trunTest( this );\n\t\t} catch ( e ) {\n\t\t\tthis.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\n\t\t\t\tthis.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\n\n\t\t\t// Else next test will carry the responsibility\n\t\t\tsaveGlobal();\n\n\t\t\t// Restart the tests if they're blocking\n\t\t\tif ( config.blocking ) {\n\t\t\t\tQUnit.start();\n\t\t\t}\n\t\t}\n\n\t\tfunction runTest( test ) {\n\t\t\tpromise = test.callback.call( test.testEnvironment, test.assert );\n\t\t\ttest.resolvePromise( promise );\n\t\t}\n\t},\n\n\tafter: function() {\n\t\tcheckPollution();\n\t},\n\n\tqueueHook: function( hook, hookName ) {\n\t\tvar promise,\n\t\t\ttest = this;\n\t\treturn function runHook() {\n\t\t\tconfig.current = test;\n\t\t\tif ( config.notrycatch ) {\n\t\t\t\tcallHook();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tcallHook();\n\t\t\t} catch ( error ) {\n\t\t\t\ttest.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\n\t\t\t\t( error.message || error ), extractStacktrace( error, 0 ) );\n\t\t\t}\n\n\t\t\tfunction callHook() {\n\t\t\t\tpromise = hook.call( test.testEnvironment, test.assert );\n\t\t\t\ttest.resolvePromise( promise, hookName );\n\t\t\t}\n\t\t};\n\t},\n\n\t// Currently only used for module level hooks, can be used to add global level ones\n\thooks: function( handler ) {\n\t\tvar hooks = [];\n\n\t\tfunction processHooks( test, module ) {\n\t\t\tif ( module.parentModule ) {\n\t\t\t\tprocessHooks( test, module.parentModule );\n\t\t\t}\n\t\t\tif ( module.testEnvironment &&\n\t\t\t\tQUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\n\t\t\t\thooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\n\t\t\t}\n\t\t}\n\n\t\t// Hooks are ignored on skipped tests\n\t\tif ( !this.skip ) {\n\t\t\tprocessHooks( this, this.module );\n\t\t}\n\t\treturn hooks;\n\t},\n\n\tfinish: function() {\n\t\tconfig.current = this;\n\t\tif ( config.requireExpects && this.expected === null ) {\n\t\t\tthis.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\n\t\t\t\t\"not called.\", this.stack );\n\t\t} else if ( this.expected !== null && this.expected !== this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\n\t\t\t\tthis.assertions.length + \" were run\", this.stack );\n\t\t} else if ( this.expected === null && !this.assertions.length ) {\n\t\t\tthis.pushFailure( \"Expected at least one assertion, but none were run - call \" +\n\t\t\t\t\"expect(0) to accept zero assertions.\", this.stack );\n\t\t}\n\n\t\tvar i,\n\t\t\tbad = 0;\n\n\t\tthis.runtime = now() - this.started;\n\t\tconfig.stats.all += this.assertions.length;\n\t\tconfig.moduleStats.all += this.assertions.length;\n\n\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\n\t\t\tif ( !this.assertions[ i ].result ) {\n\t\t\t\tbad++;\n\t\t\t\tconfig.stats.bad++;\n\t\t\t\tconfig.moduleStats.bad++;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"testDone\", {\n\t\t\tname: this.testName,\n\t\t\tmodule: this.module.name,\n\t\t\tskipped: !!this.skip,\n\t\t\tfailed: bad,\n\t\t\tpassed: this.assertions.length - bad,\n\t\t\ttotal: this.assertions.length,\n\t\t\truntime: this.runtime,\n\n\t\t\t// HTML Reporter use\n\t\t\tassertions: this.assertions,\n\t\t\ttestId: this.testId,\n\n\t\t\t// Source of Test\n\t\t\tsource: this.stack,\n\n\t\t\t// DEPRECATED: this property will be removed in 2.0.0, use runtime instead\n\t\t\tduration: this.runtime\n\t\t} );\n\n\t\t// QUnit.reset() is deprecated and will be replaced for a new\n\t\t// fixture reset function on QUnit 2.0/2.1.\n\t\t// It's still called here for backwards compatibility handling\n\t\tQUnit.reset();\n\n\t\tconfig.current = undefined;\n\t},\n\n\tqueue: function() {\n\t\tvar priority,\n\t\t\ttest = this;\n\n\t\tif ( !this.valid() ) {\n\t\t\treturn;\n\t\t}\n\n\t\tfunction run() {\n\n\t\t\t// Each of these can by async\n\t\t\tsynchronize( [\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.before();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"beforeEach\" ),\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.run();\n\t\t\t\t},\n\n\t\t\t\ttest.hooks( \"afterEach\" ).reverse(),\n\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.after();\n\t\t\t\t},\n\t\t\t\tfunction() {\n\t\t\t\t\ttest.finish();\n\t\t\t\t}\n\t\t\t] );\n\t\t}\n\n\t\t// Prioritize previously failed tests, detected from sessionStorage\n\t\tpriority = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\n\n\t\treturn synchronize( run, priority, config.seed );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar source,\n\t\t\tdetails = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: resultInfo.result,\n\t\t\t\tmessage: resultInfo.message,\n\t\t\t\tactual: resultInfo.actual,\n\t\t\t\texpected: resultInfo.expected,\n\t\t\t\ttestId: this.testId,\n\t\t\t\tnegative: resultInfo.negative || false,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( !resultInfo.result ) {\n\t\t\tsource = sourceFromStacktrace();\n\n\t\t\tif ( source ) {\n\t\t\t\tdetails.source = source;\n\t\t\t}\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: !!resultInfo.result,\n\t\t\tmessage: resultInfo.message\n\t\t} );\n\t},\n\n\tpushFailure: function( message, source, actual ) {\n\t\tif ( !( this instanceof Test ) ) {\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" +\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tvar details = {\n\t\t\t\tmodule: this.module.name,\n\t\t\t\tname: this.testName,\n\t\t\t\tresult: false,\n\t\t\t\tmessage: message || \"error\",\n\t\t\t\tactual: actual || null,\n\t\t\t\ttestId: this.testId,\n\t\t\t\truntime: now() - this.started\n\t\t\t};\n\n\t\tif ( source ) {\n\t\t\tdetails.source = source;\n\t\t}\n\n\t\trunLoggingCallbacks( \"log\", details );\n\n\t\tthis.assertions.push( {\n\t\t\tresult: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tresolvePromise: function( promise, phase ) {\n\t\tvar then, message,\n\t\t\ttest = this;\n\t\tif ( promise != null ) {\n\t\t\tthen = promise.then;\n\t\t\tif ( QUnit.objectType( then ) === \"function\" ) {\n\t\t\t\tQUnit.stop();\n\t\t\t\tthen.call(\n\t\t\t\t\tpromise,\n\t\t\t\t\tfunction() { QUnit.start(); },\n\t\t\t\t\tfunction( error ) {\n\t\t\t\t\t\tmessage = \"Promise rejected \" +\n\t\t\t\t\t\t\t( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\n\t\t\t\t\t\t\t\" \" + test.testName + \": \" + ( error.message || error );\n\t\t\t\t\t\ttest.pushFailure( message, extractStacktrace( error, 0 ) );\n\n\t\t\t\t\t\t// Else next test will carry the responsibility\n\t\t\t\t\t\tsaveGlobal();\n\n\t\t\t\t\t\t// Unblock\n\t\t\t\t\t\tQUnit.start();\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t},\n\n\tvalid: function() {\n\t\tvar filter = config.filter,\n\t\t\tregexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\n\t\t\tmodule = config.module && config.module.toLowerCase(),\n\t\t\tfullName = ( this.module.name + \": \" + this.testName );\n\n\t\tfunction moduleChainNameMatch( testModule ) {\n\t\t\tvar testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\n\t\t\tif ( testModuleName === module ) {\n\t\t\t\treturn true;\n\t\t\t} else if ( testModule.parentModule ) {\n\t\t\t\treturn moduleChainNameMatch( testModule.parentModule );\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfunction moduleChainIdMatch( testModule ) {\n\t\t\treturn inArray( testModule.moduleId, config.moduleId ) > -1 ||\n\t\t\t\ttestModule.parentModule && moduleChainIdMatch( testModule.parentModule );\n\t\t}\n\n\t\t// Internally-generated tests are always valid\n\t\tif ( this.callback && this.callback.validTest ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( config.moduleId && config.moduleId.length > 0 &&\n\t\t\t!moduleChainIdMatch( this.module ) ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( config.testId && config.testId.length > 0 &&\n\t\t\tinArray( this.testId, config.testId ) < 0 ) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( module && !moduleChainNameMatch( this.module ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( !filter ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn regexFilter ?\n\t\t\tthis.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\n\t\t\tthis.stringFilter( filter, fullName );\n\t},\n\n\tregexFilter: function( exclude, pattern, flags, fullName ) {\n\t\tvar regex = new RegExp( pattern, flags );\n\t\tvar match = regex.test( fullName );\n\n\t\treturn match !== exclude;\n\t},\n\n\tstringFilter: function( filter, fullName ) {\n\t\tfilter = filter.toLowerCase();\n\t\tfullName = fullName.toLowerCase();\n\n\t\tvar include = filter.charAt( 0 ) !== \"!\";\n\t\tif ( !include ) {\n\t\t\tfilter = filter.slice( 1 );\n\t\t}\n\n\t\t// If the filter matches, we need to honour include\n\t\tif ( fullName.indexOf( filter ) !== -1 ) {\n\t\t\treturn include;\n\t\t}\n\n\t\t// Otherwise, do the opposite\n\t\treturn !include;\n\t}\n};\n\n// Resets the test setup. Useful for tests that modify the DOM.\n/*\nDEPRECATED: Use multiple tests instead of resetting inside a test.\nUse testStart or testDone for custom cleanup.\nThis method will throw an error in 2.0, and will be removed in 2.1\n*/\nQUnit.reset = function() {\n\n\t// Return on non-browser environments\n\t// This is necessary to not break on node tests\n\tif ( !defined.document ) {\n\t\treturn;\n\t}\n\n\tvar fixture = defined.document && document.getElementById &&\n\t\t\tdocument.getElementById( \"qunit-fixture\" );\n\n\tif ( fixture ) {\n\t\tfixture.innerHTML = config.fixture;\n\t}\n};\n\nQUnit.pushFailure = function() {\n\tif ( !QUnit.config.current ) {\n\t\tthrow new Error( \"pushFailure() assertion outside test context, in \" +\n\t\t\tsourceFromStacktrace( 2 ) );\n\t}\n\n\t// Gets current test obj\n\tvar currentTest = QUnit.config.current;\n\n\treturn currentTest.pushFailure.apply( currentTest, arguments );\n};\n\n// Based on Java's String.hashCode, a simple but not\n// rigorously collision resistant hashing function\nfunction generateHash( module, testName ) {\n\tvar hex,\n\t\ti = 0,\n\t\thash = 0,\n\t\tstr = module + \"\\x1C\" + testName,\n\t\tlen = str.length;\n\n\tfor ( ; i < len; i++ ) {\n\t\thash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\n\t\thash |= 0;\n\t}\n\n\t// Convert the possibly negative integer hash code into an 8 character hex string, which isn't\n\t// strictly necessary but increases user understanding that the id is a SHA-like hash\n\thex = ( 0x100000000 + hash ).toString( 16 );\n\tif ( hex.length < 8 ) {\n\t\thex = \"0000000\" + hex;\n\t}\n\n\treturn hex.slice( -8 );\n}\n\nfunction synchronize( callback, priority, seed ) {\n\tvar last = !priority,\n\t\tindex;\n\n\tif ( QUnit.objectType( callback ) === \"array\" ) {\n\t\twhile ( callback.length ) {\n\t\t\tsynchronize( callback.shift() );\n\t\t}\n\t\treturn;\n\t}\n\n\tif ( priority ) {\n\t\tconfig.queue.splice( priorityCount++, 0, callback );\n\t} else if ( seed ) {\n\t\tif ( !unitSampler ) {\n\t\t\tunitSampler = unitSamplerGenerator( seed );\n\t\t}\n\n\t\t// Insert into a random position after all priority items\n\t\tindex = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\n\t\tconfig.queue.splice( priorityCount + index, 0, callback );\n\t} else {\n\t\tconfig.queue.push( callback );\n\t}\n\n\tif ( config.autorun && !config.blocking ) {\n\t\tprocess( last );\n\t}\n}\n\nfunction unitSamplerGenerator( seed ) {\n\n\t// 32-bit xorshift, requires only a nonzero seed\n\t// http://excamera.com/sphinx/article-xorshift.html\n\tvar sample = parseInt( generateHash( seed ), 16 ) || -1;\n\treturn function() {\n\t\tsample ^= sample << 13;\n\t\tsample ^= sample >>> 17;\n\t\tsample ^= sample << 5;\n\n\t\t// ECMAScript has no unsigned number type\n\t\tif ( sample < 0 ) {\n\t\t\tsample += 0x100000000;\n\t\t}\n\n\t\treturn sample / 0x100000000;\n\t};\n}\n\nfunction saveGlobal() {\n\tconfig.pollution = [];\n\n\tif ( config.noglobals ) {\n\t\tfor ( var key in global ) {\n\t\t\tif ( hasOwn.call( global, key ) ) {\n\n\t\t\t\t// In Opera sometimes DOM element ids show up here, ignore them\n\t\t\t\tif ( /^qunit-test-output/.test( key ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconfig.pollution.push( key );\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction checkPollution() {\n\tvar newGlobals,\n\t\tdeletedGlobals,\n\t\told = config.pollution;\n\n\tsaveGlobal();\n\n\tnewGlobals = diff( config.pollution, old );\n\tif ( newGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\n\t}\n\n\tdeletedGlobals = diff( old, config.pollution );\n\tif ( deletedGlobals.length > 0 ) {\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\n\t}\n}\n\n// Will be exposed as QUnit.asyncTest\nfunction asyncTest( testName, expected, callback ) {\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tQUnit.test( testName, expected, callback, true );\n}\n\n// Will be exposed as QUnit.test\nfunction test( testName, expected, callback, async ) {\n\tif ( focused )  { return; }\n\n\tvar newTest;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\n// Will be exposed as QUnit.skip\nfunction skip( testName ) {\n\tif ( focused )  { return; }\n\n\tvar test = new Test( {\n\t\ttestName: testName,\n\t\tskip: true\n\t} );\n\n\ttest.queue();\n}\n\n// Will be exposed as QUnit.only\nfunction only( testName, expected, callback, async ) {\n\tvar newTest;\n\n\tif ( focused )  { return; }\n\n\tQUnit.config.queue.length = 0;\n\tfocused = true;\n\n\tif ( arguments.length === 2 ) {\n\t\tcallback = expected;\n\t\texpected = null;\n\t}\n\n\tnewTest = new Test( {\n\t\ttestName: testName,\n\t\texpected: expected,\n\t\tasync: async,\n\t\tcallback: callback\n\t} );\n\n\tnewTest.queue();\n}\n\nfunction Assert( testContext ) {\n\tthis.test = testContext;\n}\n\n// Assert helpers\nQUnit.assert = Assert.prototype = {\n\n\t// Specify the number of expected assertions to guarantee that failed test\n\t// (no assertions are run at all) don't slip through.\n\texpect: function( asserts ) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\tthis.test.expected = asserts;\n\t\t} else {\n\t\t\treturn this.test.expected;\n\t\t}\n\t},\n\n\t// Increment this Test's semaphore counter, then return a function that\n\t// decrements that counter a maximum of once.\n\tasync: function( count ) {\n\t\tvar test = this.test,\n\t\t\tpopped = false,\n\t\t\tacceptCallCount = count;\n\n\t\tif ( typeof acceptCallCount === \"undefined\" ) {\n\t\t\tacceptCallCount = 1;\n\t\t}\n\n\t\ttest.semaphore += 1;\n\t\ttest.usedAsync = true;\n\t\tpauseProcessing();\n\n\t\treturn function done() {\n\n\t\t\tif ( popped ) {\n\t\t\t\ttest.pushFailure( \"Too many calls to the `assert.async` callback\",\n\t\t\t\t\tsourceFromStacktrace( 2 ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tacceptCallCount -= 1;\n\t\t\tif ( acceptCallCount > 0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\ttest.semaphore -= 1;\n\t\t\tpopped = true;\n\t\t\tresumeProcessing();\n\t\t};\n\t},\n\n\t// Exports test.push() to the user API\n\t// Alias of pushResult.\n\tpush: function( result, actual, expected, message, negative ) {\n\t\tvar currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\n\t\treturn currentAssert.pushResult( {\n\t\t\tresult: result,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: negative\n\t\t} );\n\t},\n\n\tpushResult: function( resultInfo ) {\n\n\t\t// Destructure of resultInfo = { result, actual, expected, message, negative }\n\t\tvar assert = this,\n\t\t\tcurrentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\n\n\t\t// Backwards compatibility fix.\n\t\t// Allows the direct use of global exported assertions and QUnit.assert.*\n\t\t// Although, it's use is not recommended as it can leak assertions\n\t\t// to other tests from async tests, because we only get a reference to the current test,\n\t\t// not exactly the test where assertion were intended to be called.\n\t\tif ( !currentTest ) {\n\t\t\tthrow new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\n\t\t}\n\n\t\tif ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\n\t\t\tcurrentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\n\t\t\t\tsourceFromStacktrace( 2 ) );\n\n\t\t\t// Allow this assertion to continue running anyway...\n\t\t}\n\n\t\tif ( !( assert instanceof Assert ) ) {\n\t\t\tassert = currentTest.assert;\n\t\t}\n\n\t\treturn assert.test.pushResult( resultInfo );\n\t},\n\n\tok: function( result, message ) {\n\t\tmessage = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !!result,\n\t\t\tactual: result,\n\t\t\texpected: true,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotOk: function( result, message ) {\n\t\tmessage = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\n\t\t\tQUnit.dump.parse( result ) );\n\t\tthis.pushResult( {\n\t\t\tresult: !result,\n\t\t\tactual: result,\n\t\t\texpected: false,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tequal: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected == actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotEqual: function( actual, expected, message ) {\n\t\t/*jshint eqeqeq:false */\n\t\tthis.pushResult( {\n\t\t\tresult: expected != actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tpropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotPropEqual: function( actual, expected, message ) {\n\t\tactual = objectValues( actual );\n\t\texpected = objectValues( expected );\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tdeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotDeepEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: !QUnit.equiv( actual, expected ),\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\tstrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected === actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message\n\t\t} );\n\t},\n\n\tnotStrictEqual: function( actual, expected, message ) {\n\t\tthis.pushResult( {\n\t\t\tresult: expected !== actual,\n\t\t\tactual: actual,\n\t\t\texpected: expected,\n\t\t\tmessage: message,\n\t\t\tnegative: true\n\t\t} );\n\t},\n\n\t\"throws\": function( block, expected, message ) {\n\t\tvar actual, expectedType,\n\t\t\texpectedOutput = expected,\n\t\t\tok = false,\n\t\t\tcurrentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\n\n\t\t// 'expected' is optional unless doing string comparison\n\t\tif ( message == null && typeof expected === \"string\" ) {\n\t\t\tmessage = expected;\n\t\t\texpected = null;\n\t\t}\n\n\t\tcurrentTest.ignoreGlobalErrors = true;\n\t\ttry {\n\t\t\tblock.call( currentTest.testEnvironment );\n\t\t} catch ( e ) {\n\t\t\tactual = e;\n\t\t}\n\t\tcurrentTest.ignoreGlobalErrors = false;\n\n\t\tif ( actual ) {\n\t\t\texpectedType = QUnit.objectType( expected );\n\n\t\t\t// We don't want to validate thrown error\n\t\t\tif ( !expected ) {\n\t\t\t\tok = true;\n\t\t\t\texpectedOutput = null;\n\n\t\t\t// Expected is a regexp\n\t\t\t} else if ( expectedType === \"regexp\" ) {\n\t\t\t\tok = expected.test( errorString( actual ) );\n\n\t\t\t// Expected is a string\n\t\t\t} else if ( expectedType === \"string\" ) {\n\t\t\t\tok = expected === errorString( actual );\n\n\t\t\t// Expected is a constructor, maybe an Error constructor\n\t\t\t} else if ( expectedType === \"function\" && actual instanceof expected ) {\n\t\t\t\tok = true;\n\n\t\t\t// Expected is an Error object\n\t\t\t} else if ( expectedType === \"object\" ) {\n\t\t\t\tok = actual instanceof expected.constructor &&\n\t\t\t\t\tactual.name === expected.name &&\n\t\t\t\t\tactual.message === expected.message;\n\n\t\t\t// Expected is a validation function which returns true if validation passed\n\t\t\t} else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\n\t\t\t\texpectedOutput = null;\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\n\t\tcurrentTest.assert.pushResult( {\n\t\t\tresult: ok,\n\t\t\tactual: actual,\n\t\t\texpected: expectedOutput,\n\t\t\tmessage: message\n\t\t} );\n\t}\n};\n\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\n// Known to us are: Closure Compiler, Narwhal\n( function() {\n\t/*jshint sub:true */\n\tAssert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\n}() );\n\nfunction errorString( error ) {\n\tvar name, message,\n\t\tresultErrorString = error.toString();\n\tif ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\n\t\tname = error.name ? error.name.toString() : \"Error\";\n\t\tmessage = error.message ? error.message.toString() : \"\";\n\t\tif ( name && message ) {\n\t\t\treturn name + \": \" + message;\n\t\t} else if ( name ) {\n\t\t\treturn name;\n\t\t} else if ( message ) {\n\t\t\treturn message;\n\t\t} else {\n\t\t\treturn \"Error\";\n\t\t}\n\t} else {\n\t\treturn resultErrorString;\n\t}\n}\n\n// Test for equality any JavaScript type.\n// Author: Philippe Rathé <prathe@gmail.com>\nQUnit.equiv = ( function() {\n\n\t// Stack to decide between skip/abort functions\n\tvar callers = [];\n\n\t// Stack to avoiding loops from circular referencing\n\tvar parents = [];\n\tvar parentsB = [];\n\n\tvar getProto = Object.getPrototypeOf || function( obj ) {\n\n\t\t/*jshint proto: true */\n\t\treturn obj.__proto__;\n\t};\n\n\tfunction useStrictEquality( b, a ) {\n\n\t\t// To catch short annotation VS 'new' annotation of a declaration. e.g.:\n\t\t// `var i = 1;`\n\t\t// `var j = new Number(1);`\n\t\tif ( typeof a === \"object\" ) {\n\t\t\ta = a.valueOf();\n\t\t}\n\t\tif ( typeof b === \"object\" ) {\n\t\t\tb = b.valueOf();\n\t\t}\n\n\t\treturn a === b;\n\t}\n\n\tfunction compareConstructors( a, b ) {\n\t\tvar protoA = getProto( a );\n\t\tvar protoB = getProto( b );\n\n\t\t// Comparing constructors is more strict than using `instanceof`\n\t\tif ( a.constructor === b.constructor ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Ref #851\n\t\t// If the obj prototype descends from a null constructor, treat it\n\t\t// as a null prototype.\n\t\tif ( protoA && protoA.constructor === null ) {\n\t\t\tprotoA = null;\n\t\t}\n\t\tif ( protoB && protoB.constructor === null ) {\n\t\t\tprotoB = null;\n\t\t}\n\n\t\t// Allow objects with no prototype to be equivalent to\n\t\t// objects with Object as their constructor.\n\t\tif ( ( protoA === null && protoB === Object.prototype ) ||\n\t\t\t\t( protoB === null && protoA === Object.prototype ) ) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction getRegExpFlags( regexp ) {\n\t\treturn \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\n\t}\n\n\tvar callbacks = {\n\t\t\"string\": useStrictEquality,\n\t\t\"boolean\": useStrictEquality,\n\t\t\"number\": useStrictEquality,\n\t\t\"null\": useStrictEquality,\n\t\t\"undefined\": useStrictEquality,\n\t\t\"symbol\": useStrictEquality,\n\t\t\"date\": useStrictEquality,\n\n\t\t\"nan\": function() {\n\t\t\treturn true;\n\t\t},\n\n\t\t\"regexp\": function( b, a ) {\n\t\t\treturn a.source === b.source &&\n\n\t\t\t\t// Include flags in the comparison\n\t\t\t\tgetRegExpFlags( a ) === getRegExpFlags( b );\n\t\t},\n\n\t\t// - skip when the property is a method of an instance (OOP)\n\t\t// - abort otherwise,\n\t\t// initial === would have catch identical references anyway\n\t\t\"function\": function() {\n\t\t\tvar caller = callers[ callers.length - 1 ];\n\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\n\t\t},\n\n\t\t\"array\": function( b, a ) {\n\t\t\tvar i, j, len, loop, aCircular, bCircular;\n\n\t\t\tlen = a.length;\n\t\t\tif ( len !== b.length ) {\n\n\t\t\t\t// Safe and faster\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparents.pop();\n\t\t\t\t\t\t\tparentsB.pop();\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\tparents.pop();\n\t\t\t\t\tparentsB.pop();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\t\t\treturn true;\n\t\t},\n\n\t\t\"set\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal ) {\n\t\t\t\t\tif ( innerEquiv( bVal, aVal ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"map\": function( b, a ) {\n\t\t\tvar innerEq,\n\t\t\t\touterEq = true;\n\n\t\t\tif ( a.size !== b.size ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\ta.forEach( function( aVal, aKey ) {\n\t\t\t\tinnerEq = false;\n\n\t\t\t\tb.forEach( function( bVal, bKey ) {\n\t\t\t\t\tif ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\n\t\t\t\t\t\tinnerEq = true;\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tif ( !innerEq ) {\n\t\t\t\t\touterEq = false;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\treturn outerEq;\n\t\t},\n\n\t\t\"object\": function( b, a ) {\n\t\t\tvar i, j, loop, aCircular, bCircular;\n\n\t\t\t// Default to true\n\t\t\tvar eq = true;\n\t\t\tvar aProperties = [];\n\t\t\tvar bProperties = [];\n\n\t\t\tif ( compareConstructors( a, b ) === false ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stack constructor before traversing properties\n\t\t\tcallers.push( a.constructor );\n\n\t\t\t// Track reference to avoid circular references\n\t\t\tparents.push( a );\n\t\t\tparentsB.push( b );\n\n\t\t\t// Be strict: don't ensure hasOwnProperty and go deep\n\t\t\tfor ( i in a ) {\n\t\t\t\tloop = false;\n\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\n\t\t\t\t\taCircular = parents[ j ] === a[ i ];\n\t\t\t\t\tbCircular = parentsB[ j ] === b[ i ];\n\t\t\t\t\tif ( aCircular || bCircular ) {\n\t\t\t\t\t\tif ( a[ i ] === b[ i ] || aCircular && bCircular ) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\teq = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\taProperties.push( i );\n\t\t\t\tif ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\n\t\t\t\t\teq = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparents.pop();\n\t\t\tparentsB.pop();\n\n\t\t\t// Unstack, we are done\n\t\t\tcallers.pop();\n\n\t\t\tfor ( i in b ) {\n\n\t\t\t\t// Collect b's properties\n\t\t\t\tbProperties.push( i );\n\t\t\t}\n\n\t\t\t// Ensures identical properties name\n\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\n\t\t}\n\t};\n\n\tfunction typeEquiv( a, b ) {\n\t\tvar type = QUnit.objectType( a );\n\t\treturn QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\n\t}\n\n\t// The real equiv function\n\tfunction innerEquiv( a, b ) {\n\n\t\t// We're done when there's nothing more to compare\n\t\tif ( arguments.length < 2 ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Require type-specific equality\n\t\treturn ( a === b || typeEquiv( a, b ) ) &&\n\n\t\t\t// ...across all consecutive argument pairs\n\t\t\t( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\n\t}\n\n\treturn innerEquiv;\n}() );\n\n// Based on jsDump by Ariel Flesler\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\nQUnit.dump = ( function() {\n\tfunction quote( str ) {\n\t\treturn \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\n\t}\n\tfunction literal( o ) {\n\t\treturn o + \"\";\n\t}\n\tfunction join( pre, arr, post ) {\n\t\tvar s = dump.separator(),\n\t\t\tbase = dump.indent(),\n\t\t\tinner = dump.indent( 1 );\n\t\tif ( arr.join ) {\n\t\t\tarr = arr.join( \",\" + s + inner );\n\t\t}\n\t\tif ( !arr ) {\n\t\t\treturn pre + post;\n\t\t}\n\t\treturn [ pre, inner + arr, base + post ].join( s );\n\t}\n\tfunction array( arr, stack ) {\n\t\tvar i = arr.length,\n\t\t\tret = new Array( i );\n\n\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\treturn \"[object Array]\";\n\t\t}\n\n\t\tthis.up();\n\t\twhile ( i-- ) {\n\t\t\tret[ i ] = this.parse( arr[ i ], undefined, stack );\n\t\t}\n\t\tthis.down();\n\t\treturn join( \"[\", ret, \"]\" );\n\t}\n\n\tvar reName = /^function (\\w+)/,\n\t\tdump = {\n\n\t\t\t// The objType is used mostly internally, you can fix a (custom) type in advance\n\t\t\tparse: function( obj, objType, stack ) {\n\t\t\t\tstack = stack || [];\n\t\t\t\tvar res, parser, parserType,\n\t\t\t\t\tinStack = inArray( obj, stack );\n\n\t\t\t\tif ( inStack !== -1 ) {\n\t\t\t\t\treturn \"recursion(\" + ( inStack - stack.length ) + \")\";\n\t\t\t\t}\n\n\t\t\t\tobjType = objType || this.typeOf( obj  );\n\t\t\t\tparser = this.parsers[ objType ];\n\t\t\t\tparserType = typeof parser;\n\n\t\t\t\tif ( parserType === \"function\" ) {\n\t\t\t\t\tstack.push( obj );\n\t\t\t\t\tres = parser.call( this, obj, stack );\n\t\t\t\t\tstack.pop();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\treturn ( parserType === \"string\" ) ? parser : this.parsers.error;\n\t\t\t},\n\t\t\ttypeOf: function( obj ) {\n\t\t\t\tvar type;\n\t\t\t\tif ( obj === null ) {\n\t\t\t\t\ttype = \"null\";\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\n\t\t\t\t\ttype = \"undefined\";\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj ) ) {\n\t\t\t\t\ttype = \"regexp\";\n\t\t\t\t} else if ( QUnit.is( \"date\", obj ) ) {\n\t\t\t\t\ttype = \"date\";\n\t\t\t\t} else if ( QUnit.is( \"function\", obj ) ) {\n\t\t\t\t\ttype = \"function\";\n\t\t\t\t} else if ( obj.setInterval !== undefined &&\n\t\t\t\t\t\tobj.document !== undefined &&\n\t\t\t\t\t\tobj.nodeType === undefined ) {\n\t\t\t\t\ttype = \"window\";\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\n\t\t\t\t\ttype = \"document\";\n\t\t\t\t} else if ( obj.nodeType ) {\n\t\t\t\t\ttype = \"node\";\n\t\t\t\t} else if (\n\n\t\t\t\t\t// Native arrays\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\n\n\t\t\t\t\t// NodeList objects\n\t\t\t\t\t( typeof obj.length === \"number\" && obj.item !== undefined &&\n\t\t\t\t\t( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\n\t\t\t\t\tobj[ 0 ] === undefined ) ) )\n\t\t\t\t) {\n\t\t\t\t\ttype = \"array\";\n\t\t\t\t} else if ( obj.constructor === Error.prototype.constructor ) {\n\t\t\t\t\ttype = \"error\";\n\t\t\t\t} else {\n\t\t\t\t\ttype = typeof obj;\n\t\t\t\t}\n\t\t\t\treturn type;\n\t\t\t},\n\n\t\t\tseparator: function() {\n\t\t\t\treturn this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\n\t\t\t},\n\n\t\t\t// Extra can be a number, shortcut for increasing-calling-decreasing\n\t\t\tindent: function( extra ) {\n\t\t\t\tif ( !this.multiline ) {\n\t\t\t\t\treturn \"\";\n\t\t\t\t}\n\t\t\t\tvar chr = this.indentChar;\n\t\t\t\tif ( this.HTML ) {\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\n\t\t\t\t}\n\t\t\t\treturn new Array( this.depth + ( extra || 0 ) ).join( chr );\n\t\t\t},\n\t\t\tup: function( a ) {\n\t\t\t\tthis.depth += a || 1;\n\t\t\t},\n\t\t\tdown: function( a ) {\n\t\t\t\tthis.depth -= a || 1;\n\t\t\t},\n\t\t\tsetParser: function( name, parser ) {\n\t\t\t\tthis.parsers[ name ] = parser;\n\t\t\t},\n\n\t\t\t// The next 3 are exposed so you can use them\n\t\t\tquote: quote,\n\t\t\tliteral: literal,\n\t\t\tjoin: join,\n\t\t\tdepth: 1,\n\t\t\tmaxDepth: QUnit.config.maxDepth,\n\n\t\t\t// This is the list of parsers, to modify them, use dump.setParser\n\t\t\tparsers: {\n\t\t\t\twindow: \"[Window]\",\n\t\t\t\tdocument: \"[Document]\",\n\t\t\t\terror: function( error ) {\n\t\t\t\t\treturn \"Error(\\\"\" + error.message + \"\\\")\";\n\t\t\t\t},\n\t\t\t\tunknown: \"[Unknown]\",\n\t\t\t\t\"null\": \"null\",\n\t\t\t\t\"undefined\": \"undefined\",\n\t\t\t\t\"function\": function( fn ) {\n\t\t\t\t\tvar ret = \"function\",\n\n\t\t\t\t\t\t// Functions never have name in IE\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\n\n\t\t\t\t\tif ( name ) {\n\t\t\t\t\t\tret += \" \" + name;\n\t\t\t\t\t}\n\t\t\t\t\tret += \"(\";\n\n\t\t\t\t\tret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\n\t\t\t\t\treturn join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\n\t\t\t\t},\n\t\t\t\tarray: array,\n\t\t\t\tnodelist: array,\n\t\t\t\t\"arguments\": array,\n\t\t\t\tobject: function( map, stack ) {\n\t\t\t\t\tvar keys, key, val, i, nonEnumerableProperties,\n\t\t\t\t\t\tret = [];\n\n\t\t\t\t\tif ( dump.maxDepth && dump.depth > dump.maxDepth ) {\n\t\t\t\t\t\treturn \"[object Object]\";\n\t\t\t\t\t}\n\n\t\t\t\t\tdump.up();\n\t\t\t\t\tkeys = [];\n\t\t\t\t\tfor ( key in map ) {\n\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Some properties are not always enumerable on Error objects.\n\t\t\t\t\tnonEnumerableProperties = [ \"message\", \"name\" ];\n\t\t\t\t\tfor ( i in nonEnumerableProperties ) {\n\t\t\t\t\t\tkey = nonEnumerableProperties[ i ];\n\t\t\t\t\t\tif ( key in map && inArray( key, keys ) < 0 ) {\n\t\t\t\t\t\t\tkeys.push( key );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tkeys.sort();\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\n\t\t\t\t\t\tkey = keys[ i ];\n\t\t\t\t\t\tval = map[ key ];\n\t\t\t\t\t\tret.push( dump.parse( key, \"key\" ) + \": \" +\n\t\t\t\t\t\t\tdump.parse( val, undefined, stack ) );\n\t\t\t\t\t}\n\t\t\t\t\tdump.down();\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\n\t\t\t\t},\n\t\t\t\tnode: function( node ) {\n\t\t\t\t\tvar len, i, val,\n\t\t\t\t\t\topen = dump.HTML ? \"&lt;\" : \"<\",\n\t\t\t\t\t\tclose = dump.HTML ? \"&gt;\" : \">\",\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\n\t\t\t\t\t\tret = open + tag,\n\t\t\t\t\t\tattrs = node.attributes;\n\n\t\t\t\t\tif ( attrs ) {\n\t\t\t\t\t\tfor ( i = 0, len = attrs.length; i < len; i++ ) {\n\t\t\t\t\t\t\tval = attrs[ i ].nodeValue;\n\n\t\t\t\t\t\t\t// IE6 includes all attributes in .attributes, even ones not explicitly\n\t\t\t\t\t\t\t// set. Those have values like undefined, null, 0, false, \"\" or\n\t\t\t\t\t\t\t// \"inherit\".\n\t\t\t\t\t\t\tif ( val && val !== \"inherit\" ) {\n\t\t\t\t\t\t\t\tret += \" \" + attrs[ i ].nodeName + \"=\" +\n\t\t\t\t\t\t\t\t\tdump.parse( val, \"attribute\" );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tret += close;\n\n\t\t\t\t\t// Show content of TextNode or CDATASection\n\t\t\t\t\tif ( node.nodeType === 3 || node.nodeType === 4 ) {\n\t\t\t\t\t\tret += node.nodeValue;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn ret + open + \"/\" + tag + close;\n\t\t\t\t},\n\n\t\t\t\t// Function calls it internally, it's the arguments part of the function\n\t\t\t\tfunctionArgs: function( fn ) {\n\t\t\t\t\tvar args,\n\t\t\t\t\t\tl = fn.length;\n\n\t\t\t\t\tif ( !l ) {\n\t\t\t\t\t\treturn \"\";\n\t\t\t\t\t}\n\n\t\t\t\t\targs = new Array( l );\n\t\t\t\t\twhile ( l-- ) {\n\n\t\t\t\t\t\t// 97 is 'a'\n\t\t\t\t\t\targs[ l ] = String.fromCharCode( 97 + l );\n\t\t\t\t\t}\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\n\t\t\t\t},\n\n\t\t\t\t// Object calls it internally, the key part of an item in a map\n\t\t\t\tkey: quote,\n\n\t\t\t\t// Function calls it internally, it's the content of the function\n\t\t\t\tfunctionCode: \"[code]\",\n\n\t\t\t\t// Node calls it internally, it's a html attribute value\n\t\t\t\tattribute: quote,\n\t\t\t\tstring: quote,\n\t\t\t\tdate: quote,\n\t\t\t\tregexp: literal,\n\t\t\t\tnumber: literal,\n\t\t\t\t\"boolean\": literal\n\t\t\t},\n\n\t\t\t// If true, entities are escaped ( <, >, \\t, space and \\n )\n\t\t\tHTML: false,\n\n\t\t\t// Indentation unit\n\t\t\tindentChar: \"  \",\n\n\t\t\t// If true, items in a collection, are separated by a \\n, else just a space.\n\t\t\tmultiline: true\n\t\t};\n\n\treturn dump;\n}() );\n\n// Back compat\nQUnit.jsDump = QUnit.dump;\n\n// Deprecated\n// Extend assert methods to QUnit for Backwards compatibility\n( function() {\n\tvar i,\n\t\tassertions = Assert.prototype;\n\n\tfunction applyCurrent( current ) {\n\t\treturn function() {\n\t\t\tvar assert = new Assert( QUnit.config.current );\n\t\t\tcurrent.apply( assert, arguments );\n\t\t};\n\t}\n\n\tfor ( i in assertions ) {\n\t\tQUnit[ i ] = applyCurrent( assertions[ i ] );\n\t}\n}() );\n\n// For browser, export only select globals\nif ( defined.document ) {\n\n\t( function() {\n\t\tvar i, l,\n\t\t\tkeys = [\n\t\t\t\t\"test\",\n\t\t\t\t\"module\",\n\t\t\t\t\"expect\",\n\t\t\t\t\"asyncTest\",\n\t\t\t\t\"start\",\n\t\t\t\t\"stop\",\n\t\t\t\t\"ok\",\n\t\t\t\t\"notOk\",\n\t\t\t\t\"equal\",\n\t\t\t\t\"notEqual\",\n\t\t\t\t\"propEqual\",\n\t\t\t\t\"notPropEqual\",\n\t\t\t\t\"deepEqual\",\n\t\t\t\t\"notDeepEqual\",\n\t\t\t\t\"strictEqual\",\n\t\t\t\t\"notStrictEqual\",\n\t\t\t\t\"throws\",\n\t\t\t\t\"raises\"\n\t\t\t];\n\n\t\tfor ( i = 0, l = keys.length; i < l; i++ ) {\n\t\t\twindow[ keys[ i ] ] = QUnit[ keys[ i ] ];\n\t\t}\n\t}() );\n\n\twindow.QUnit = QUnit;\n}\n\n// For nodejs\nif ( typeof module !== \"undefined\" && module && module.exports ) {\n\tmodule.exports = QUnit;\n\n\t// For consistency with CommonJS environments' exports\n\tmodule.exports.QUnit = QUnit;\n}\n\n// For CommonJS with exports, but without module.exports, like Rhino\nif ( typeof exports !== \"undefined\" && exports ) {\n\texports.QUnit = QUnit;\n}\n\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine( function() {\n\t\treturn QUnit;\n\t} );\n\tQUnit.config.autostart = false;\n}\n\n// Get a reference to the global object, like window in browsers\n}( ( function() {\n\treturn this;\n}() ) ) );\n\n( function() {\n\n// Only interact with URLs via window.location\nvar location = typeof window !== \"undefined\" && window.location;\nif ( !location ) {\n\treturn;\n}\n\nvar urlParams = getUrlParams();\n\nQUnit.urlParams = urlParams;\n\n// Match module/test by inclusion in an array\nQUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\nQUnit.config.testId = [].concat( urlParams.testId || [] );\n\n// Exact case-insensitive match of the module name\nQUnit.config.module = urlParams.module;\n\n// Regular expression or case-insenstive substring match against \"moduleName: testName\"\nQUnit.config.filter = urlParams.filter;\n\n// Test order randomization\nif ( urlParams.seed === true ) {\n\n\t// Generate a random seed if the option is specified without a value\n\tQUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\n} else if ( urlParams.seed ) {\n\tQUnit.config.seed = urlParams.seed;\n}\n\n// Add URL-parameter-mapped config values with UI form rendering data\nQUnit.config.urlConfig.push(\n\t{\n\t\tid: \"hidepassed\",\n\t\tlabel: \"Hide passed tests\",\n\t\ttooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"noglobals\",\n\t\tlabel: \"Check for Globals\",\n\t\ttooltip: \"Enabling this will test if any test introduces new properties on the \" +\n\t\t\t\"global object (`window` in Browsers). Stored as query-strings.\"\n\t},\n\t{\n\t\tid: \"notrycatch\",\n\t\tlabel: \"No try-catch\",\n\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\n\t\t\t\"exceptions in IE reasonable. Stored as query-strings.\"\n\t}\n);\n\nQUnit.begin( function() {\n\tvar i, option,\n\t\turlConfig = QUnit.config.urlConfig;\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\toption = QUnit.config.urlConfig[ i ];\n\t\tif ( typeof option !== \"string\" ) {\n\t\t\toption = option.id;\n\t\t}\n\n\t\tif ( QUnit.config[ option ] === undefined ) {\n\t\t\tQUnit.config[ option ] = urlParams[ option ];\n\t\t}\n\t}\n} );\n\nfunction getUrlParams() {\n\tvar i, param, name, value;\n\tvar urlParams = {};\n\tvar params = location.search.slice( 1 ).split( \"&\" );\n\tvar length = params.length;\n\n\tfor ( i = 0; i < length; i++ ) {\n\t\tif ( params[ i ] ) {\n\t\t\tparam = params[ i ].split( \"=\" );\n\t\t\tname = decodeURIComponent( param[ 0 ] );\n\n\t\t\t// Allow just a key to turn on a flag, e.g., test.html?noglobals\n\t\t\tvalue = param.length === 1 ||\n\t\t\t\tdecodeURIComponent( param.slice( 1 ).join( \"=\" ) ) ;\n\t\t\tif ( urlParams[ name ] ) {\n\t\t\t\turlParams[ name ] = [].concat( urlParams[ name ], value );\n\t\t\t} else {\n\t\t\t\turlParams[ name ] = value;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn urlParams;\n}\n\n// Don't load the HTML Reporter on non-browser environments\nif ( typeof window === \"undefined\" || !window.document ) {\n\treturn;\n}\n\n// Deprecated QUnit.init - Ref #530\n// Re-initialize the configuration options\nQUnit.init = function() {\n\tvar config = QUnit.config;\n\n\tconfig.stats = { all: 0, bad: 0 };\n\tconfig.moduleStats = { all: 0, bad: 0 };\n\tconfig.started = 0;\n\tconfig.updateRate = 1000;\n\tconfig.blocking = false;\n\tconfig.autostart = true;\n\tconfig.autorun = false;\n\tconfig.filter = \"\";\n\tconfig.queue = [];\n\n\tappendInterface();\n};\n\nvar config = QUnit.config,\n\tdocument = window.document,\n\tcollapseNext = false,\n\thasOwn = Object.prototype.hasOwnProperty,\n\tunfilteredUrl = setUrl( { filter: undefined, module: undefined,\n\t\tmoduleId: undefined, testId: undefined } ),\n\tdefined = {\n\t\tsessionStorage: ( function() {\n\t\t\tvar x = \"qunit-test-string\";\n\t\t\ttry {\n\t\t\t\tsessionStorage.setItem( x, x );\n\t\t\t\tsessionStorage.removeItem( x );\n\t\t\t\treturn true;\n\t\t\t} catch ( e ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}() )\n\t},\n\tmodulesList = [];\n\n/**\n* Escape text for attribute or text content.\n*/\nfunction escapeText( s ) {\n\tif ( !s ) {\n\t\treturn \"\";\n\t}\n\ts = s + \"\";\n\n\t// Both single quotes and double quotes (for attributes)\n\treturn s.replace( /['\"<>&]/g, function( s ) {\n\t\tswitch ( s ) {\n\t\tcase \"'\":\n\t\t\treturn \"&#039;\";\n\t\tcase \"\\\"\":\n\t\t\treturn \"&quot;\";\n\t\tcase \"<\":\n\t\t\treturn \"&lt;\";\n\t\tcase \">\":\n\t\t\treturn \"&gt;\";\n\t\tcase \"&\":\n\t\t\treturn \"&amp;\";\n\t\t}\n\t} );\n}\n\n/**\n * @param {HTMLElement} elem\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvent( elem, type, fn ) {\n\tif ( elem.addEventListener ) {\n\n\t\t// Standards-based browsers\n\t\telem.addEventListener( type, fn, false );\n\t} else if ( elem.attachEvent ) {\n\n\t\t// Support: IE <9\n\t\telem.attachEvent( \"on\" + type, function() {\n\t\t\tvar event = window.event;\n\t\t\tif ( !event.target ) {\n\t\t\t\tevent.target = event.srcElement || document;\n\t\t\t}\n\n\t\t\tfn.call( elem, event );\n\t\t} );\n\t}\n}\n\n/**\n * @param {Array|NodeList} elems\n * @param {string} type\n * @param {Function} fn\n */\nfunction addEvents( elems, type, fn ) {\n\tvar i = elems.length;\n\twhile ( i-- ) {\n\t\taddEvent( elems[ i ], type, fn );\n\t}\n}\n\nfunction hasClass( elem, name ) {\n\treturn ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\n}\n\nfunction addClass( elem, name ) {\n\tif ( !hasClass( elem, name ) ) {\n\t\telem.className += ( elem.className ? \" \" : \"\" ) + name;\n\t}\n}\n\nfunction toggleClass( elem, name, force ) {\n\tif ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\n\t\taddClass( elem, name );\n\t} else {\n\t\tremoveClass( elem, name );\n\t}\n}\n\nfunction removeClass( elem, name ) {\n\tvar set = \" \" + elem.className + \" \";\n\n\t// Class name may appear multiple times\n\twhile ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\n\t\tset = set.replace( \" \" + name + \" \", \" \" );\n\t}\n\n\t// Trim for prettiness\n\telem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\nfunction id( name ) {\n\treturn document.getElementById && document.getElementById( name );\n}\n\nfunction getUrlConfigHtml() {\n\tvar i, j, val,\n\t\tescaped, escapedTooltip,\n\t\tselection = false,\n\t\turlConfig = config.urlConfig,\n\t\turlConfigHtml = \"\";\n\n\tfor ( i = 0; i < urlConfig.length; i++ ) {\n\n\t\t// Options can be either strings or objects with nonempty \"id\" properties\n\t\tval = config.urlConfig[ i ];\n\t\tif ( typeof val === \"string\" ) {\n\t\t\tval = {\n\t\t\t\tid: val,\n\t\t\t\tlabel: val\n\t\t\t};\n\t\t}\n\n\t\tescaped = escapeText( val.id );\n\t\tescapedTooltip = escapeText( val.tooltip );\n\n\t\tif ( !val.value || typeof val.value === \"string\" ) {\n\t\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' type='checkbox'\" +\n\t\t\t\t( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\n\t\t\t\t( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\n\t\t\t\t\" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\n\t\t} else {\n\t\t\turlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' title='\" + escapedTooltip + \"'>\" + val.label +\n\t\t\t\t\": </label><select id='qunit-urlconfig-\" + escaped +\n\t\t\t\t\"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\n\n\t\t\tif ( QUnit.is( \"array\", val.value ) ) {\n\t\t\t\tfor ( j = 0; j < val.value.length; j++ ) {\n\t\t\t\t\tescaped = escapeText( val.value[ j ] );\n\t\t\t\t\turlConfigHtml += \"<option value='\" + escaped + \"'\" +\n\t\t\t\t\t\t( config[ val.id ] === val.value[ j ] ?\n\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\">\" + escaped + \"</option>\";\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( j in val.value ) {\n\t\t\t\t\tif ( hasOwn.call( val.value, j ) ) {\n\t\t\t\t\t\turlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\n\t\t\t\t\t\t\t( config[ val.id ] === j ?\n\t\t\t\t\t\t\t\t( selection = true ) && \" selected='selected'\" : \"\" ) +\n\t\t\t\t\t\t\t\">\" + escapeText( val.value[ j ] ) + \"</option>\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( config[ val.id ] && !selection ) {\n\t\t\t\tescaped = escapeText( config[ val.id ] );\n\t\t\t\turlConfigHtml += \"<option value='\" + escaped +\n\t\t\t\t\t\"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\n\t\t\t}\n\t\t\turlConfigHtml += \"</select>\";\n\t\t}\n\t}\n\n\treturn urlConfigHtml;\n}\n\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\n// Updates the URL with the new state of `config.urlConfig` values.\nfunction toolbarChanged() {\n\tvar updatedUrl, value, tests,\n\t\tfield = this,\n\t\tparams = {};\n\n\t// Detect if field is a select menu or a checkbox\n\tif ( \"selectedIndex\" in field ) {\n\t\tvalue = field.options[ field.selectedIndex ].value || undefined;\n\t} else {\n\t\tvalue = field.checked ? ( field.defaultValue || true ) : undefined;\n\t}\n\n\tparams[ field.name ] = value;\n\tupdatedUrl = setUrl( params );\n\n\t// Check if we can apply the change without a page refresh\n\tif ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\n\t\tQUnit.urlParams[ field.name ] = value;\n\t\tconfig[ field.name ] = value || false;\n\t\ttests = id( \"qunit-tests\" );\n\t\tif ( tests ) {\n\t\t\ttoggleClass( tests, \"hidepass\", value || false );\n\t\t}\n\t\twindow.history.replaceState( null, \"\", updatedUrl );\n\t} else {\n\t\twindow.location = updatedUrl;\n\t}\n}\n\nfunction setUrl( params ) {\n\tvar key, arrValue, i,\n\t\tquerystring = \"?\",\n\t\tlocation = window.location;\n\n\tparams = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\n\n\tfor ( key in params ) {\n\n\t\t// Skip inherited or undefined properties\n\t\tif ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\n\n\t\t\t// Output a parameter for each value of this key (but usually just one)\n\t\t\tarrValue = [].concat( params[ key ] );\n\t\t\tfor ( i = 0; i < arrValue.length; i++ ) {\n\t\t\t\tquerystring += encodeURIComponent( key );\n\t\t\t\tif ( arrValue[ i ] !== true ) {\n\t\t\t\t\tquerystring += \"=\" + encodeURIComponent( arrValue[ i ] );\n\t\t\t\t}\n\t\t\t\tquerystring += \"&\";\n\t\t\t}\n\t\t}\n\t}\n\treturn location.protocol + \"//\" + location.host +\n\t\tlocation.pathname + querystring.slice( 0, -1 );\n}\n\nfunction applyUrlParams() {\n\tvar selectedModule,\n\t\tmodulesList = id( \"qunit-modulefilter\" ),\n\t\tfilter = id( \"qunit-filter-input\" ).value;\n\n\tselectedModule = modulesList ?\n\t\tdecodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\n\t\tundefined;\n\n\twindow.location = setUrl( {\n\t\tmodule: ( selectedModule === \"\" ) ? undefined : selectedModule,\n\t\tfilter: ( filter === \"\" ) ? undefined : filter,\n\n\t\t// Remove moduleId and testId filters\n\t\tmoduleId: undefined,\n\t\ttestId: undefined\n\t} );\n}\n\nfunction toolbarUrlConfigContainer() {\n\tvar urlConfigContainer = document.createElement( \"span\" );\n\n\turlConfigContainer.innerHTML = getUrlConfigHtml();\n\taddClass( urlConfigContainer, \"qunit-url-config\" );\n\n\t// For oldIE support:\n\t// * Add handlers to the individual elements instead of the container\n\t// * Use \"click\" instead of \"change\" for checkboxes\n\taddEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"click\", toolbarChanged );\n\taddEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\n\n\treturn urlConfigContainer;\n}\n\nfunction toolbarLooseFilter() {\n\tvar filter = document.createElement( \"form\" ),\n\t\tlabel = document.createElement( \"label\" ),\n\t\tinput = document.createElement( \"input\" ),\n\t\tbutton = document.createElement( \"button\" );\n\n\taddClass( filter, \"qunit-filter\" );\n\n\tlabel.innerHTML = \"Filter: \";\n\n\tinput.type = \"text\";\n\tinput.value = config.filter || \"\";\n\tinput.name = \"filter\";\n\tinput.id = \"qunit-filter-input\";\n\n\tbutton.innerHTML = \"Go\";\n\n\tlabel.appendChild( input );\n\n\tfilter.appendChild( label );\n\tfilter.appendChild( button );\n\taddEvent( filter, \"submit\", function( ev ) {\n\t\tapplyUrlParams();\n\n\t\tif ( ev && ev.preventDefault ) {\n\t\t\tev.preventDefault();\n\t\t}\n\n\t\treturn false;\n\t} );\n\n\treturn filter;\n}\n\nfunction toolbarModuleFilterHtml() {\n\tvar i,\n\t\tmoduleFilterHtml = \"\";\n\n\tif ( !modulesList.length ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label>\" +\n\t\t\"<select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\n\t\t( QUnit.urlParams.module === undefined ? \"selected='selected'\" : \"\" ) +\n\t\t\">< All Modules ></option>\";\n\n\tfor ( i = 0; i < modulesList.length; i++ ) {\n\t\tmoduleFilterHtml += \"<option value='\" +\n\t\t\tescapeText( encodeURIComponent( modulesList[ i ] ) ) + \"' \" +\n\t\t\t( QUnit.urlParams.module === modulesList[ i ] ? \"selected='selected'\" : \"\" ) +\n\t\t\t\">\" + escapeText( modulesList[ i ] ) + \"</option>\";\n\t}\n\tmoduleFilterHtml += \"</select>\";\n\n\treturn moduleFilterHtml;\n}\n\nfunction toolbarModuleFilter() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" ),\n\t\tmoduleFilter = document.createElement( \"span\" ),\n\t\tmoduleFilterHtml = toolbarModuleFilterHtml();\n\n\tif ( !toolbar || !moduleFilterHtml ) {\n\t\treturn false;\n\t}\n\n\tmoduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\n\tmoduleFilter.innerHTML = moduleFilterHtml;\n\n\taddEvent( moduleFilter.lastChild, \"change\", applyUrlParams );\n\n\ttoolbar.appendChild( moduleFilter );\n}\n\nfunction appendToolbar() {\n\tvar toolbar = id( \"qunit-testrunner-toolbar\" );\n\n\tif ( toolbar ) {\n\t\ttoolbar.appendChild( toolbarUrlConfigContainer() );\n\t\ttoolbar.appendChild( toolbarLooseFilter() );\n\t\ttoolbarModuleFilter();\n\t}\n}\n\nfunction appendHeader() {\n\tvar header = id( \"qunit-header\" );\n\n\tif ( header ) {\n\t\theader.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\n\t\t\t\"</a> \";\n\t}\n}\n\nfunction appendBanner() {\n\tvar banner = id( \"qunit-banner\" );\n\n\tif ( banner ) {\n\t\tbanner.className = \"\";\n\t}\n}\n\nfunction appendTestResults() {\n\tvar tests = id( \"qunit-tests\" ),\n\t\tresult = id( \"qunit-testresult\" );\n\n\tif ( result ) {\n\t\tresult.parentNode.removeChild( result );\n\t}\n\n\tif ( tests ) {\n\t\ttests.innerHTML = \"\";\n\t\tresult = document.createElement( \"p\" );\n\t\tresult.id = \"qunit-testresult\";\n\t\tresult.className = \"result\";\n\t\ttests.parentNode.insertBefore( result, tests );\n\t\tresult.innerHTML = \"Running...<br />&#160;\";\n\t}\n}\n\nfunction storeFixture() {\n\tvar fixture = id( \"qunit-fixture\" );\n\tif ( fixture ) {\n\t\tconfig.fixture = fixture.innerHTML;\n\t}\n}\n\nfunction appendFilteredTest() {\n\tvar testId = QUnit.config.testId;\n\tif ( !testId || testId.length <= 0 ) {\n\t\treturn \"\";\n\t}\n\treturn \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\n\t\tescapeText( testId.join( \", \" ) ) +\n\t\t\" <a id='qunit-clearFilter' href='\" +\n\t\tescapeText( unfilteredUrl ) +\n\t\t\"'>Run all tests</a></div>\";\n}\n\nfunction appendUserAgent() {\n\tvar userAgent = id( \"qunit-userAgent\" );\n\n\tif ( userAgent ) {\n\t\tuserAgent.innerHTML = \"\";\n\t\tuserAgent.appendChild(\n\t\t\tdocument.createTextNode(\n\t\t\t\t\"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\n\t\t\t)\n\t\t);\n\t}\n}\n\nfunction appendInterface() {\n\tvar qunit = id( \"qunit\" );\n\n\tif ( qunit ) {\n\t\tqunit.innerHTML =\n\t\t\t\"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\n\t\t\t\"<h2 id='qunit-banner'></h2>\" +\n\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\n\t\t\tappendFilteredTest() +\n\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\n\t\t\t\"<ol id='qunit-tests'></ol>\";\n\t}\n\n\tappendHeader();\n\tappendBanner();\n\tappendTestResults();\n\tappendUserAgent();\n\tappendToolbar();\n}\n\nfunction appendTestsList( modules ) {\n\tvar i, l, x, z, test, moduleObj;\n\n\tfor ( i = 0, l = modules.length; i < l; i++ ) {\n\t\tmoduleObj = modules[ i ];\n\n\t\tfor ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\n\t\t\ttest = moduleObj.tests[ x ];\n\n\t\t\tappendTest( test.name, test.testId, moduleObj.name );\n\t\t}\n\t}\n}\n\nfunction appendTest( name, testId, moduleName ) {\n\tvar title, rerunTrigger, testBlock, assertList,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttitle = document.createElement( \"strong\" );\n\ttitle.innerHTML = getNameHtml( name, moduleName );\n\n\trerunTrigger = document.createElement( \"a\" );\n\trerunTrigger.innerHTML = \"Rerun\";\n\trerunTrigger.href = setUrl( { testId: testId } );\n\n\ttestBlock = document.createElement( \"li\" );\n\ttestBlock.appendChild( title );\n\ttestBlock.appendChild( rerunTrigger );\n\ttestBlock.id = \"qunit-test-output-\" + testId;\n\n\tassertList = document.createElement( \"ol\" );\n\tassertList.className = \"qunit-assert-list\";\n\n\ttestBlock.appendChild( assertList );\n\n\ttests.appendChild( testBlock );\n}\n\n// HTML Reporter initialization and load\nQUnit.begin( function( details ) {\n\tvar i, moduleObj, tests;\n\n\t// Sort modules by name for the picker\n\tfor ( i = 0; i < details.modules.length; i++ ) {\n\t\tmoduleObj = details.modules[ i ];\n\t\tif ( moduleObj.name ) {\n\t\t\tmodulesList.push( moduleObj.name );\n\t\t}\n\t}\n\tmodulesList.sort( function( a, b ) {\n\t\treturn a.localeCompare( b );\n\t} );\n\n\t// Capture fixture HTML from the page\n\tstoreFixture();\n\n\t// Initialize QUnit elements\n\tappendInterface();\n\tappendTestsList( details.modules );\n\ttests = id( \"qunit-tests\" );\n\tif ( tests && config.hidepassed ) {\n\t\taddClass( tests, \"hidepass\" );\n\t}\n} );\n\nQUnit.done( function( details ) {\n\tvar i, key,\n\t\tbanner = id( \"qunit-banner\" ),\n\t\ttests = id( \"qunit-tests\" ),\n\t\thtml = [\n\t\t\t\"Tests completed in \",\n\t\t\tdetails.runtime,\n\t\t\t\" milliseconds.<br />\",\n\t\t\t\"<span class='passed'>\",\n\t\t\tdetails.passed,\n\t\t\t\"</span> assertions of <span class='total'>\",\n\t\t\tdetails.total,\n\t\t\t\"</span> passed, <span class='failed'>\",\n\t\t\tdetails.failed,\n\t\t\t\"</span> failed.\"\n\t\t].join( \"\" );\n\n\tif ( banner ) {\n\t\tbanner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\n\t}\n\n\tif ( tests ) {\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\n\t}\n\n\tif ( config.altertitle && document.title ) {\n\n\t\t// Show ✖ for good, ✔ for bad suite result in title\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\n\t\tdocument.title = [\n\t\t\t( details.failed ? \"\\u2716\" : \"\\u2714\" ),\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\n\t\t].join( \" \" );\n\t}\n\n\t// Clear own sessionStorage items if all tests passed\n\tif ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\n\t\t\tkey = sessionStorage.key( i++ );\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\n\t\t\t\tsessionStorage.removeItem( key );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Scroll back to top to show results\n\tif ( config.scrolltop && window.scrollTo ) {\n\t\twindow.scrollTo( 0, 0 );\n\t}\n} );\n\nfunction getNameHtml( name, module ) {\n\tvar nameHtml = \"\";\n\n\tif ( module ) {\n\t\tnameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\n\t}\n\n\tnameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\n\n\treturn nameHtml;\n}\n\nQUnit.testStart( function( details ) {\n\tvar running, testBlock, bad;\n\n\ttestBlock = id( \"qunit-test-output-\" + details.testId );\n\tif ( testBlock ) {\n\t\ttestBlock.className = \"running\";\n\t} else {\n\n\t\t// Report later registered tests\n\t\tappendTest( details.name, details.testId, details.module );\n\t}\n\n\trunning = id( \"qunit-testresult\" );\n\tif ( running ) {\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\n\t\t\t+sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\n\t\trunning.innerHTML = ( bad ?\n\t\t\t\"Rerunning previously failed test: <br />\" :\n\t\t\t\"Running: <br />\" ) +\n\t\t\tgetNameHtml( details.name, details.module );\n\t}\n\n} );\n\nfunction stripHtml( string ) {\n\n\t// Strip tags, html entity and whitespaces\n\treturn string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\n}\n\nQUnit.log( function( details ) {\n\tvar assertList, assertLi,\n\t\tmessage, expected, actual, diff,\n\t\tshowDiff = false,\n\t\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tif ( !testItem ) {\n\t\treturn;\n\t}\n\n\tmessage = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\n\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\n\tmessage += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\n\n\t// The pushFailure doesn't provide details.expected\n\t// when it calls, it's implicit to also not show expected and diff stuff\n\t// Also, we need to check details.expected existence, as it can exist and be undefined\n\tif ( !details.result && hasOwn.call( details, \"expected\" ) ) {\n\t\tif ( details.negative ) {\n\t\t\texpected = \"NOT \" + QUnit.dump.parse( details.expected );\n\t\t} else {\n\t\t\texpected = QUnit.dump.parse( details.expected );\n\t\t}\n\n\t\tactual = QUnit.dump.parse( details.actual );\n\t\tmessage += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\n\t\t\tescapeText( expected ) +\n\t\t\t\"</pre></td></tr>\";\n\n\t\tif ( actual !== expected ) {\n\n\t\t\tmessage += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\n\t\t\t\tescapeText( actual ) + \"</pre></td></tr>\";\n\n\t\t\t// Don't show diff if actual or expected are booleans\n\t\t\tif ( !( /^(true|false)$/.test( actual ) ) &&\n\t\t\t\t\t!( /^(true|false)$/.test( expected ) ) ) {\n\t\t\t\tdiff = QUnit.diff( expected, actual );\n\t\t\t\tshowDiff = stripHtml( diff ).length !==\n\t\t\t\t\tstripHtml( expected ).length +\n\t\t\t\t\tstripHtml( actual ).length;\n\t\t\t}\n\n\t\t\t// Don't show diff if expected and actual are totally different\n\t\t\tif ( showDiff ) {\n\t\t\t\tmessage += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\n\t\t\t\t\tdiff + \"</pre></td></tr>\";\n\t\t\t}\n\t\t} else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\n\t\t\t\texpected.indexOf( \"[object Object]\" ) !== -1 ) {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the depth of object is more than current max depth (\" +\n\t\t\t\tQUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\n\t\t\t\t\" run with a higher max depth or <a href='\" +\n\t\t\t\tescapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\n\t\t\t\t\"Rerun</a> without max depth.</p></td></tr>\";\n\t\t} else {\n\t\t\tmessage += \"<tr class='test-message'><th>Message: </th><td>\" +\n\t\t\t\t\"Diff suppressed as the expected and actual results have an equivalent\" +\n\t\t\t\t\" serialization</td></tr>\";\n\t\t}\n\n\t\tif ( details.source ) {\n\t\t\tmessage += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\t\tescapeText( details.source ) + \"</pre></td></tr>\";\n\t\t}\n\n\t\tmessage += \"</table>\";\n\n\t// This occurs when pushFailure is set and we have an extracted stack trace\n\t} else if ( !details.result && details.source ) {\n\t\tmessage += \"<table>\" +\n\t\t\t\"<tr class='test-source'><th>Source: </th><td><pre>\" +\n\t\t\tescapeText( details.source ) + \"</pre></td></tr>\" +\n\t\t\t\"</table>\";\n\t}\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tassertLi = document.createElement( \"li\" );\n\tassertLi.className = details.result ? \"pass\" : \"fail\";\n\tassertLi.innerHTML = message;\n\tassertList.appendChild( assertLi );\n} );\n\nQUnit.testDone( function( details ) {\n\tvar testTitle, time, testItem, assertList,\n\t\tgood, bad, testCounts, skipped, sourceName,\n\t\ttests = id( \"qunit-tests\" );\n\n\tif ( !tests ) {\n\t\treturn;\n\t}\n\n\ttestItem = id( \"qunit-test-output-\" + details.testId );\n\n\tassertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\n\n\tgood = details.passed;\n\tbad = details.failed;\n\n\t// Store result when possible\n\tif ( config.reorder && defined.sessionStorage ) {\n\t\tif ( bad ) {\n\t\t\tsessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\n\t\t} else {\n\t\t\tsessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\n\t\t}\n\t}\n\n\tif ( bad === 0 ) {\n\n\t\t// Collapse the passing tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t} else if ( bad && config.collapse && !collapseNext ) {\n\n\t\t// Skip collapsing the first failing test\n\t\tcollapseNext = true;\n\t} else {\n\n\t\t// Collapse remaining tests\n\t\taddClass( assertList, \"qunit-collapsed\" );\n\t}\n\n\t// The testItem.firstChild is the test name\n\ttestTitle = testItem.firstChild;\n\n\ttestCounts = bad ?\n\t\t\"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\n\t\t\"\";\n\n\ttestTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\n\t\tdetails.assertions.length + \")</b>\";\n\n\tif ( details.skipped ) {\n\t\ttestItem.className = \"skipped\";\n\t\tskipped = document.createElement( \"em\" );\n\t\tskipped.className = \"qunit-skipped-label\";\n\t\tskipped.innerHTML = \"skipped\";\n\t\ttestItem.insertBefore( skipped, testTitle );\n\t} else {\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( assertList, \"qunit-collapsed\" );\n\t\t} );\n\n\t\ttestItem.className = bad ? \"fail\" : \"pass\";\n\n\t\ttime = document.createElement( \"span\" );\n\t\ttime.className = \"runtime\";\n\t\ttime.innerHTML = details.runtime + \" ms\";\n\t\ttestItem.insertBefore( time, assertList );\n\t}\n\n\t// Show the source of the test when showing assertions\n\tif ( details.source ) {\n\t\tsourceName = document.createElement( \"p\" );\n\t\tsourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\n\t\taddClass( sourceName, \"qunit-source\" );\n\t\tif ( bad === 0 ) {\n\t\t\taddClass( sourceName, \"qunit-collapsed\" );\n\t\t}\n\t\taddEvent( testTitle, \"click\", function() {\n\t\t\ttoggleClass( sourceName, \"qunit-collapsed\" );\n\t\t} );\n\t\ttestItem.appendChild( sourceName );\n\t}\n} );\n\n// Avoid readyState issue with phantomjs\n// Ref: #818\nvar notPhantom = ( function( p ) {\n\treturn !( p && p.version && p.version.major > 0 );\n} )( window.phantom );\n\nif ( notPhantom && document.readyState === \"complete\" ) {\n\tQUnit.load();\n} else {\n\taddEvent( window, \"load\", QUnit.load );\n}\n\n/*\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\n * modifications are licensed as more fully set forth in LICENSE.txt.\n *\n * The original source of google-diff-match-patch is attributable and licensed as follows:\n *\n * Copyright 2006 Google Inc.\n * https://code.google.com/p/google-diff-match-patch/\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * More Info:\n *  https://code.google.com/p/google-diff-match-patch/\n *\n * Usage: QUnit.diff(expected, actual)\n *\n */\nQUnit.diff = ( function() {\n\tfunction DiffMatchPatch() {\n\t}\n\n\t//  DIFF FUNCTIONS\n\n\t/**\n\t * The data structure representing a diff is an array of tuples:\n\t * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\n\t * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\n\t */\n\tvar DIFF_DELETE = -1,\n\t\tDIFF_INSERT = 1,\n\t\tDIFF_EQUAL = 0;\n\n\t/**\n\t * Find the differences between two texts.  Simplifies the problem by stripping\n\t * any common prefix or suffix off the texts before diffing.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean=} optChecklines Optional speedup flag. If present and false,\n\t *     then don't run a line-level diff first to identify the changed areas.\n\t *     Defaults to true, which does a faster, slightly less optimal diff.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\n\t\tvar deadline, checklines, commonlength,\n\t\t\tcommonprefix, commonsuffix, diffs;\n\n\t\t// The diff must be complete in up to 1 second.\n\t\tdeadline = ( new Date() ).getTime() + 1000;\n\n\t\t// Check for null inputs.\n\t\tif ( text1 === null || text2 === null ) {\n\t\t\tthrow new Error( \"Null input. (DiffMain)\" );\n\t\t}\n\n\t\t// Check for equality (speedup).\n\t\tif ( text1 === text2 ) {\n\t\t\tif ( text1 ) {\n\t\t\t\treturn [\n\t\t\t\t\t[ DIFF_EQUAL, text1 ]\n\t\t\t\t];\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tif ( typeof optChecklines === \"undefined\" ) {\n\t\t\toptChecklines = true;\n\t\t}\n\n\t\tchecklines = optChecklines;\n\n\t\t// Trim off common prefix (speedup).\n\t\tcommonlength = this.diffCommonPrefix( text1, text2 );\n\t\tcommonprefix = text1.substring( 0, commonlength );\n\t\ttext1 = text1.substring( commonlength );\n\t\ttext2 = text2.substring( commonlength );\n\n\t\t// Trim off common suffix (speedup).\n\t\tcommonlength = this.diffCommonSuffix( text1, text2 );\n\t\tcommonsuffix = text1.substring( text1.length - commonlength );\n\t\ttext1 = text1.substring( 0, text1.length - commonlength );\n\t\ttext2 = text2.substring( 0, text2.length - commonlength );\n\n\t\t// Compute the diff on the middle block.\n\t\tdiffs = this.diffCompute( text1, text2, checklines, deadline );\n\n\t\t// Restore the prefix and suffix.\n\t\tif ( commonprefix ) {\n\t\t\tdiffs.unshift( [ DIFF_EQUAL, commonprefix ] );\n\t\t}\n\t\tif ( commonsuffix ) {\n\t\t\tdiffs.push( [ DIFF_EQUAL, commonsuffix ] );\n\t\t}\n\t\tthis.diffCleanupMerge( diffs );\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating operationally trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, preIns, preDel, postIns, postDel;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Is there an insertion operation before the last equality.\n\t\tpreIns = false;\n\n\t\t// Is there a deletion operation before the last equality.\n\t\tpreDel = false;\n\n\t\t// Is there an insertion operation after the last equality.\n\t\tpostIns = false;\n\n\t\t// Is there a deletion operation after the last equality.\n\t\tpostDel = false;\n\t\twhile ( pointer < diffs.length ) {\n\n\t\t\t// Equality found.\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\n\t\t\t\tif ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\n\n\t\t\t\t\t// Candidate found.\n\t\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\t\tpreIns = postIns;\n\t\t\t\t\tpreDel = postDel;\n\t\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// Not a candidate, and can never become one.\n\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t}\n\t\t\t\tpostIns = postDel = false;\n\n\t\t\t// An insertion or deletion.\n\t\t\t} else {\n\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\n\t\t\t\t\tpostDel = true;\n\t\t\t\t} else {\n\t\t\t\t\tpostIns = true;\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Five types to be split:\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\n\t\t\t\t */\n\t\t\t\tif ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\n\t\t\t\t\t\t( ( lastequality.length < 2 ) &&\n\t\t\t\t\t\t( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\tequalitiesLength--; // Throw away the equality we just deleted;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tif ( preIns && preDel ) {\n\n\t\t\t\t\t\t// No changes made which could affect previous entry, keep going.\n\t\t\t\t\t\tpostIns = postDel = true;\n\t\t\t\t\t\tequalitiesLength = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tequalitiesLength--; // Throw away the previous equality.\n\t\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\t\t\t\t\t\tpostIns = postDel = false;\n\t\t\t\t\t}\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\t/**\n\t * Convert a diff array into a pretty HTML report.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {integer} string to be beautified.\n\t * @return {string} HTML representation.\n\t */\n\tDiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\n\t\tvar op, data, x,\n\t\t\thtml = [];\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\top = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\n\t\t\tdata = diffs[ x ][ 1 ]; // Text of change.\n\t\t\tswitch ( op ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\thtml[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\thtml[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\t\t\t\thtml[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn html.join( \"\" );\n\t};\n\n\t/**\n\t * Determine the common prefix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the start of each\n\t *     string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerstart;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerstart = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( pointerstart, pointermid ) ===\n\t\t\t\t\ttext2.substring( pointerstart, pointermid ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerstart = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Determine the common suffix of two strings.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of each string.\n\t */\n\tDiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\n\t\tvar pointermid, pointermax, pointermin, pointerend;\n\n\t\t// Quick check for common null cases.\n\t\tif ( !text1 ||\n\t\t\t\t!text2 ||\n\t\t\t\ttext1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Binary search.\n\t\t// Performance analysis: https://neil.fraser.name/news/2007/10/09/\n\t\tpointermin = 0;\n\t\tpointermax = Math.min( text1.length, text2.length );\n\t\tpointermid = pointermax;\n\t\tpointerend = 0;\n\t\twhile ( pointermin < pointermid ) {\n\t\t\tif ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\n\t\t\t\t\ttext2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\n\t\t\t\tpointermin = pointermid;\n\t\t\t\tpointerend = pointermin;\n\t\t\t} else {\n\t\t\t\tpointermax = pointermid;\n\t\t\t}\n\t\t\tpointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\n\t\t}\n\t\treturn pointermid;\n\t};\n\n\t/**\n\t * Find the differences between two texts.  Assumes that the texts do not\n\t * have any common prefix or suffix.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {boolean} checklines Speedup flag.  If false, then don't run a\n\t *     line-level diff first to identify the changed areas.\n\t *     If true, then run a faster, slightly less optimal diff.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\n\t\tvar diffs, longtext, shorttext, i, hm,\n\t\t\ttext1A, text2A, text1B, text2B,\n\t\t\tmidCommon, diffsA, diffsB;\n\n\t\tif ( !text1 ) {\n\n\t\t\t// Just add some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\tif ( !text2 ) {\n\n\t\t\t// Just delete some text (speedup).\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ]\n\t\t\t];\n\t\t}\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\ti = longtext.indexOf( shorttext );\n\t\tif ( i !== -1 ) {\n\n\t\t\t// Shorter text is inside the longer text (speedup).\n\t\t\tdiffs = [\n\t\t\t\t[ DIFF_INSERT, longtext.substring( 0, i ) ],\n\t\t\t\t[ DIFF_EQUAL, shorttext ],\n\t\t\t\t[ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\n\t\t\t];\n\n\t\t\t// Swap insertions for deletions if diff is reversed.\n\t\t\tif ( text1.length > text2.length ) {\n\t\t\t\tdiffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\n\t\t\t}\n\t\t\treturn diffs;\n\t\t}\n\n\t\tif ( shorttext.length === 1 ) {\n\n\t\t\t// Single character string.\n\t\t\t// After the previous speedup, the character can't be an equality.\n\t\t\treturn [\n\t\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t\t[ DIFF_INSERT, text2 ]\n\t\t\t];\n\t\t}\n\n\t\t// Check to see if the problem can be split in two.\n\t\thm = this.diffHalfMatch( text1, text2 );\n\t\tif ( hm ) {\n\n\t\t\t// A half-match was found, sort out the return data.\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t\tmidCommon = hm[ 4 ];\n\n\t\t\t// Send both pairs off for separate processing.\n\t\t\tdiffsA = this.DiffMain( text1A, text2A, checklines, deadline );\n\t\t\tdiffsB = this.DiffMain( text1B, text2B, checklines, deadline );\n\n\t\t\t// Merge the results.\n\t\t\treturn diffsA.concat( [\n\t\t\t\t[ DIFF_EQUAL, midCommon ]\n\t\t\t], diffsB );\n\t\t}\n\n\t\tif ( checklines && text1.length > 100 && text2.length > 100 ) {\n\t\t\treturn this.diffLineMode( text1, text2, deadline );\n\t\t}\n\n\t\treturn this.diffBisect( text1, text2, deadline );\n\t};\n\n\t/**\n\t * Do the two texts share a substring which is at least half the length of the\n\t * longer text?\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t *     text1, the suffix of text1, the prefix of text2, the suffix of\n\t *     text2 and the common middle.  Or null if there was no match.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\n\t\tvar longtext, shorttext, dmp,\n\t\t\ttext1A, text2B, text2A, text1B, midCommon,\n\t\t\thm1, hm2, hm;\n\n\t\tlongtext = text1.length > text2.length ? text1 : text2;\n\t\tshorttext = text1.length > text2.length ? text2 : text1;\n\t\tif ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\n\t\t\treturn null; // Pointless.\n\t\t}\n\t\tdmp = this; // 'this' becomes 'window' in a closure.\n\n\t\t/**\n\t\t * Does a substring of shorttext exist within longtext such that the substring\n\t\t * is at least half the length of longtext?\n\t\t * Closure, but does not reference any external variables.\n\t\t * @param {string} longtext Longer string.\n\t\t * @param {string} shorttext Shorter string.\n\t\t * @param {number} i Start index of quarter length substring within longtext.\n\t\t * @return {Array.<string>} Five element Array, containing the prefix of\n\t\t *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\n\t\t *     of shorttext and the common middle.  Or null if there was no match.\n\t\t * @private\n\t\t */\n\t\tfunction diffHalfMatchI( longtext, shorttext, i ) {\n\t\t\tvar seed, j, bestCommon, prefixLength, suffixLength,\n\t\t\t\tbestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\n\n\t\t\t// Start with a 1/4 length substring at position i as a seed.\n\t\t\tseed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\n\t\t\tj = -1;\n\t\t\tbestCommon = \"\";\n\t\t\twhile ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\n\t\t\t\tprefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\n\t\t\t\t\tshorttext.substring( j ) );\n\t\t\t\tsuffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\n\t\t\t\t\tshorttext.substring( 0, j ) );\n\t\t\t\tif ( bestCommon.length < suffixLength + prefixLength ) {\n\t\t\t\t\tbestCommon = shorttext.substring( j - suffixLength, j ) +\n\t\t\t\t\t\tshorttext.substring( j, j + prefixLength );\n\t\t\t\t\tbestLongtextA = longtext.substring( 0, i - suffixLength );\n\t\t\t\t\tbestLongtextB = longtext.substring( i + prefixLength );\n\t\t\t\t\tbestShorttextA = shorttext.substring( 0, j - suffixLength );\n\t\t\t\t\tbestShorttextB = shorttext.substring( j + prefixLength );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( bestCommon.length * 2 >= longtext.length ) {\n\t\t\t\treturn [ bestLongtextA, bestLongtextB,\n\t\t\t\t\tbestShorttextA, bestShorttextB, bestCommon\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\t// First check if the second quarter is the seed for a half-match.\n\t\thm1 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 4 ) );\n\n\t\t// Check again based on the third quarter.\n\t\thm2 = diffHalfMatchI( longtext, shorttext,\n\t\t\tMath.ceil( longtext.length / 2 ) );\n\t\tif ( !hm1 && !hm2 ) {\n\t\t\treturn null;\n\t\t} else if ( !hm2 ) {\n\t\t\thm = hm1;\n\t\t} else if ( !hm1 ) {\n\t\t\thm = hm2;\n\t\t} else {\n\n\t\t\t// Both matched.  Select the longest.\n\t\t\thm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\n\t\t}\n\n\t\t// A half-match was found, sort out the return data.\n\t\ttext1A, text1B, text2A, text2B;\n\t\tif ( text1.length > text2.length ) {\n\t\t\ttext1A = hm[ 0 ];\n\t\t\ttext1B = hm[ 1 ];\n\t\t\ttext2A = hm[ 2 ];\n\t\t\ttext2B = hm[ 3 ];\n\t\t} else {\n\t\t\ttext2A = hm[ 0 ];\n\t\t\ttext2B = hm[ 1 ];\n\t\t\ttext1A = hm[ 2 ];\n\t\t\ttext1B = hm[ 3 ];\n\t\t}\n\t\tmidCommon = hm[ 4 ];\n\t\treturn [ text1A, text1B, text2A, text2B, midCommon ];\n\t};\n\n\t/**\n\t * Do a quick line-level diff on both strings, then rediff the parts for\n\t * greater accuracy.\n\t * This speedup can produce non-minimal diffs.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time when the diff should be complete by.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\n\t\tvar a, diffs, linearray, pointer, countInsert,\n\t\t\tcountDelete, textInsert, textDelete, j;\n\n\t\t// Scan the text on a line-by-line basis first.\n\t\ta = this.diffLinesToChars( text1, text2 );\n\t\ttext1 = a.chars1;\n\t\ttext2 = a.chars2;\n\t\tlinearray = a.lineArray;\n\n\t\tdiffs = this.DiffMain( text1, text2, false, deadline );\n\n\t\t// Convert the diff back to original text.\n\t\tthis.diffCharsToLines( diffs, linearray );\n\n\t\t// Eliminate freak matches (e.g. blank lines)\n\t\tthis.diffCleanupSemantic( diffs );\n\n\t\t// Rediff any replacement blocks, this time character-by-character.\n\t\t// Add a dummy entry at the end.\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] );\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete >= 1 && countInsert >= 1 ) {\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tdiffs.splice( pointer - countDelete - countInsert,\n\t\t\t\t\t\tcountDelete + countInsert );\n\t\t\t\t\tpointer = pointer - countDelete - countInsert;\n\t\t\t\t\ta = this.DiffMain( textDelete, textInsert, false, deadline );\n\t\t\t\t\tfor ( j = a.length - 1; j >= 0; j-- ) {\n\t\t\t\t\t\tdiffs.splice( pointer, 0, a[ j ] );\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer + a.length;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\n\t\treturn diffs;\n\t};\n\n\t/**\n\t * Find the 'middle snake' of a diff, split the problem in two\n\t * and return the recursively constructed diff.\n\t * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\n\t\tvar text1Length, text2Length, maxD, vOffset, vLength,\n\t\t\tv1, v2, x, delta, front, k1start, k1end, k2start,\n\t\t\tk2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\t\tmaxD = Math.ceil( ( text1Length + text2Length ) / 2 );\n\t\tvOffset = maxD;\n\t\tvLength = 2 * maxD;\n\t\tv1 = new Array( vLength );\n\t\tv2 = new Array( vLength );\n\n\t\t// Setting all elements to -1 is faster in Chrome & Firefox than mixing\n\t\t// integers and undefined.\n\t\tfor ( x = 0; x < vLength; x++ ) {\n\t\t\tv1[ x ] = -1;\n\t\t\tv2[ x ] = -1;\n\t\t}\n\t\tv1[ vOffset + 1 ] = 0;\n\t\tv2[ vOffset + 1 ] = 0;\n\t\tdelta = text1Length - text2Length;\n\n\t\t// If the total number of characters is odd, then the front path will collide\n\t\t// with the reverse path.\n\t\tfront = ( delta % 2 !== 0 );\n\n\t\t// Offsets for start and end of k loop.\n\t\t// Prevents mapping of space beyond the grid.\n\t\tk1start = 0;\n\t\tk1end = 0;\n\t\tk2start = 0;\n\t\tk2end = 0;\n\t\tfor ( d = 0; d < maxD; d++ ) {\n\n\t\t\t// Bail out if deadline is reached.\n\t\t\tif ( ( new Date() ).getTime() > deadline ) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Walk the front path one step.\n\t\t\tfor ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\n\t\t\t\tk1Offset = vOffset + k1;\n\t\t\t\tif ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\n\t\t\t\t\tx1 = v1[ k1Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx1 = v1[ k1Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty1 = x1 - k1;\n\t\t\t\twhile ( x1 < text1Length && y1 < text2Length &&\n\t\t\t\t\ttext1.charAt( x1 ) === text2.charAt( y1 ) ) {\n\t\t\t\t\tx1++;\n\t\t\t\t\ty1++;\n\t\t\t\t}\n\t\t\t\tv1[ k1Offset ] = x1;\n\t\t\t\tif ( x1 > text1Length ) {\n\n\t\t\t\t\t// Ran off the right of the graph.\n\t\t\t\t\tk1end += 2;\n\t\t\t\t} else if ( y1 > text2Length ) {\n\n\t\t\t\t\t// Ran off the bottom of the graph.\n\t\t\t\t\tk1start += 2;\n\t\t\t\t} else if ( front ) {\n\t\t\t\t\tk2Offset = vOffset + delta - k1;\n\t\t\t\t\tif ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - v2[ k2Offset ];\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Walk the reverse path one step.\n\t\t\tfor ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\n\t\t\t\tk2Offset = vOffset + k2;\n\t\t\t\tif ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\n\t\t\t\t\tx2 = v2[ k2Offset + 1 ];\n\t\t\t\t} else {\n\t\t\t\t\tx2 = v2[ k2Offset - 1 ] + 1;\n\t\t\t\t}\n\t\t\t\ty2 = x2 - k2;\n\t\t\t\twhile ( x2 < text1Length && y2 < text2Length &&\n\t\t\t\t\ttext1.charAt( text1Length - x2 - 1 ) ===\n\t\t\t\t\ttext2.charAt( text2Length - y2 - 1 ) ) {\n\t\t\t\t\tx2++;\n\t\t\t\t\ty2++;\n\t\t\t\t}\n\t\t\t\tv2[ k2Offset ] = x2;\n\t\t\t\tif ( x2 > text1Length ) {\n\n\t\t\t\t\t// Ran off the left of the graph.\n\t\t\t\t\tk2end += 2;\n\t\t\t\t} else if ( y2 > text2Length ) {\n\n\t\t\t\t\t// Ran off the top of the graph.\n\t\t\t\t\tk2start += 2;\n\t\t\t\t} else if ( !front ) {\n\t\t\t\t\tk1Offset = vOffset + delta - k2;\n\t\t\t\t\tif ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\n\t\t\t\t\t\tx1 = v1[ k1Offset ];\n\t\t\t\t\t\ty1 = vOffset + x1 - k1Offset;\n\n\t\t\t\t\t\t// Mirror x2 onto top-left coordinate system.\n\t\t\t\t\t\tx2 = text1Length - x2;\n\t\t\t\t\t\tif ( x1 >= x2 ) {\n\n\t\t\t\t\t\t\t// Overlap detected.\n\t\t\t\t\t\t\treturn this.diffBisectSplit( text1, text2, x1, y1, deadline );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Diff took too long and hit the deadline or\n\t\t// number of diffs equals number of characters, no commonality at all.\n\t\treturn [\n\t\t\t[ DIFF_DELETE, text1 ],\n\t\t\t[ DIFF_INSERT, text2 ]\n\t\t];\n\t};\n\n\t/**\n\t * Given the location of the 'middle snake', split the diff in two parts\n\t * and recurse.\n\t * @param {string} text1 Old string to be diffed.\n\t * @param {string} text2 New string to be diffed.\n\t * @param {number} x Index of split point in text1.\n\t * @param {number} y Index of split point in text2.\n\t * @param {number} deadline Time at which to bail if not yet complete.\n\t * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\n\t\tvar text1a, text1b, text2a, text2b, diffs, diffsb;\n\t\ttext1a = text1.substring( 0, x );\n\t\ttext2a = text2.substring( 0, y );\n\t\ttext1b = text1.substring( x );\n\t\ttext2b = text2.substring( y );\n\n\t\t// Compute both diffs serially.\n\t\tdiffs = this.DiffMain( text1a, text2a, false, deadline );\n\t\tdiffsb = this.DiffMain( text1b, text2b, false, deadline );\n\n\t\treturn diffs.concat( diffsb );\n\t};\n\n\t/**\n\t * Reduce the number of edits by eliminating semantically trivial equalities.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\n\t\tvar changes, equalities, equalitiesLength, lastequality,\n\t\t\tpointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\n\t\t\tlengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\n\t\tchanges = false;\n\t\tequalities = []; // Stack of indices where equalities are found.\n\t\tequalitiesLength = 0; // Keeping our own length var is faster in JS.\n\t\t/** @type {?string} */\n\t\tlastequality = null;\n\n\t\t// Always equal to diffs[equalities[equalitiesLength - 1]][1]\n\t\tpointer = 0; // Index of current position.\n\n\t\t// Number of characters that changed prior to the equality.\n\t\tlengthInsertions1 = 0;\n\t\tlengthDeletions1 = 0;\n\n\t\t// Number of characters that changed after the equality.\n\t\tlengthInsertions2 = 0;\n\t\tlengthDeletions2 = 0;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\n\t\t\t\tequalities[ equalitiesLength++ ] = pointer;\n\t\t\t\tlengthInsertions1 = lengthInsertions2;\n\t\t\t\tlengthDeletions1 = lengthDeletions2;\n\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\tlastequality = diffs[ pointer ][ 1 ];\n\t\t\t} else { // An insertion or deletion.\n\t\t\t\tif ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\t\tlengthInsertions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t} else {\n\t\t\t\t\tlengthDeletions2 += diffs[ pointer ][ 1 ].length;\n\t\t\t\t}\n\n\t\t\t\t// Eliminate an equality that is smaller or equal to the edits on both\n\t\t\t\t// sides of it.\n\t\t\t\tif ( lastequality && ( lastequality.length <=\n\t\t\t\t\t\tMath.max( lengthInsertions1, lengthDeletions1 ) ) &&\n\t\t\t\t\t\t( lastequality.length <= Math.max( lengthInsertions2,\n\t\t\t\t\t\t\tlengthDeletions2 ) ) ) {\n\n\t\t\t\t\t// Duplicate record.\n\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\tequalities[ equalitiesLength - 1 ],\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t[ DIFF_DELETE, lastequality ]\n\t\t\t\t\t);\n\n\t\t\t\t\t// Change second copy to insert.\n\t\t\t\t\tdiffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\n\n\t\t\t\t\t// Throw away the equality we just deleted.\n\t\t\t\t\tequalitiesLength--;\n\n\t\t\t\t\t// Throw away the previous equality (it needs to be reevaluated).\n\t\t\t\t\tequalitiesLength--;\n\t\t\t\t\tpointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\n\n\t\t\t\t\t// Reset the counters.\n\t\t\t\t\tlengthInsertions1 = 0;\n\t\t\t\t\tlengthDeletions1 = 0;\n\t\t\t\t\tlengthInsertions2 = 0;\n\t\t\t\t\tlengthDeletions2 = 0;\n\t\t\t\t\tlastequality = null;\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// Normalize the diff.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\n\t\t// Find any overlaps between deletions and insertions.\n\t\t// e.g: <del>abcxxx</del><ins>xxxdef</ins>\n\t\t//   -> <del>abc</del>xxx<ins>def</ins>\n\t\t// e.g: <del>xxxabc</del><ins>defxxx</ins>\n\t\t//   -> <ins>def</ins>xxx<del>abc</del>\n\t\t// Only extract an overlap if it is as big as the edit ahead or behind it.\n\t\tpointer = 1;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\n\t\t\t\t\tdiffs[ pointer ][ 0 ] === DIFF_INSERT ) {\n\t\t\t\tdeletion = diffs[ pointer - 1 ][ 1 ];\n\t\t\t\tinsertion = diffs[ pointer ][ 1 ];\n\t\t\t\toverlapLength1 = this.diffCommonOverlap( deletion, insertion );\n\t\t\t\toverlapLength2 = this.diffCommonOverlap( insertion, deletion );\n\t\t\t\tif ( overlapLength1 >= overlapLength2 ) {\n\t\t\t\t\tif ( overlapLength1 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength1 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Overlap found.  Insert an equality and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( 0, deletion.length - overlapLength1 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif ( overlapLength2 >= deletion.length / 2 ||\n\t\t\t\t\t\t\toverlapLength2 >= insertion.length / 2 ) {\n\n\t\t\t\t\t\t// Reverse overlap found.\n\t\t\t\t\t\t// Insert an equality and swap and trim the surrounding edits.\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer,\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t[ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] =\n\t\t\t\t\t\t\tinsertion.substring( 0, insertion.length - overlapLength2 );\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\t\tdeletion.substring( overlapLength2 );\n\t\t\t\t\t\tpointer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\t};\n\n\t/**\n\t * Determine if the suffix of one string is the prefix of another.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {number} The number of characters common to the end of the first\n\t *     string and the start of the second string.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\n\t\tvar text1Length, text2Length, textLength,\n\t\t\tbest, length, pattern, found;\n\n\t\t// Cache the text lengths to prevent multiple calls.\n\t\ttext1Length = text1.length;\n\t\ttext2Length = text2.length;\n\n\t\t// Eliminate the null case.\n\t\tif ( text1Length === 0 || text2Length === 0 ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Truncate the longer string.\n\t\tif ( text1Length > text2Length ) {\n\t\t\ttext1 = text1.substring( text1Length - text2Length );\n\t\t} else if ( text1Length < text2Length ) {\n\t\t\ttext2 = text2.substring( 0, text1Length );\n\t\t}\n\t\ttextLength = Math.min( text1Length, text2Length );\n\n\t\t// Quick check for the worst case.\n\t\tif ( text1 === text2 ) {\n\t\t\treturn textLength;\n\t\t}\n\n\t\t// Start by looking for a single character match\n\t\t// and increase length until no match is found.\n\t\t// Performance analysis: https://neil.fraser.name/news/2010/11/04/\n\t\tbest = 0;\n\t\tlength = 1;\n\t\twhile ( true ) {\n\t\t\tpattern = text1.substring( textLength - length );\n\t\t\tfound = text2.indexOf( pattern );\n\t\t\tif ( found === -1 ) {\n\t\t\t\treturn best;\n\t\t\t}\n\t\t\tlength += found;\n\t\t\tif ( found === 0 || text1.substring( textLength - length ) ===\n\t\t\t\t\ttext2.substring( 0, length ) ) {\n\t\t\t\tbest = length;\n\t\t\t\tlength++;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Split two texts into an array of strings.  Reduce the texts to a string of\n\t * hashes where each Unicode character represents one line.\n\t * @param {string} text1 First string.\n\t * @param {string} text2 Second string.\n\t * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\n\t *     An object containing the encoded text1, the encoded text2 and\n\t *     the array of unique strings.\n\t *     The zeroth element of the array of unique strings is intentionally blank.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\n\t\tvar lineArray, lineHash, chars1, chars2;\n\t\tlineArray = []; // E.g. lineArray[4] === 'Hello\\n'\n\t\tlineHash = {};  // E.g. lineHash['Hello\\n'] === 4\n\n\t\t// '\\x00' is a valid character, but various debuggers don't like it.\n\t\t// So we'll insert a junk entry to avoid generating a null character.\n\t\tlineArray[ 0 ] = \"\";\n\n\t\t/**\n\t\t * Split a text into an array of strings.  Reduce the texts to a string of\n\t\t * hashes where each Unicode character represents one line.\n\t\t * Modifies linearray and linehash through being a closure.\n\t\t * @param {string} text String to encode.\n\t\t * @return {string} Encoded string.\n\t\t * @private\n\t\t */\n\t\tfunction diffLinesToCharsMunge( text ) {\n\t\t\tvar chars, lineStart, lineEnd, lineArrayLength, line;\n\t\t\tchars = \"\";\n\n\t\t\t// Walk the text, pulling out a substring for each line.\n\t\t\t// text.split('\\n') would would temporarily double our memory footprint.\n\t\t\t// Modifying text would create many large strings to garbage collect.\n\t\t\tlineStart = 0;\n\t\t\tlineEnd = -1;\n\n\t\t\t// Keeping our own length variable is faster than looking it up.\n\t\t\tlineArrayLength = lineArray.length;\n\t\t\twhile ( lineEnd < text.length - 1 ) {\n\t\t\t\tlineEnd = text.indexOf( \"\\n\", lineStart );\n\t\t\t\tif ( lineEnd === -1 ) {\n\t\t\t\t\tlineEnd = text.length - 1;\n\t\t\t\t}\n\t\t\t\tline = text.substring( lineStart, lineEnd + 1 );\n\t\t\t\tlineStart = lineEnd + 1;\n\n\t\t\t\tif ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\n\t\t\t\t\t\t\t( lineHash[ line ] !== undefined ) ) {\n\t\t\t\t\tchars += String.fromCharCode( lineHash[ line ] );\n\t\t\t\t} else {\n\t\t\t\t\tchars += String.fromCharCode( lineArrayLength );\n\t\t\t\t\tlineHash[ line ] = lineArrayLength;\n\t\t\t\t\tlineArray[ lineArrayLength++ ] = line;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn chars;\n\t\t}\n\n\t\tchars1 = diffLinesToCharsMunge( text1 );\n\t\tchars2 = diffLinesToCharsMunge( text2 );\n\t\treturn {\n\t\t\tchars1: chars1,\n\t\t\tchars2: chars2,\n\t\t\tlineArray: lineArray\n\t\t};\n\t};\n\n\t/**\n\t * Rehydrate the text in a diff from a string of line hashes to real lines of\n\t * text.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t * @param {!Array.<string>} lineArray Array of unique strings.\n\t * @private\n\t */\n\tDiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\n\t\tvar x, chars, text, y;\n\t\tfor ( x = 0; x < diffs.length; x++ ) {\n\t\t\tchars = diffs[ x ][ 1 ];\n\t\t\ttext = [];\n\t\t\tfor ( y = 0; y < chars.length; y++ ) {\n\t\t\t\ttext[ y ] = lineArray[ chars.charCodeAt( y ) ];\n\t\t\t}\n\t\t\tdiffs[ x ][ 1 ] = text.join( \"\" );\n\t\t}\n\t};\n\n\t/**\n\t * Reorder and merge like edit sections.  Merge equalities.\n\t * Any edit section can move as long as it doesn't cross an equality.\n\t * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\n\t */\n\tDiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\n\t\tvar pointer, countDelete, countInsert, textInsert, textDelete,\n\t\t\tcommonlength, changes, diffPointer, position;\n\t\tdiffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\n\t\tpointer = 0;\n\t\tcountDelete = 0;\n\t\tcountInsert = 0;\n\t\ttextDelete = \"\";\n\t\ttextInsert = \"\";\n\t\tcommonlength;\n\t\twhile ( pointer < diffs.length ) {\n\t\t\tswitch ( diffs[ pointer ][ 0 ] ) {\n\t\t\tcase DIFF_INSERT:\n\t\t\t\tcountInsert++;\n\t\t\t\ttextInsert += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_DELETE:\n\t\t\t\tcountDelete++;\n\t\t\t\ttextDelete += diffs[ pointer ][ 1 ];\n\t\t\t\tpointer++;\n\t\t\t\tbreak;\n\t\t\tcase DIFF_EQUAL:\n\n\t\t\t\t// Upon reaching an equality, check for prior redundancies.\n\t\t\t\tif ( countDelete + countInsert > 1 ) {\n\t\t\t\t\tif ( countDelete !== 0 && countInsert !== 0 ) {\n\n\t\t\t\t\t\t// Factor out any common prefixes.\n\t\t\t\t\t\tcommonlength = this.diffCommonPrefix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tif ( ( pointer - countDelete - countInsert ) > 0 &&\n\t\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\n\t\t\t\t\t\t\t\t\tDIFF_EQUAL ) {\n\t\t\t\t\t\t\t\tdiffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength );\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tdiffs.splice( 0, 0, [ DIFF_EQUAL,\n\t\t\t\t\t\t\t\t\ttextInsert.substring( 0, commonlength )\n\t\t\t\t\t\t\t\t] );\n\t\t\t\t\t\t\t\tpointer++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( commonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( commonlength );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Factor out any common suffixies.\n\t\t\t\t\t\tcommonlength = this.diffCommonSuffix( textInsert, textDelete );\n\t\t\t\t\t\tif ( commonlength !== 0 ) {\n\t\t\t\t\t\t\tdiffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\n\t\t\t\t\t\t\t\t\tcommonlength ) + diffs[ pointer ][ 1 ];\n\t\t\t\t\t\t\ttextInsert = textInsert.substring( 0, textInsert.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t\ttextDelete = textDelete.substring( 0, textDelete.length -\n\t\t\t\t\t\t\t\tcommonlength );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Delete the offending records and add the merged ones.\n\t\t\t\t\tif ( countDelete === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_INSERT, textInsert ] );\n\t\t\t\t\t} else if ( countInsert === 0 ) {\n\t\t\t\t\t\tdiffs.splice( pointer - countDelete,\n\t\t\t\t\t\t\tcountDelete + countInsert, [ DIFF_DELETE, textDelete ] );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdiffs.splice(\n\t\t\t\t\t\t\tpointer - countDelete - countInsert,\n\t\t\t\t\t\t\tcountDelete + countInsert,\n\t\t\t\t\t\t\t[ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tpointer = pointer - countDelete - countInsert +\n\t\t\t\t\t\t( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\n\t\t\t\t} else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\t\t// Merge this equality with the previous one.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer, 1 );\n\t\t\t\t} else {\n\t\t\t\t\tpointer++;\n\t\t\t\t}\n\t\t\t\tcountInsert = 0;\n\t\t\t\tcountDelete = 0;\n\t\t\t\ttextDelete = \"\";\n\t\t\t\ttextInsert = \"\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\n\t\t\tdiffs.pop(); // Remove the dummy entry at the end.\n\t\t}\n\n\t\t// Second pass: look for single edits surrounded on both sides by equalities\n\t\t// which can be shifted sideways to eliminate an equality.\n\t\t// e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\n\t\tchanges = false;\n\t\tpointer = 1;\n\n\t\t// Intentionally ignore the first and last element (don't need checking).\n\t\twhile ( pointer < diffs.length - 1 ) {\n\t\t\tif ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\n\t\t\t\t\tdiffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\n\n\t\t\t\tdiffPointer = diffs[ pointer ][ 1 ];\n\t\t\t\tposition = diffPointer.substring(\n\t\t\t\t\tdiffPointer.length - diffs[ pointer - 1 ][ 1 ].length\n\t\t\t\t);\n\n\t\t\t\t// This is a single edit surrounded by equalities.\n\t\t\t\tif ( position === diffs[ pointer - 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the previous equality.\n\t\t\t\t\tdiffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\n\t\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ].length );\n\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer - 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t} else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ] ) {\n\n\t\t\t\t\t// Shift the edit over the next equality.\n\t\t\t\t\tdiffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs[ pointer ][ 1 ] =\n\t\t\t\t\t\tdiffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\n\t\t\t\t\t\tdiffs[ pointer + 1 ][ 1 ];\n\t\t\t\t\tdiffs.splice( pointer + 1, 1 );\n\t\t\t\t\tchanges = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpointer++;\n\t\t}\n\n\t\t// If shifts were made, the diff needs reordering and another shift sweep.\n\t\tif ( changes ) {\n\t\t\tthis.diffCleanupMerge( diffs );\n\t\t}\n\t};\n\n\treturn function( o, n ) {\n\t\tvar diff, output, text;\n\t\tdiff = new DiffMatchPatch();\n\t\toutput = diff.DiffMain( o, n );\n\t\tdiff.diffCleanupEfficiency( output );\n\t\ttext = diff.diffPrettyHtml( output );\n\n\t\treturn text;\n\t};\n}() );\n\n}() );\n","/*!\r\n * QUnit 1.23.1\r\n * https://qunitjs.com/\r\n *\r\n * Copyright jQuery Foundation and other contributors\r\n * Released under the MIT license\r\n * https://jquery.org/license\r\n *\r\n * Date: 2016-04-12T17:29Z\r\n */\r\n\r\nimport * as QUnit from \"qunitjs\"\r\n\r\n( function(global ) {\r\n\r\n  var QUnit = {};\r\n\r\n  var Date = global.Date;\r\n  var now = Date.now || function() {\r\n    return new Date().getTime();\r\n  };\r\n\r\n  var setTimeout = global.setTimeout;\r\n  var clearTimeout = global.clearTimeout;\r\n\r\n// Store a local window from the global to allow direct references.\r\n  var window = global.window;\r\n\r\n  var defined = {\r\n    document: window && window.document !== undefined,\r\n    setTimeout: setTimeout !== undefined,\r\n    sessionStorage: ( function() {\r\n      var x = \"qunit-test-string\";\r\n      try {\r\n        sessionStorage.setItem( x, x );\r\n        sessionStorage.removeItem( x );\r\n        return true;\r\n      } catch ( e ) {\r\n        return false;\r\n      }\r\n    }() )\r\n  };\r\n\r\n  var fileName = ( sourceFromStacktrace( 0 ) || \"\" ).replace( /(:\\d+)+\\)?/, \"\" ).replace( /.+\\//, \"\" );\r\n  var globalStartCalled = false;\r\n  var runStarted = false;\r\n\r\n  var toString = Object.prototype.toString,\r\n    hasOwn = Object.prototype.hasOwnProperty;\r\n\r\n// Returns a new Array with the elements that are in a but not in b\r\n  function diff( a, b ) {\r\n    var i, j,\r\n      result = a.slice();\r\n\r\n    for ( i = 0; i < result.length; i++ ) {\r\n      for ( j = 0; j < b.length; j++ ) {\r\n        if ( result[ i ] === b[ j ] ) {\r\n          result.splice( i, 1 );\r\n          i--;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n// From jquery.js\r\n  function inArray( elem, array ) {\r\n    if ( array.indexOf ) {\r\n      return array.indexOf( elem );\r\n    }\r\n\r\n    for ( var i = 0, length = array.length; i < length; i++ ) {\r\n      if ( array[ i ] === elem ) {\r\n        return i;\r\n      }\r\n    }\r\n\r\n    return -1;\r\n  }\r\n\r\n  /**\r\n   * Makes a clone of an object using only Array or Object as base,\r\n   * and copies over the own enumerable properties.\r\n   *\r\n   * @param {Object} obj\r\n   * @return {Object} New object with only the own properties (recursively).\r\n   */\r\n  function objectValues ( obj ) {\r\n    var key, val,\r\n      vals = QUnit.is( \"array\", obj ) ? [] : {};\r\n    for ( key in obj ) {\r\n      if ( hasOwn.call( obj, key ) ) {\r\n        val = obj[ key ];\r\n        vals[ key ] = val === Object( val ) ? objectValues( val ) : val;\r\n      }\r\n    }\r\n    return vals;\r\n  }\r\n\r\n  function extend( a, b, undefOnly ) {\r\n    for ( var prop in b ) {\r\n      if ( hasOwn.call( b, prop ) ) {\r\n\r\n        // Avoid \"Member not found\" error in IE8 caused by messing with window.constructor\r\n        // This block runs on every environment, so `global` is being used instead of `window`\r\n        // to avoid errors on node.\r\n        if ( prop !== \"constructor\" || a !== global ) {\r\n          if ( b[ prop ] === undefined ) {\r\n            delete a[ prop ];\r\n          } else if ( !( undefOnly && typeof a[ prop ] !== \"undefined\" ) ) {\r\n            a[ prop ] = b[ prop ];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return a;\r\n  }\r\n\r\n  function objectType( obj ) {\r\n    if ( typeof obj === \"undefined\" ) {\r\n      return \"undefined\";\r\n    }\r\n\r\n    // Consider: typeof null === object\r\n    if ( obj === null ) {\r\n      return \"null\";\r\n    }\r\n\r\n    var match = toString.call( obj ).match( /^\\[object\\s(.*)\\]$/ ),\r\n      type = match && match[ 1 ];\r\n\r\n    switch ( type ) {\r\n      case \"Number\":\r\n        if ( isNaN( obj ) ) {\r\n          return \"nan\";\r\n        }\r\n        return \"number\";\r\n      case \"String\":\r\n      case \"Boolean\":\r\n      case \"Array\":\r\n      case \"Set\":\r\n      case \"Map\":\r\n      case \"Date\":\r\n      case \"RegExp\":\r\n      case \"Function\":\r\n      case \"Symbol\":\r\n        return type.toLowerCase();\r\n    }\r\n    if ( typeof obj === \"object\" ) {\r\n      return \"object\";\r\n    }\r\n  }\r\n\r\n// Safe object type checking\r\n  function is( type, obj ) {\r\n    return QUnit.objectType( obj ) === type;\r\n  }\r\n\r\n// Doesn't support IE6 to IE9, it will return undefined on these browsers\r\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\r\n  function extractStacktrace( e, offset ) {\r\n    offset = offset === undefined ? 4 : offset;\r\n\r\n    var stack, include, i;\r\n\r\n    if ( e.stack ) {\r\n      stack = e.stack.split( \"\\n\" );\r\n      if ( /^error$/i.test( stack[ 0 ] ) ) {\r\n        stack.shift();\r\n      }\r\n      if ( fileName ) {\r\n        include = [];\r\n        for ( i = offset; i < stack.length; i++ ) {\r\n          if ( stack[ i ].indexOf( fileName ) !== -1 ) {\r\n            break;\r\n          }\r\n          include.push( stack[ i ] );\r\n        }\r\n        if ( include.length ) {\r\n          return include.join( \"\\n\" );\r\n        }\r\n      }\r\n      return stack[ offset ];\r\n\r\n      // Support: Safari <=6 only\r\n    } else if ( e.sourceURL ) {\r\n\r\n      // Exclude useless self-reference for generated Error objects\r\n      if ( /qunit.js$/.test( e.sourceURL ) ) {\r\n        return;\r\n      }\r\n\r\n      // For actual exceptions, this is useful\r\n      return e.sourceURL + \":\" + e.line;\r\n    }\r\n  }\r\n\r\n  function sourceFromStacktrace( offset ) {\r\n    var error = new Error();\r\n\r\n    // Support: Safari <=7 only, IE <=10 - 11 only\r\n    // Not all browsers generate the `stack` property for `new Error()`, see also #636\r\n    if ( !error.stack ) {\r\n      try {\r\n        throw error;\r\n      } catch ( err ) {\r\n        error = err;\r\n      }\r\n    }\r\n\r\n    return extractStacktrace( error, offset );\r\n  }\r\n\r\n  /**\r\n   * Config object: Maintain internal state\r\n   * Later exposed as QUnit.config\r\n   * `config` initialized at top of scope\r\n   */\r\n  var config = {\r\n\r\n    // The queue of tests to run\r\n    queue: [],\r\n\r\n    // Block until document ready\r\n    blocking: true,\r\n\r\n    // By default, run previously failed tests first\r\n    // very useful in combination with \"Hide passed tests\" checked\r\n    reorder: true,\r\n\r\n    // By default, modify document.title when suite is done\r\n    altertitle: true,\r\n\r\n    // HTML Reporter: collapse every test except the first failing test\r\n    // If false, all failing tests will be expanded\r\n    collapse: true,\r\n\r\n    // By default, scroll to top of the page when suite is done\r\n    scrolltop: true,\r\n\r\n    // Depth up-to which object will be dumped\r\n    maxDepth: 5,\r\n\r\n    // When enabled, all tests must call expect()\r\n    requireExpects: false,\r\n\r\n    // Placeholder for user-configurable form-exposed URL parameters\r\n    urlConfig: [],\r\n\r\n    // Set of all modules.\r\n    modules: [],\r\n\r\n    // Stack of nested modules\r\n    moduleStack: [],\r\n\r\n    // The first unnamed module\r\n    currentModule: {\r\n      name: \"\",\r\n      tests: []\r\n    },\r\n\r\n    callbacks: {}\r\n  };\r\n\r\n// Push a loose unnamed module to the modules collection\r\n  config.modules.push( config.currentModule );\r\n\r\n  var loggingCallbacks = {};\r\n\r\n// Register logging callbacks\r\n  function registerLoggingCallbacks( obj ) {\r\n    var i, l, key,\r\n      callbackNames = [ \"begin\", \"done\", \"log\", \"testStart\", \"testDone\",\r\n        \"moduleStart\", \"moduleDone\" ];\r\n\r\n    function registerLoggingCallback( key ) {\r\n      var loggingCallback = function( callback ) {\r\n        if ( objectType( callback ) !== \"function\" ) {\r\n          throw new Error(\r\n            \"QUnit logging methods require a callback function as their first parameters.\"\r\n          );\r\n        }\r\n\r\n        config.callbacks[ key ].push( callback );\r\n      };\r\n\r\n      // DEPRECATED: This will be removed on QUnit 2.0.0+\r\n      // Stores the registered functions allowing restoring\r\n      // at verifyLoggingCallbacks() if modified\r\n      loggingCallbacks[ key ] = loggingCallback;\r\n\r\n      return loggingCallback;\r\n    }\r\n\r\n    for ( i = 0, l = callbackNames.length; i < l; i++ ) {\r\n      key = callbackNames[ i ];\r\n\r\n      // Initialize key collection of logging callback\r\n      if ( objectType( config.callbacks[ key ] ) === \"undefined\" ) {\r\n        config.callbacks[ key ] = [];\r\n      }\r\n\r\n      obj[ key ] = registerLoggingCallback( key );\r\n    }\r\n  }\r\n\r\n  function runLoggingCallbacks( key, args ) {\r\n    var i, l, callbacks;\r\n\r\n    callbacks = config.callbacks[ key ];\r\n    for ( i = 0, l = callbacks.length; i < l; i++ ) {\r\n      callbacks[ i ]( args );\r\n    }\r\n  }\r\n\r\n// DEPRECATED: This will be removed on 2.0.0+\r\n// This function verifies if the loggingCallbacks were modified by the user\r\n// If so, it will restore it, assign the given callback and print a console warning\r\n  function verifyLoggingCallbacks() {\r\n    var loggingCallback, userCallback;\r\n\r\n    for ( loggingCallback in loggingCallbacks ) {\r\n      if ( QUnit[ loggingCallback ] !== loggingCallbacks[ loggingCallback ] ) {\r\n\r\n        userCallback = QUnit[ loggingCallback ];\r\n\r\n        // Restore the callback function\r\n        QUnit[ loggingCallback ] = loggingCallbacks[ loggingCallback ];\r\n\r\n        // Assign the deprecated given callback\r\n        QUnit[ loggingCallback ]( userCallback );\r\n\r\n        if ( global.console && global.console.warn ) {\r\n          global.console.warn(\r\n            \"QUnit.\" + loggingCallback + \" was replaced with a new value.\\n\" +\r\n            \"Please, check out the documentation on how to apply logging callbacks.\\n\" +\r\n            \"Reference: https://api.qunitjs.com/category/callbacks/\"\r\n          );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  ( function() {\r\n    if ( !defined.document ) {\r\n      return;\r\n    }\r\n\r\n    // `onErrorFnPrev` initialized at top of scope\r\n    // Preserve other handlers\r\n    var onErrorFnPrev = window.onerror;\r\n\r\n    // Cover uncaught exceptions\r\n    // Returning true will suppress the default browser handler,\r\n    // returning false will let it run.\r\n    window.onerror = function( error, filePath, linerNr ) {\r\n      var ret = false;\r\n      if ( onErrorFnPrev ) {\r\n        ret = onErrorFnPrev( error, filePath, linerNr );\r\n      }\r\n\r\n      // Treat return value as window.onerror itself does,\r\n      // Only do our handling if not suppressed.\r\n      if ( ret !== true ) {\r\n        if ( QUnit.config.current ) {\r\n          if ( QUnit.config.current.ignoreGlobalErrors ) {\r\n            return true;\r\n          }\r\n          QUnit.pushFailure( error, filePath + \":\" + linerNr );\r\n        } else {\r\n          QUnit.test( \"global failure\", extend( function() {\r\n            QUnit.pushFailure( error, filePath + \":\" + linerNr );\r\n          }, { validTest: true } ) );\r\n        }\r\n        return false;\r\n      }\r\n\r\n      return ret;\r\n    };\r\n  }() );\r\n\r\n// Figure out if we're running the tests from a server or not\r\n  QUnit.isLocal = !( defined.document && window.location.protocol !== \"file:\" );\r\n\r\n// Expose the current QUnit version\r\n  QUnit.version = \"1.23.1\";\r\n\r\n  extend( QUnit, {\r\n\r\n    // Call on start of module test to prepend name to all tests\r\n    module: function( name, testEnvironment, executeNow ) {\r\n      var module, moduleFns;\r\n      var currentModule = config.currentModule;\r\n\r\n      if ( arguments.length === 2 ) {\r\n        if ( objectType( testEnvironment ) === \"function\" ) {\r\n          executeNow = testEnvironment;\r\n          testEnvironment = undefined;\r\n        }\r\n      }\r\n\r\n      // DEPRECATED: handles setup/teardown functions,\r\n      // beforeEach and afterEach should be used instead\r\n      if ( testEnvironment && testEnvironment.setup ) {\r\n        testEnvironment.beforeEach = testEnvironment.setup;\r\n        delete testEnvironment.setup;\r\n      }\r\n      if ( testEnvironment && testEnvironment.teardown ) {\r\n        testEnvironment.afterEach = testEnvironment.teardown;\r\n        delete testEnvironment.teardown;\r\n      }\r\n\r\n      module = createModule();\r\n\r\n      moduleFns = {\r\n        beforeEach: setHook( module, \"beforeEach\" ),\r\n        afterEach: setHook( module, \"afterEach\" )\r\n      };\r\n\r\n      if ( objectType( executeNow ) === \"function\" ) {\r\n        config.moduleStack.push( module );\r\n        setCurrentModule( module );\r\n        executeNow.call( module.testEnvironment, moduleFns );\r\n        config.moduleStack.pop();\r\n        module = module.parentModule || currentModule;\r\n      }\r\n\r\n      setCurrentModule( module );\r\n\r\n      function createModule() {\r\n        var parentModule = config.moduleStack.length ?\r\n          config.moduleStack.slice( -1 )[ 0 ] : null;\r\n        var moduleName = parentModule !== null ?\r\n          [ parentModule.name, name ].join( \" > \" ) : name;\r\n        var module = {\r\n          name: moduleName,\r\n          parentModule: parentModule,\r\n          tests: [],\r\n          moduleId: generateHash( moduleName )\r\n        };\r\n\r\n        var env = {};\r\n        if ( parentModule ) {\r\n          extend( env, parentModule.testEnvironment );\r\n          delete env.beforeEach;\r\n          delete env.afterEach;\r\n        }\r\n        extend( env, testEnvironment );\r\n        module.testEnvironment = env;\r\n\r\n        config.modules.push( module );\r\n        return module;\r\n      }\r\n\r\n      function setCurrentModule( module ) {\r\n        config.currentModule = module;\r\n      }\r\n\r\n    },\r\n\r\n    // DEPRECATED: QUnit.asyncTest() will be removed in QUnit 2.0.\r\n    asyncTest: asyncTest,\r\n\r\n    test: test,\r\n\r\n    skip: skip,\r\n\r\n    only: only,\r\n\r\n    // DEPRECATED: The functionality of QUnit.start() will be altered in QUnit 2.0.\r\n    // In QUnit 2.0, invoking it will ONLY affect the `QUnit.config.autostart` blocking behavior.\r\n    start: function( count ) {\r\n      var globalStartAlreadyCalled = globalStartCalled;\r\n\r\n      if ( !config.current ) {\r\n        globalStartCalled = true;\r\n\r\n        if ( runStarted ) {\r\n          throw new Error( \"Called start() outside of a test context while already started\" );\r\n        } else if ( globalStartAlreadyCalled || count > 1 ) {\r\n          throw new Error( \"Called start() outside of a test context too many times\" );\r\n        } else if ( config.autostart ) {\r\n          throw new Error( \"Called start() outside of a test context when \" +\r\n            \"QUnit.config.autostart was true\" );\r\n        } else if ( !config.pageLoaded ) {\r\n\r\n          // The page isn't completely loaded yet, so bail out and let `QUnit.load` handle it\r\n          config.autostart = true;\r\n          return;\r\n        }\r\n      } else {\r\n\r\n        // If a test is running, adjust its semaphore\r\n        config.current.semaphore -= count || 1;\r\n\r\n        // If semaphore is non-numeric, throw error\r\n        if ( isNaN( config.current.semaphore ) ) {\r\n          config.current.semaphore = 0;\r\n\r\n          QUnit.pushFailure(\r\n            \"Called start() with a non-numeric decrement.\",\r\n            sourceFromStacktrace( 2 )\r\n          );\r\n          return;\r\n        }\r\n\r\n        // Don't start until equal number of stop-calls\r\n        if ( config.current.semaphore > 0 ) {\r\n          return;\r\n        }\r\n\r\n        // Throw an Error if start is called more often than stop\r\n        if ( config.current.semaphore < 0 ) {\r\n          config.current.semaphore = 0;\r\n\r\n          QUnit.pushFailure(\r\n            \"Called start() while already started (test's semaphore was 0 already)\",\r\n            sourceFromStacktrace( 2 )\r\n          );\r\n          return;\r\n        }\r\n      }\r\n\r\n      resumeProcessing();\r\n    },\r\n\r\n    // DEPRECATED: QUnit.stop() will be removed in QUnit 2.0.\r\n    stop: function( count ) {\r\n\r\n      // If there isn't a test running, don't allow QUnit.stop() to be called\r\n      if ( !config.current ) {\r\n        throw new Error( \"Called stop() outside of a test context\" );\r\n      }\r\n\r\n      // If a test is running, adjust its semaphore\r\n      config.current.semaphore += count || 1;\r\n\r\n      pauseProcessing();\r\n    },\r\n\r\n    config: config,\r\n\r\n    is: is,\r\n\r\n    objectType: objectType,\r\n\r\n    extend: extend,\r\n\r\n    load: function() {\r\n      config.pageLoaded = true;\r\n\r\n      // Initialize the configuration options\r\n      extend( config, {\r\n        stats: { all: 0, bad: 0 },\r\n        moduleStats: { all: 0, bad: 0 },\r\n        started: 0,\r\n        updateRate: 1000,\r\n        autostart: true,\r\n        filter: \"\"\r\n      }, true );\r\n\r\n      config.blocking = false;\r\n\r\n      if ( config.autostart ) {\r\n        resumeProcessing();\r\n      }\r\n    },\r\n\r\n    stack: function( offset ) {\r\n      offset = ( offset || 0 ) + 2;\r\n      return sourceFromStacktrace( offset );\r\n    }\r\n  } );\r\n\r\n  registerLoggingCallbacks( QUnit );\r\n\r\n  function begin() {\r\n    var i, l,\r\n      modulesLog = [];\r\n\r\n    // If the test run hasn't officially begun yet\r\n    if ( !config.started ) {\r\n\r\n      // Record the time of the test run's beginning\r\n      config.started = now();\r\n\r\n      verifyLoggingCallbacks();\r\n\r\n      // Delete the loose unnamed module if unused.\r\n      if ( config.modules[ 0 ].name === \"\" && config.modules[ 0 ].tests.length === 0 ) {\r\n        config.modules.shift();\r\n      }\r\n\r\n      // Avoid unnecessary information by not logging modules' test environments\r\n      for ( i = 0, l = config.modules.length; i < l; i++ ) {\r\n        modulesLog.push( {\r\n          name: config.modules[ i ].name,\r\n          tests: config.modules[ i ].tests\r\n        } );\r\n      }\r\n\r\n      // The test run is officially beginning now\r\n      runLoggingCallbacks( \"begin\", {\r\n        totalTests: Test.count,\r\n        modules: modulesLog\r\n      } );\r\n    }\r\n\r\n    config.blocking = false;\r\n    process( true );\r\n  }\r\n\r\n  function process( last ) {\r\n    function next() {\r\n      process( last );\r\n    }\r\n    var start = now();\r\n    config.depth = ( config.depth || 0 ) + 1;\r\n\r\n    while ( config.queue.length && !config.blocking ) {\r\n      if ( !defined.setTimeout || config.updateRate <= 0 ||\r\n        ( ( now() - start ) < config.updateRate ) ) {\r\n        if ( config.current ) {\r\n\r\n          // Reset async tracking for each phase of the Test lifecycle\r\n          config.current.usedAsync = false;\r\n        }\r\n        config.queue.shift()();\r\n      } else {\r\n        setTimeout( next, 13 );\r\n        break;\r\n      }\r\n    }\r\n    config.depth--;\r\n    if ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\r\n      done();\r\n    }\r\n  }\r\n\r\n  function pauseProcessing() {\r\n    config.blocking = true;\r\n\r\n    if ( config.testTimeout && defined.setTimeout ) {\r\n      clearTimeout( config.timeout );\r\n      config.timeout = setTimeout( function() {\r\n        if ( config.current ) {\r\n          config.current.semaphore = 0;\r\n          QUnit.pushFailure( \"Test timed out\", sourceFromStacktrace( 2 ) );\r\n        } else {\r\n          throw new Error( \"Test timed out\" );\r\n        }\r\n        resumeProcessing();\r\n      }, config.testTimeout );\r\n    }\r\n  }\r\n\r\n  function resumeProcessing() {\r\n    runStarted = true;\r\n\r\n    // A slight delay to allow this iteration of the event loop to finish (more assertions, etc.)\r\n    if ( defined.setTimeout ) {\r\n      setTimeout( function() {\r\n        if ( config.current && config.current.semaphore > 0 ) {\r\n          return;\r\n        }\r\n        if ( config.timeout ) {\r\n          clearTimeout( config.timeout );\r\n        }\r\n\r\n        begin();\r\n      }, 13 );\r\n    } else {\r\n      begin();\r\n    }\r\n  }\r\n\r\n  function done() {\r\n    var runtime, passed;\r\n\r\n    config.autorun = true;\r\n\r\n    // Log the last module results\r\n    if ( config.previousModule ) {\r\n      runLoggingCallbacks( \"moduleDone\", {\r\n        name: config.previousModule.name,\r\n        tests: config.previousModule.tests,\r\n        failed: config.moduleStats.bad,\r\n        passed: config.moduleStats.all - config.moduleStats.bad,\r\n        total: config.moduleStats.all,\r\n        runtime: now() - config.moduleStats.started\r\n      } );\r\n    }\r\n    delete config.previousModule;\r\n\r\n    runtime = now() - config.started;\r\n    passed = config.stats.all - config.stats.bad;\r\n\r\n    runLoggingCallbacks( \"done\", {\r\n      failed: config.stats.bad,\r\n      passed: passed,\r\n      total: config.stats.all,\r\n      runtime: runtime\r\n    } );\r\n  }\r\n\r\n  function setHook( module, hookName ) {\r\n    if ( module.testEnvironment === undefined ) {\r\n      module.testEnvironment = {};\r\n    }\r\n\r\n    return function( callback ) {\r\n      module.testEnvironment[ hookName ] = callback;\r\n    };\r\n  }\r\n\r\n  var focused = false;\r\n  var priorityCount = 0;\r\n  var unitSampler;\r\n\r\n  function Test( settings ) {\r\n    var i, l;\r\n\r\n    ++Test.count;\r\n\r\n    extend( this, settings );\r\n    this.assertions = [];\r\n    this.semaphore = 0;\r\n    this.usedAsync = false;\r\n    this.module = config.currentModule;\r\n    this.stack = sourceFromStacktrace( 3 );\r\n\r\n    // Register unique strings\r\n    for ( i = 0, l = this.module.tests; i < l.length; i++ ) {\r\n      if ( this.module.tests[ i ].name === this.testName ) {\r\n        this.testName += \" \";\r\n      }\r\n    }\r\n\r\n    this.testId = generateHash( this.module.name, this.testName );\r\n\r\n    this.module.tests.push( {\r\n      name: this.testName,\r\n      testId: this.testId\r\n    } );\r\n\r\n    if ( settings.skip ) {\r\n\r\n      // Skipped tests will fully ignore any sent callback\r\n      this.callback = function() {};\r\n      this.async = false;\r\n      this.expected = 0;\r\n    } else {\r\n      this.assert = new Assert( this );\r\n    }\r\n  }\r\n\r\n  Test.count = 0;\r\n\r\n  Test.prototype = {\r\n    before: function() {\r\n      if (\r\n\r\n        // Emit moduleStart when we're switching from one module to another\r\n        this.module !== config.previousModule ||\r\n\r\n        // They could be equal (both undefined) but if the previousModule property doesn't\r\n        // yet exist it means this is the first test in a suite that isn't wrapped in a\r\n        // module, in which case we'll just emit a moduleStart event for 'undefined'.\r\n        // Without this, reporters can get testStart before moduleStart  which is a problem.\r\n        !hasOwn.call( config, \"previousModule\" )\r\n      ) {\r\n        if ( hasOwn.call( config, \"previousModule\" ) ) {\r\n          runLoggingCallbacks( \"moduleDone\", {\r\n            name: config.previousModule.name,\r\n            tests: config.previousModule.tests,\r\n            failed: config.moduleStats.bad,\r\n            passed: config.moduleStats.all - config.moduleStats.bad,\r\n            total: config.moduleStats.all,\r\n            runtime: now() - config.moduleStats.started\r\n          } );\r\n        }\r\n        config.previousModule = this.module;\r\n        config.moduleStats = { all: 0, bad: 0, started: now() };\r\n        runLoggingCallbacks( \"moduleStart\", {\r\n          name: this.module.name,\r\n          tests: this.module.tests\r\n        } );\r\n      }\r\n\r\n      config.current = this;\r\n\r\n      if ( this.module.testEnvironment ) {\r\n        delete this.module.testEnvironment.beforeEach;\r\n        delete this.module.testEnvironment.afterEach;\r\n      }\r\n      this.testEnvironment = extend( {}, this.module.testEnvironment );\r\n\r\n      this.started = now();\r\n      runLoggingCallbacks( \"testStart\", {\r\n        name: this.testName,\r\n        module: this.module.name,\r\n        testId: this.testId\r\n      } );\r\n\r\n      if ( !config.pollution ) {\r\n        saveGlobal();\r\n      }\r\n    },\r\n\r\n    run: function() {\r\n      var promise;\r\n\r\n      config.current = this;\r\n\r\n      if ( this.async ) {\r\n        QUnit.stop();\r\n      }\r\n\r\n      this.callbackStarted = now();\r\n\r\n      if ( config.notrycatch ) {\r\n        runTest( this );\r\n        return;\r\n      }\r\n\r\n      try {\r\n        runTest( this );\r\n      } catch ( e ) {\r\n        this.pushFailure( \"Died on test #\" + ( this.assertions.length + 1 ) + \" \" +\r\n          this.stack + \": \" + ( e.message || e ), extractStacktrace( e, 0 ) );\r\n\r\n        // Else next test will carry the responsibility\r\n        saveGlobal();\r\n\r\n        // Restart the tests if they're blocking\r\n        if ( config.blocking ) {\r\n          QUnit.start();\r\n        }\r\n      }\r\n\r\n      function runTest( test ) {\r\n        promise = test.callback.call( test.testEnvironment, test.assert );\r\n        test.resolvePromise( promise );\r\n      }\r\n    },\r\n\r\n    after: function() {\r\n      checkPollution();\r\n    },\r\n\r\n    queueHook: function( hook, hookName ) {\r\n      var promise,\r\n        test = this;\r\n      return function runHook() {\r\n        config.current = test;\r\n        if ( config.notrycatch ) {\r\n          callHook();\r\n          return;\r\n        }\r\n        try {\r\n          callHook();\r\n        } catch ( error ) {\r\n          test.pushFailure( hookName + \" failed on \" + test.testName + \": \" +\r\n            ( error.message || error ), extractStacktrace( error, 0 ) );\r\n        }\r\n\r\n        function callHook() {\r\n          promise = hook.call( test.testEnvironment, test.assert );\r\n          test.resolvePromise( promise, hookName );\r\n        }\r\n      };\r\n    },\r\n\r\n    // Currently only used for module level hooks, can be used to add global level ones\r\n    hooks: function( handler ) {\r\n      var hooks = [];\r\n\r\n      function processHooks( test, module ) {\r\n        if ( module.parentModule ) {\r\n          processHooks( test, module.parentModule );\r\n        }\r\n        if ( module.testEnvironment &&\r\n          QUnit.objectType( module.testEnvironment[ handler ] ) === \"function\" ) {\r\n          hooks.push( test.queueHook( module.testEnvironment[ handler ], handler ) );\r\n        }\r\n      }\r\n\r\n      // Hooks are ignored on skipped tests\r\n      if ( !this.skip ) {\r\n        processHooks( this, this.module );\r\n      }\r\n      return hooks;\r\n    },\r\n\r\n    finish: function() {\r\n      config.current = this;\r\n      if ( config.requireExpects && this.expected === null ) {\r\n        this.pushFailure( \"Expected number of assertions to be defined, but expect() was \" +\r\n          \"not called.\", this.stack );\r\n      } else if ( this.expected !== null && this.expected !== this.assertions.length ) {\r\n        this.pushFailure( \"Expected \" + this.expected + \" assertions, but \" +\r\n          this.assertions.length + \" were run\", this.stack );\r\n      } else if ( this.expected === null && !this.assertions.length ) {\r\n        this.pushFailure( \"Expected at least one assertion, but none were run - call \" +\r\n          \"expect(0) to accept zero assertions.\", this.stack );\r\n      }\r\n\r\n      var i,\r\n        bad = 0;\r\n\r\n      this.runtime = now() - this.started;\r\n      config.stats.all += this.assertions.length;\r\n      config.moduleStats.all += this.assertions.length;\r\n\r\n      for ( i = 0; i < this.assertions.length; i++ ) {\r\n        if ( !this.assertions[ i ].result ) {\r\n          bad++;\r\n          config.stats.bad++;\r\n          config.moduleStats.bad++;\r\n        }\r\n      }\r\n\r\n      runLoggingCallbacks( \"testDone\", {\r\n        name: this.testName,\r\n        module: this.module.name,\r\n        skipped: !!this.skip,\r\n        failed: bad,\r\n        passed: this.assertions.length - bad,\r\n        total: this.assertions.length,\r\n        runtime: this.runtime,\r\n\r\n        // HTML Reporter use\r\n        assertions: this.assertions,\r\n        testId: this.testId,\r\n\r\n        // Source of Test\r\n        source: this.stack,\r\n\r\n        // DEPRECATED: this property will be removed in 2.0.0, use runtime instead\r\n        duration: this.runtime\r\n      } );\r\n\r\n      // QUnit.reset() is deprecated and will be replaced for a new\r\n      // fixture reset function on QUnit 2.0/2.1.\r\n      // It's still called here for backwards compatibility handling\r\n      QUnit.reset();\r\n\r\n      config.current = undefined;\r\n    },\r\n\r\n    queue: function() {\r\n      var priority,\r\n        test = this;\r\n\r\n      if ( !this.valid() ) {\r\n        return;\r\n      }\r\n\r\n      function run() {\r\n\r\n        // Each of these can by async\r\n        synchronize( [\r\n          function() {\r\n            test.before();\r\n          },\r\n\r\n          test.hooks( \"beforeEach\" ),\r\n          function() {\r\n            test.run();\r\n          },\r\n\r\n          test.hooks( \"afterEach\" ).reverse(),\r\n\r\n          function() {\r\n            test.after();\r\n          },\r\n          function() {\r\n            test.finish();\r\n          }\r\n        ] );\r\n      }\r\n\r\n      // Prioritize previously failed tests, detected from sessionStorage\r\n      priority = QUnit.config.reorder && defined.sessionStorage &&\r\n        +sessionStorage.getItem( \"qunit-test-\" + this.module.name + \"-\" + this.testName );\r\n\r\n      return synchronize( run, priority, config.seed );\r\n    },\r\n\r\n    pushResult: function( resultInfo ) {\r\n\r\n      // Destructure of resultInfo = { result, actual, expected, message, negative }\r\n      var source,\r\n        details = {\r\n          module: this.module.name,\r\n          name: this.testName,\r\n          result: resultInfo.result,\r\n          message: resultInfo.message,\r\n          actual: resultInfo.actual,\r\n          expected: resultInfo.expected,\r\n          testId: this.testId,\r\n          negative: resultInfo.negative || false,\r\n          runtime: now() - this.started\r\n        };\r\n\r\n      if ( !resultInfo.result ) {\r\n        source = sourceFromStacktrace();\r\n\r\n        if ( source ) {\r\n          details.source = source;\r\n        }\r\n      }\r\n\r\n      runLoggingCallbacks( \"log\", details );\r\n\r\n      this.assertions.push( {\r\n        result: !!resultInfo.result,\r\n        message: resultInfo.message\r\n      } );\r\n    },\r\n\r\n    pushFailure: function( message, source, actual ) {\r\n      if ( !( this instanceof Test ) ) {\r\n        throw new Error( \"pushFailure() assertion outside test context, was \" +\r\n          sourceFromStacktrace( 2 ) );\r\n      }\r\n\r\n      var details = {\r\n        module: this.module.name,\r\n        name: this.testName,\r\n        result: false,\r\n        message: message || \"error\",\r\n        actual: actual || null,\r\n        testId: this.testId,\r\n        runtime: now() - this.started\r\n      };\r\n\r\n      if ( source ) {\r\n        details.source = source;\r\n      }\r\n\r\n      runLoggingCallbacks( \"log\", details );\r\n\r\n      this.assertions.push( {\r\n        result: false,\r\n        message: message\r\n      } );\r\n    },\r\n\r\n    resolvePromise: function( promise, phase ) {\r\n      var then, message,\r\n        test = this;\r\n      if ( promise != null ) {\r\n        then = promise.then;\r\n        if ( QUnit.objectType( then ) === \"function\" ) {\r\n          QUnit.stop();\r\n          then.call(\r\n            promise,\r\n            function() { QUnit.start(); },\r\n            function( error ) {\r\n              message = \"Promise rejected \" +\r\n                ( !phase ? \"during\" : phase.replace( /Each$/, \"\" ) ) +\r\n                \" \" + test.testName + \": \" + ( error.message || error );\r\n              test.pushFailure( message, extractStacktrace( error, 0 ) );\r\n\r\n              // Else next test will carry the responsibility\r\n              saveGlobal();\r\n\r\n              // Unblock\r\n              QUnit.start();\r\n            }\r\n          );\r\n        }\r\n      }\r\n    },\r\n\r\n    valid: function() {\r\n      var filter = config.filter,\r\n        regexFilter = /^(!?)\\/([\\w\\W]*)\\/(i?$)/.exec( filter ),\r\n        module = config.module && config.module.toLowerCase(),\r\n        fullName = ( this.module.name + \": \" + this.testName );\r\n\r\n      function moduleChainNameMatch( testModule ) {\r\n        var testModuleName = testModule.name ? testModule.name.toLowerCase() : null;\r\n        if ( testModuleName === module ) {\r\n          return true;\r\n        } else if ( testModule.parentModule ) {\r\n          return moduleChainNameMatch( testModule.parentModule );\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      function moduleChainIdMatch( testModule ) {\r\n        return inArray( testModule.moduleId, config.moduleId ) > -1 ||\r\n          testModule.parentModule && moduleChainIdMatch( testModule.parentModule );\r\n      }\r\n\r\n      // Internally-generated tests are always valid\r\n      if ( this.callback && this.callback.validTest ) {\r\n        return true;\r\n      }\r\n\r\n      if ( config.moduleId && config.moduleId.length > 0 &&\r\n        !moduleChainIdMatch( this.module ) ) {\r\n\r\n        return false;\r\n      }\r\n\r\n      if ( config.testId && config.testId.length > 0 &&\r\n        inArray( this.testId, config.testId ) < 0 ) {\r\n\r\n        return false;\r\n      }\r\n\r\n      if ( module && !moduleChainNameMatch( this.module ) ) {\r\n        return false;\r\n      }\r\n\r\n      if ( !filter ) {\r\n        return true;\r\n      }\r\n\r\n      return regexFilter ?\r\n        this.regexFilter( !!regexFilter[ 1 ], regexFilter[ 2 ], regexFilter[ 3 ], fullName ) :\r\n        this.stringFilter( filter, fullName );\r\n    },\r\n\r\n    regexFilter: function( exclude, pattern, flags, fullName ) {\r\n      var regex = new RegExp( pattern, flags );\r\n      var match = regex.test( fullName );\r\n\r\n      return match !== exclude;\r\n    },\r\n\r\n    stringFilter: function( filter, fullName ) {\r\n      filter = filter.toLowerCase();\r\n      fullName = fullName.toLowerCase();\r\n\r\n      var include = filter.charAt( 0 ) !== \"!\";\r\n      if ( !include ) {\r\n        filter = filter.slice( 1 );\r\n      }\r\n\r\n      // If the filter matches, we need to honour include\r\n      if ( fullName.indexOf( filter ) !== -1 ) {\r\n        return include;\r\n      }\r\n\r\n      // Otherwise, do the opposite\r\n      return !include;\r\n    }\r\n  };\r\n\r\n// Resets the test setup. Useful for tests that modify the DOM.\r\n  /*\r\nDEPRECATED: Use multiple tests instead of resetting inside a test.\r\nUse testStart or testDone for custom cleanup.\r\nThis method will throw an error in 2.0, and will be removed in 2.1\r\n*/\r\n  QUnit.reset = function() {\r\n\r\n    // Return on non-browser environments\r\n    // This is necessary to not break on node tests\r\n    if ( !defined.document ) {\r\n      return;\r\n    }\r\n\r\n    var fixture = defined.document && document.getElementById &&\r\n      document.getElementById( \"qunit-fixture\" );\r\n\r\n    if ( fixture ) {\r\n      fixture.innerHTML = config.fixture;\r\n    }\r\n  };\r\n\r\n  QUnit.pushFailure = function() {\r\n    if ( !QUnit.config.current ) {\r\n      throw new Error( \"pushFailure() assertion outside test context, in \" +\r\n        sourceFromStacktrace( 2 ) );\r\n    }\r\n\r\n    // Gets current test obj\r\n    var currentTest = QUnit.config.current;\r\n\r\n    return currentTest.pushFailure.apply( currentTest, arguments );\r\n  };\r\n\r\n// Based on Java's String.hashCode, a simple but not\r\n// rigorously collision resistant hashing function\r\n  function generateHash( module, testName ) {\r\n    var hex,\r\n      i = 0,\r\n      hash = 0,\r\n      str = module + \"\\x1C\" + testName,\r\n      len = str.length;\r\n\r\n    for ( ; i < len; i++ ) {\r\n      hash  = ( ( hash << 5 ) - hash ) + str.charCodeAt( i );\r\n      hash |= 0;\r\n    }\r\n\r\n    // Convert the possibly negative integer hash code into an 8 character hex string, which isn't\r\n    // strictly necessary but increases user understanding that the id is a SHA-like hash\r\n    hex = ( 0x100000000 + hash ).toString( 16 );\r\n    if ( hex.length < 8 ) {\r\n      hex = \"0000000\" + hex;\r\n    }\r\n\r\n    return hex.slice( -8 );\r\n  }\r\n\r\n  function synchronize( callback, priority, seed ) {\r\n    var last = !priority,\r\n      index;\r\n\r\n    if ( QUnit.objectType( callback ) === \"array\" ) {\r\n      while ( callback.length ) {\r\n        synchronize( callback.shift() );\r\n      }\r\n      return;\r\n    }\r\n\r\n    if ( priority ) {\r\n      config.queue.splice( priorityCount++, 0, callback );\r\n    } else if ( seed ) {\r\n      if ( !unitSampler ) {\r\n        unitSampler = unitSamplerGenerator( seed );\r\n      }\r\n\r\n      // Insert into a random position after all priority items\r\n      index = Math.floor( unitSampler() * ( config.queue.length - priorityCount + 1 ) );\r\n      config.queue.splice( priorityCount + index, 0, callback );\r\n    } else {\r\n      config.queue.push( callback );\r\n    }\r\n\r\n    if ( config.autorun && !config.blocking ) {\r\n      process( last );\r\n    }\r\n  }\r\n\r\n  function unitSamplerGenerator( seed ) {\r\n\r\n    // 32-bit xorshift, requires only a nonzero seed\r\n    // http://excamera.com/sphinx/article-xorshift.html\r\n    var sample = parseInt( generateHash( seed ), 16 ) || -1;\r\n    return function() {\r\n      sample ^= sample << 13;\r\n      sample ^= sample >>> 17;\r\n      sample ^= sample << 5;\r\n\r\n      // ECMAScript has no unsigned number type\r\n      if ( sample < 0 ) {\r\n        sample += 0x100000000;\r\n      }\r\n\r\n      return sample / 0x100000000;\r\n    };\r\n  }\r\n\r\n  function saveGlobal() {\r\n    config.pollution = [];\r\n\r\n    if ( config.noglobals ) {\r\n      for ( var key in global ) {\r\n        if ( hasOwn.call( global, key ) ) {\r\n\r\n          // In Opera sometimes DOM element ids show up here, ignore them\r\n          if ( /^qunit-test-output/.test( key ) ) {\r\n            continue;\r\n          }\r\n          config.pollution.push( key );\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  function checkPollution() {\r\n    var newGlobals,\r\n      deletedGlobals,\r\n      old = config.pollution;\r\n\r\n    saveGlobal();\r\n\r\n    newGlobals = diff( config.pollution, old );\r\n    if ( newGlobals.length > 0 ) {\r\n      QUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join( \", \" ) );\r\n    }\r\n\r\n    deletedGlobals = diff( old, config.pollution );\r\n    if ( deletedGlobals.length > 0 ) {\r\n      QUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join( \", \" ) );\r\n    }\r\n  }\r\n\r\n// Will be exposed as QUnit.asyncTest\r\n  function asyncTest( testName, expected, callback ) {\r\n    if ( arguments.length === 2 ) {\r\n      callback = expected;\r\n      expected = null;\r\n    }\r\n\r\n    QUnit.test( testName, expected, callback, true );\r\n  }\r\n\r\n// Will be exposed as QUnit.test\r\n  function test( testName, expected, callback, async ) {\r\n    if ( focused )  { return; }\r\n\r\n    var newTest;\r\n\r\n    if ( arguments.length === 2 ) {\r\n      callback = expected;\r\n      expected = null;\r\n    }\r\n\r\n    newTest = new Test( {\r\n      testName: testName,\r\n      expected: expected,\r\n      async: async,\r\n      callback: callback\r\n    } );\r\n\r\n    newTest.queue();\r\n  }\r\n\r\n// Will be exposed as QUnit.skip\r\n  function skip( testName ) {\r\n    if ( focused )  { return; }\r\n\r\n    var test = new Test( {\r\n      testName: testName,\r\n      skip: true\r\n    } );\r\n\r\n    test.queue();\r\n  }\r\n\r\n// Will be exposed as QUnit.only\r\n  function only( testName, expected, callback, async ) {\r\n    var newTest;\r\n\r\n    if ( focused )  { return; }\r\n\r\n    QUnit.config.queue.length = 0;\r\n    focused = true;\r\n\r\n    if ( arguments.length === 2 ) {\r\n      callback = expected;\r\n      expected = null;\r\n    }\r\n\r\n    newTest = new Test( {\r\n      testName: testName,\r\n      expected: expected,\r\n      async: async,\r\n      callback: callback\r\n    } );\r\n\r\n    newTest.queue();\r\n  }\r\n\r\n  function Assert( testContext ) {\r\n    this.test = testContext;\r\n  }\r\n\r\n// Assert helpers\r\n  QUnit.assert = Assert.prototype = {\r\n\r\n    // Specify the number of expected assertions to guarantee that failed test\r\n    // (no assertions are run at all) don't slip through.\r\n    expect: function( asserts ) {\r\n      if ( arguments.length === 1 ) {\r\n        this.test.expected = asserts;\r\n      } else {\r\n        return this.test.expected;\r\n      }\r\n    },\r\n\r\n    // Increment this Test's semaphore counter, then return a function that\r\n    // decrements that counter a maximum of once.\r\n    async: function( count ) {\r\n      var test = this.test,\r\n        popped = false,\r\n        acceptCallCount = count;\r\n\r\n      if ( typeof acceptCallCount === \"undefined\" ) {\r\n        acceptCallCount = 1;\r\n      }\r\n\r\n      test.semaphore += 1;\r\n      test.usedAsync = true;\r\n      pauseProcessing();\r\n\r\n      return function done() {\r\n\r\n        if ( popped ) {\r\n          test.pushFailure( \"Too many calls to the `assert.async` callback\",\r\n            sourceFromStacktrace( 2 ) );\r\n          return;\r\n        }\r\n        acceptCallCount -= 1;\r\n        if ( acceptCallCount > 0 ) {\r\n          return;\r\n        }\r\n\r\n        test.semaphore -= 1;\r\n        popped = true;\r\n        resumeProcessing();\r\n      };\r\n    },\r\n\r\n    // Exports test.push() to the user API\r\n    // Alias of pushResult.\r\n    push: function( result, actual, expected, message, negative ) {\r\n      var currentAssert = this instanceof Assert ? this : QUnit.config.current.assert;\r\n      return currentAssert.pushResult( {\r\n        result: result,\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message,\r\n        negative: negative\r\n      } );\r\n    },\r\n\r\n    pushResult: function( resultInfo ) {\r\n\r\n      // Destructure of resultInfo = { result, actual, expected, message, negative }\r\n      var assert = this,\r\n        currentTest = ( assert instanceof Assert && assert.test ) || QUnit.config.current;\r\n\r\n      // Backwards compatibility fix.\r\n      // Allows the direct use of global exported assertions and QUnit.assert.*\r\n      // Although, it's use is not recommended as it can leak assertions\r\n      // to other tests from async tests, because we only get a reference to the current test,\r\n      // not exactly the test where assertion were intended to be called.\r\n      if ( !currentTest ) {\r\n        throw new Error( \"assertion outside test context, in \" + sourceFromStacktrace( 2 ) );\r\n      }\r\n\r\n      if ( currentTest.usedAsync === true && currentTest.semaphore === 0 ) {\r\n        currentTest.pushFailure( \"Assertion after the final `assert.async` was resolved\",\r\n          sourceFromStacktrace( 2 ) );\r\n\r\n        // Allow this assertion to continue running anyway...\r\n      }\r\n\r\n      if ( !( assert instanceof Assert ) ) {\r\n        assert = currentTest.assert;\r\n      }\r\n\r\n      return assert.test.pushResult( resultInfo );\r\n    },\r\n\r\n    ok: function( result, message ) {\r\n      message = message || ( result ? \"okay\" : \"failed, expected argument to be truthy, was: \" +\r\n        QUnit.dump.parse( result ) );\r\n      this.pushResult( {\r\n        result: !!result,\r\n        actual: result,\r\n        expected: true,\r\n        message: message\r\n      } );\r\n    },\r\n\r\n    notOk: function( result, message ) {\r\n      message = message || ( !result ? \"okay\" : \"failed, expected argument to be falsy, was: \" +\r\n        QUnit.dump.parse( result ) );\r\n      this.pushResult( {\r\n        result: !result,\r\n        actual: result,\r\n        expected: false,\r\n        message: message\r\n      } );\r\n    },\r\n\r\n    equal: function( actual, expected, message ) {\r\n      /*jshint eqeqeq:false */\r\n      this.pushResult( {\r\n        result: expected == actual,\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message\r\n      } );\r\n    },\r\n\r\n    notEqual: function( actual, expected, message ) {\r\n      /*jshint eqeqeq:false */\r\n      this.pushResult( {\r\n        result: expected != actual,\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message,\r\n        negative: true\r\n      } );\r\n    },\r\n\r\n    propEqual: function( actual, expected, message ) {\r\n      actual = objectValues( actual );\r\n      expected = objectValues( expected );\r\n      this.pushResult( {\r\n        result: QUnit.equiv( actual, expected ),\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message\r\n      } );\r\n    },\r\n\r\n    notPropEqual: function( actual, expected, message ) {\r\n      actual = objectValues( actual );\r\n      expected = objectValues( expected );\r\n      this.pushResult( {\r\n        result: !QUnit.equiv( actual, expected ),\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message,\r\n        negative: true\r\n      } );\r\n    },\r\n\r\n    deepEqual: function( actual, expected, message ) {\r\n      this.pushResult( {\r\n        result: QUnit.equiv( actual, expected ),\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message\r\n      } );\r\n    },\r\n\r\n    notDeepEqual: function( actual, expected, message ) {\r\n      this.pushResult( {\r\n        result: !QUnit.equiv( actual, expected ),\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message,\r\n        negative: true\r\n      } );\r\n    },\r\n\r\n    strictEqual: function( actual, expected, message ) {\r\n      this.pushResult( {\r\n        result: expected === actual,\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message\r\n      } );\r\n    },\r\n\r\n    notStrictEqual: function( actual, expected, message ) {\r\n      this.pushResult( {\r\n        result: expected !== actual,\r\n        actual: actual,\r\n        expected: expected,\r\n        message: message,\r\n        negative: true\r\n      } );\r\n    },\r\n\r\n    \"throws\": function( block, expected, message ) {\r\n      var actual, expectedType,\r\n        expectedOutput = expected,\r\n        ok = false,\r\n        currentTest = ( this instanceof Assert && this.test ) || QUnit.config.current;\r\n\r\n      // 'expected' is optional unless doing string comparison\r\n      if ( message == null && typeof expected === \"string\" ) {\r\n        message = expected;\r\n        expected = null;\r\n      }\r\n\r\n      currentTest.ignoreGlobalErrors = true;\r\n      try {\r\n        block.call( currentTest.testEnvironment );\r\n      } catch ( e ) {\r\n        actual = e;\r\n      }\r\n      currentTest.ignoreGlobalErrors = false;\r\n\r\n      if ( actual ) {\r\n        expectedType = QUnit.objectType( expected );\r\n\r\n        // We don't want to validate thrown error\r\n        if ( !expected ) {\r\n          ok = true;\r\n          expectedOutput = null;\r\n\r\n          // Expected is a regexp\r\n        } else if ( expectedType === \"regexp\" ) {\r\n          ok = expected.test( errorString( actual ) );\r\n\r\n          // Expected is a string\r\n        } else if ( expectedType === \"string\" ) {\r\n          ok = expected === errorString( actual );\r\n\r\n          // Expected is a constructor, maybe an Error constructor\r\n        } else if ( expectedType === \"function\" && actual instanceof expected ) {\r\n          ok = true;\r\n\r\n          // Expected is an Error object\r\n        } else if ( expectedType === \"object\" ) {\r\n          ok = actual instanceof expected.constructor &&\r\n            actual.name === expected.name &&\r\n            actual.message === expected.message;\r\n\r\n          // Expected is a validation function which returns true if validation passed\r\n        } else if ( expectedType === \"function\" && expected.call( {}, actual ) === true ) {\r\n          expectedOutput = null;\r\n          ok = true;\r\n        }\r\n      }\r\n\r\n      currentTest.assert.pushResult( {\r\n        result: ok,\r\n        actual: actual,\r\n        expected: expectedOutput,\r\n        message: message\r\n      } );\r\n    }\r\n  };\r\n\r\n// Provide an alternative to assert.throws(), for environments that consider throws a reserved word\r\n// Known to us are: Closure Compiler, Narwhal\r\n  ( function() {\r\n    /*jshint sub:true */\r\n    Assert.prototype.raises = Assert.prototype [ \"throws\" ]; //jscs:ignore requireDotNotation\r\n  }() );\r\n\r\n  function errorString( error ) {\r\n    var name, message,\r\n      resultErrorString = error.toString();\r\n    if ( resultErrorString.substring( 0, 7 ) === \"[object\" ) {\r\n      name = error.name ? error.name.toString() : \"Error\";\r\n      message = error.message ? error.message.toString() : \"\";\r\n      if ( name && message ) {\r\n        return name + \": \" + message;\r\n      } else if ( name ) {\r\n        return name;\r\n      } else if ( message ) {\r\n        return message;\r\n      } else {\r\n        return \"Error\";\r\n      }\r\n    } else {\r\n      return resultErrorString;\r\n    }\r\n  }\r\n\r\n// Test for equality any JavaScript type.\r\n// Author: Philippe Rathé <prathe@gmail.com>\r\n  QUnit.equiv = ( function() {\r\n\r\n    // Stack to decide between skip/abort functions\r\n    var callers = [];\r\n\r\n    // Stack to avoiding loops from circular referencing\r\n    var parents = [];\r\n    var parentsB = [];\r\n\r\n    var getProto = Object.getPrototypeOf || function( obj ) {\r\n\r\n      /*jshint proto: true */\r\n      return obj.__proto__;\r\n    };\r\n\r\n    function useStrictEquality( b, a ) {\r\n\r\n      // To catch short annotation VS 'new' annotation of a declaration. e.g.:\r\n      // `var i = 1;`\r\n      // `var j = new Number(1);`\r\n      if ( typeof a === \"object\" ) {\r\n        a = a.valueOf();\r\n      }\r\n      if ( typeof b === \"object\" ) {\r\n        b = b.valueOf();\r\n      }\r\n\r\n      return a === b;\r\n    }\r\n\r\n    function compareConstructors( a, b ) {\r\n      var protoA = getProto( a );\r\n      var protoB = getProto( b );\r\n\r\n      // Comparing constructors is more strict than using `instanceof`\r\n      if ( a.constructor === b.constructor ) {\r\n        return true;\r\n      }\r\n\r\n      // Ref #851\r\n      // If the obj prototype descends from a null constructor, treat it\r\n      // as a null prototype.\r\n      if ( protoA && protoA.constructor === null ) {\r\n        protoA = null;\r\n      }\r\n      if ( protoB && protoB.constructor === null ) {\r\n        protoB = null;\r\n      }\r\n\r\n      // Allow objects with no prototype to be equivalent to\r\n      // objects with Object as their constructor.\r\n      if ( ( protoA === null && protoB === Object.prototype ) ||\r\n        ( protoB === null && protoA === Object.prototype ) ) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    }\r\n\r\n    function getRegExpFlags( regexp ) {\r\n      return \"flags\" in regexp ? regexp.flags : regexp.toString().match( /[gimuy]*$/ )[ 0 ];\r\n    }\r\n\r\n    var callbacks = {\r\n      \"string\": useStrictEquality,\r\n      \"boolean\": useStrictEquality,\r\n      \"number\": useStrictEquality,\r\n      \"null\": useStrictEquality,\r\n      \"undefined\": useStrictEquality,\r\n      \"symbol\": useStrictEquality,\r\n      \"date\": useStrictEquality,\r\n\r\n      \"nan\": function() {\r\n        return true;\r\n      },\r\n\r\n      \"regexp\": function( b, a ) {\r\n        return a.source === b.source &&\r\n\r\n          // Include flags in the comparison\r\n          getRegExpFlags( a ) === getRegExpFlags( b );\r\n      },\r\n\r\n      // - skip when the property is a method of an instance (OOP)\r\n      // - abort otherwise,\r\n      // initial === would have catch identical references anyway\r\n      \"function\": function() {\r\n        var caller = callers[ callers.length - 1 ];\r\n        return caller !== Object && typeof caller !== \"undefined\";\r\n      },\r\n\r\n      \"array\": function( b, a ) {\r\n        var i, j, len, loop, aCircular, bCircular;\r\n\r\n        len = a.length;\r\n        if ( len !== b.length ) {\r\n\r\n          // Safe and faster\r\n          return false;\r\n        }\r\n\r\n        // Track reference to avoid circular references\r\n        parents.push( a );\r\n        parentsB.push( b );\r\n        for ( i = 0; i < len; i++ ) {\r\n          loop = false;\r\n          for ( j = 0; j < parents.length; j++ ) {\r\n            aCircular = parents[ j ] === a[ i ];\r\n            bCircular = parentsB[ j ] === b[ i ];\r\n            if ( aCircular || bCircular ) {\r\n              if ( a[ i ] === b[ i ] || aCircular && bCircular ) {\r\n                loop = true;\r\n              } else {\r\n                parents.pop();\r\n                parentsB.pop();\r\n                return false;\r\n              }\r\n            }\r\n          }\r\n          if ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\r\n            parents.pop();\r\n            parentsB.pop();\r\n            return false;\r\n          }\r\n        }\r\n        parents.pop();\r\n        parentsB.pop();\r\n        return true;\r\n      },\r\n\r\n      \"set\": function( b, a ) {\r\n        var innerEq,\r\n          outerEq = true;\r\n\r\n        if ( a.size !== b.size ) {\r\n          return false;\r\n        }\r\n\r\n        a.forEach( function( aVal ) {\r\n          innerEq = false;\r\n\r\n          b.forEach( function( bVal ) {\r\n            if ( innerEquiv( bVal, aVal ) ) {\r\n              innerEq = true;\r\n            }\r\n          } );\r\n\r\n          if ( !innerEq ) {\r\n            outerEq = false;\r\n          }\r\n        } );\r\n\r\n        return outerEq;\r\n      },\r\n\r\n      \"map\": function( b, a ) {\r\n        var innerEq,\r\n          outerEq = true;\r\n\r\n        if ( a.size !== b.size ) {\r\n          return false;\r\n        }\r\n\r\n        a.forEach( function( aVal, aKey ) {\r\n          innerEq = false;\r\n\r\n          b.forEach( function( bVal, bKey ) {\r\n            if ( innerEquiv( [ bVal, bKey ], [ aVal, aKey ] ) ) {\r\n              innerEq = true;\r\n            }\r\n          } );\r\n\r\n          if ( !innerEq ) {\r\n            outerEq = false;\r\n          }\r\n        } );\r\n\r\n        return outerEq;\r\n      },\r\n\r\n      \"object\": function( b, a ) {\r\n        var i, j, loop, aCircular, bCircular;\r\n\r\n        // Default to true\r\n        var eq = true;\r\n        var aProperties = [];\r\n        var bProperties = [];\r\n\r\n        if ( compareConstructors( a, b ) === false ) {\r\n          return false;\r\n        }\r\n\r\n        // Stack constructor before traversing properties\r\n        callers.push( a.constructor );\r\n\r\n        // Track reference to avoid circular references\r\n        parents.push( a );\r\n        parentsB.push( b );\r\n\r\n        // Be strict: don't ensure hasOwnProperty and go deep\r\n        for ( i in a ) {\r\n          loop = false;\r\n          for ( j = 0; j < parents.length; j++ ) {\r\n            aCircular = parents[ j ] === a[ i ];\r\n            bCircular = parentsB[ j ] === b[ i ];\r\n            if ( aCircular || bCircular ) {\r\n              if ( a[ i ] === b[ i ] || aCircular && bCircular ) {\r\n                loop = true;\r\n              } else {\r\n                eq = false;\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          aProperties.push( i );\r\n          if ( !loop && !innerEquiv( a[ i ], b[ i ] ) ) {\r\n            eq = false;\r\n            break;\r\n          }\r\n        }\r\n\r\n        parents.pop();\r\n        parentsB.pop();\r\n\r\n        // Unstack, we are done\r\n        callers.pop();\r\n\r\n        for ( i in b ) {\r\n\r\n          // Collect b's properties\r\n          bProperties.push( i );\r\n        }\r\n\r\n        // Ensures identical properties name\r\n        return eq && innerEquiv( aProperties.sort(), bProperties.sort() );\r\n      }\r\n    };\r\n\r\n    function typeEquiv( a, b ) {\r\n      var type = QUnit.objectType( a );\r\n      return QUnit.objectType( b ) === type && callbacks[ type ]( b, a );\r\n    }\r\n\r\n    // The real equiv function\r\n    function innerEquiv( a, b ) {\r\n\r\n      // We're done when there's nothing more to compare\r\n      if ( arguments.length < 2 ) {\r\n        return true;\r\n      }\r\n\r\n      // Require type-specific equality\r\n      return ( a === b || typeEquiv( a, b ) ) &&\r\n\r\n        // ...across all consecutive argument pairs\r\n        ( arguments.length === 2 || innerEquiv.apply( this, [].slice.call( arguments, 1 ) ) );\r\n    }\r\n\r\n    return innerEquiv;\r\n  }() );\r\n\r\n// Based on jsDump by Ariel Flesler\r\n// http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html\r\n  QUnit.dump = ( function() {\r\n    function quote( str ) {\r\n      return \"\\\"\" + str.toString().replace( /\\\\/g, \"\\\\\\\\\" ).replace( /\"/g, \"\\\\\\\"\" ) + \"\\\"\";\r\n    }\r\n    function literal( o ) {\r\n      return o + \"\";\r\n    }\r\n    function join( pre, arr, post ) {\r\n      var s = dump.separator(),\r\n        base = dump.indent(),\r\n        inner = dump.indent( 1 );\r\n      if ( arr.join ) {\r\n        arr = arr.join( \",\" + s + inner );\r\n      }\r\n      if ( !arr ) {\r\n        return pre + post;\r\n      }\r\n      return [ pre, inner + arr, base + post ].join( s );\r\n    }\r\n    function array( arr, stack ) {\r\n      var i = arr.length,\r\n        ret = new Array( i );\r\n\r\n      if ( dump.maxDepth && dump.depth > dump.maxDepth ) {\r\n        return \"[object Array]\";\r\n      }\r\n\r\n      this.up();\r\n      while ( i-- ) {\r\n        ret[ i ] = this.parse( arr[ i ], undefined, stack );\r\n      }\r\n      this.down();\r\n      return join( \"[\", ret, \"]\" );\r\n    }\r\n\r\n    var reName = /^function (\\w+)/,\r\n      dump = {\r\n\r\n        // The objType is used mostly internally, you can fix a (custom) type in advance\r\n        parse: function( obj, objType, stack ) {\r\n          stack = stack || [];\r\n          var res, parser, parserType,\r\n            inStack = inArray( obj, stack );\r\n\r\n          if ( inStack !== -1 ) {\r\n            return \"recursion(\" + ( inStack - stack.length ) + \")\";\r\n          }\r\n\r\n          objType = objType || this.typeOf( obj  );\r\n          parser = this.parsers[ objType ];\r\n          parserType = typeof parser;\r\n\r\n          if ( parserType === \"function\" ) {\r\n            stack.push( obj );\r\n            res = parser.call( this, obj, stack );\r\n            stack.pop();\r\n            return res;\r\n          }\r\n          return ( parserType === \"string\" ) ? parser : this.parsers.error;\r\n        },\r\n        typeOf: function( obj ) {\r\n          var type;\r\n          if ( obj === null ) {\r\n            type = \"null\";\r\n          } else if ( typeof obj === \"undefined\" ) {\r\n            type = \"undefined\";\r\n          } else if ( QUnit.is( \"regexp\", obj ) ) {\r\n            type = \"regexp\";\r\n          } else if ( QUnit.is( \"date\", obj ) ) {\r\n            type = \"date\";\r\n          } else if ( QUnit.is( \"function\", obj ) ) {\r\n            type = \"function\";\r\n          } else if ( obj.setInterval !== undefined &&\r\n            obj.document !== undefined &&\r\n            obj.nodeType === undefined ) {\r\n            type = \"window\";\r\n          } else if ( obj.nodeType === 9 ) {\r\n            type = \"document\";\r\n          } else if ( obj.nodeType ) {\r\n            type = \"node\";\r\n          } else if (\r\n\r\n            // Native arrays\r\n            toString.call( obj ) === \"[object Array]\" ||\r\n\r\n            // NodeList objects\r\n            ( typeof obj.length === \"number\" && obj.item !== undefined &&\r\n              ( obj.length ? obj.item( 0 ) === obj[ 0 ] : ( obj.item( 0 ) === null &&\r\n                obj[ 0 ] === undefined ) ) )\r\n          ) {\r\n            type = \"array\";\r\n          } else if ( obj.constructor === Error.prototype.constructor ) {\r\n            type = \"error\";\r\n          } else {\r\n            type = typeof obj;\r\n          }\r\n          return type;\r\n        },\r\n\r\n        separator: function() {\r\n          return this.multiline ? this.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&#160;\" : \" \";\r\n        },\r\n\r\n        // Extra can be a number, shortcut for increasing-calling-decreasing\r\n        indent: function( extra ) {\r\n          if ( !this.multiline ) {\r\n            return \"\";\r\n          }\r\n          var chr = this.indentChar;\r\n          if ( this.HTML ) {\r\n            chr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&#160;\" );\r\n          }\r\n          return new Array( this.depth + ( extra || 0 ) ).join( chr );\r\n        },\r\n        up: function( a ) {\r\n          this.depth += a || 1;\r\n        },\r\n        down: function( a ) {\r\n          this.depth -= a || 1;\r\n        },\r\n        setParser: function( name, parser ) {\r\n          this.parsers[ name ] = parser;\r\n        },\r\n\r\n        // The next 3 are exposed so you can use them\r\n        quote: quote,\r\n        literal: literal,\r\n        join: join,\r\n        depth: 1,\r\n        maxDepth: QUnit.config.maxDepth,\r\n\r\n        // This is the list of parsers, to modify them, use dump.setParser\r\n        parsers: {\r\n          window: \"[Window]\",\r\n          document: \"[Document]\",\r\n          error: function( error ) {\r\n            return \"Error(\\\"\" + error.message + \"\\\")\";\r\n          },\r\n          unknown: \"[Unknown]\",\r\n          \"null\": \"null\",\r\n          \"undefined\": \"undefined\",\r\n          \"function\": function( fn ) {\r\n            var ret = \"function\",\r\n\r\n              // Functions never have name in IE\r\n              name = \"name\" in fn ? fn.name : ( reName.exec( fn ) || [] )[ 1 ];\r\n\r\n            if ( name ) {\r\n              ret += \" \" + name;\r\n            }\r\n            ret += \"(\";\r\n\r\n            ret = [ ret, dump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\r\n            return join( ret, dump.parse( fn, \"functionCode\" ), \"}\" );\r\n          },\r\n          array: array,\r\n          nodelist: array,\r\n          \"arguments\": array,\r\n          object: function( map, stack ) {\r\n            var keys, key, val, i, nonEnumerableProperties,\r\n              ret = [];\r\n\r\n            if ( dump.maxDepth && dump.depth > dump.maxDepth ) {\r\n              return \"[object Object]\";\r\n            }\r\n\r\n            dump.up();\r\n            keys = [];\r\n            for ( key in map ) {\r\n              keys.push( key );\r\n            }\r\n\r\n            // Some properties are not always enumerable on Error objects.\r\n            nonEnumerableProperties = [ \"message\", \"name\" ];\r\n            for ( i in nonEnumerableProperties ) {\r\n              key = nonEnumerableProperties[ i ];\r\n              if ( key in map && inArray( key, keys ) < 0 ) {\r\n                keys.push( key );\r\n              }\r\n            }\r\n            keys.sort();\r\n            for ( i = 0; i < keys.length; i++ ) {\r\n              key = keys[ i ];\r\n              val = map[ key ];\r\n              ret.push( dump.parse( key, \"key\" ) + \": \" +\r\n                dump.parse( val, undefined, stack ) );\r\n            }\r\n            dump.down();\r\n            return join( \"{\", ret, \"}\" );\r\n          },\r\n          node: function( node ) {\r\n            var len, i, val,\r\n              open = dump.HTML ? \"&lt;\" : \"<\",\r\n              close = dump.HTML ? \"&gt;\" : \">\",\r\n              tag = node.nodeName.toLowerCase(),\r\n              ret = open + tag,\r\n              attrs = node.attributes;\r\n\r\n            if ( attrs ) {\r\n              for ( i = 0, len = attrs.length; i < len; i++ ) {\r\n                val = attrs[ i ].nodeValue;\r\n\r\n                // IE6 includes all attributes in .attributes, even ones not explicitly\r\n                // set. Those have values like undefined, null, 0, false, \"\" or\r\n                // \"inherit\".\r\n                if ( val && val !== \"inherit\" ) {\r\n                  ret += \" \" + attrs[ i ].nodeName + \"=\" +\r\n                    dump.parse( val, \"attribute\" );\r\n                }\r\n              }\r\n            }\r\n            ret += close;\r\n\r\n            // Show content of TextNode or CDATASection\r\n            if ( node.nodeType === 3 || node.nodeType === 4 ) {\r\n              ret += node.nodeValue;\r\n            }\r\n\r\n            return ret + open + \"/\" + tag + close;\r\n          },\r\n\r\n          // Function calls it internally, it's the arguments part of the function\r\n          functionArgs: function( fn ) {\r\n            var args,\r\n              l = fn.length;\r\n\r\n            if ( !l ) {\r\n              return \"\";\r\n            }\r\n\r\n            args = new Array( l );\r\n            while ( l-- ) {\r\n\r\n              // 97 is 'a'\r\n              args[ l ] = String.fromCharCode( 97 + l );\r\n            }\r\n            return \" \" + args.join( \", \" ) + \" \";\r\n          },\r\n\r\n          // Object calls it internally, the key part of an item in a map\r\n          key: quote,\r\n\r\n          // Function calls it internally, it's the content of the function\r\n          functionCode: \"[code]\",\r\n\r\n          // Node calls it internally, it's a html attribute value\r\n          attribute: quote,\r\n          string: quote,\r\n          date: quote,\r\n          regexp: literal,\r\n          number: literal,\r\n          \"boolean\": literal\r\n        },\r\n\r\n        // If true, entities are escaped ( <, >, \\t, space and \\n )\r\n        HTML: false,\r\n\r\n        // Indentation unit\r\n        indentChar: \"  \",\r\n\r\n        // If true, items in a collection, are separated by a \\n, else just a space.\r\n        multiline: true\r\n      };\r\n\r\n    return dump;\r\n  }() );\r\n\r\n// Back compat\r\n  QUnit.jsDump = QUnit.dump;\r\n\r\n// Deprecated\r\n// Extend assert methods to QUnit for Backwards compatibility\r\n  ( function() {\r\n    var i,\r\n      assertions = Assert.prototype;\r\n\r\n    function applyCurrent( current ) {\r\n      return function() {\r\n        var assert = new Assert( QUnit.config.current );\r\n        current.apply( assert, arguments );\r\n      };\r\n    }\r\n\r\n    for ( i in assertions ) {\r\n      QUnit[ i ] = applyCurrent( assertions[ i ] );\r\n    }\r\n  }() );\r\n\r\n// For browser, export only select globals\r\n  if ( defined.document ) {\r\n\r\n    ( function() {\r\n      var i, l,\r\n        keys = [\r\n          \"test\",\r\n          \"module\",\r\n          \"expect\",\r\n          \"asyncTest\",\r\n          \"start\",\r\n          \"stop\",\r\n          \"ok\",\r\n          \"notOk\",\r\n          \"equal\",\r\n          \"notEqual\",\r\n          \"propEqual\",\r\n          \"notPropEqual\",\r\n          \"deepEqual\",\r\n          \"notDeepEqual\",\r\n          \"strictEqual\",\r\n          \"notStrictEqual\",\r\n          \"throws\",\r\n          \"raises\"\r\n        ];\r\n\r\n      for ( i = 0, l = keys.length; i < l; i++ ) {\r\n        window[ keys[ i ] ] = QUnit[ keys[ i ] ];\r\n      }\r\n    }() );\r\n\r\n    window.QUnit = QUnit;\r\n  }\r\n\r\n// For nodejs\r\n  if ( typeof module !== \"undefined\" && module && module.exports ) {\r\n    module.exports = QUnit;\r\n\r\n    // For consistency with CommonJS environments' exports\r\n    module.exports.QUnit = QUnit;\r\n  }\r\n\r\n// For CommonJS with exports, but without module.exports, like Rhino\r\n  if ( typeof exports !== \"undefined\" && exports ) {\r\n    exports.QUnit = QUnit;\r\n  }\r\n\r\n  if ( typeof define === \"function\" && define.amd ) {\r\n    define( function() {\r\n      return QUnit;\r\n    } );\r\n    QUnit.config.autostart = false;\r\n  }\r\n\r\n// Get a reference to the global object, like window in browsers\r\n}( ( function() {\r\n  return this;\r\n}() ) ) );\r\n\r\n( function() {\r\n\r\n// Only interact with URLs via window.location\r\n  var location = typeof window !== \"undefined\" && window.location;\r\n  if ( !location ) {\r\n    return;\r\n  }\r\n\r\n  var urlParams = getUrlParams();\r\n\r\n  QUnit.urlParams = urlParams;\r\n\r\n// Match module/test by inclusion in an array\r\n  QUnit.config.moduleId = [].concat( urlParams.moduleId || [] );\r\n  QUnit.config.testId = [].concat( urlParams.testId || [] );\r\n\r\n// Exact case-insensitive match of the module name\r\n  QUnit.config.module = urlParams.module;\r\n\r\n// Regular expression or case-insenstive substring match against \"moduleName: testName\"\r\n  QUnit.config.filter = urlParams.filter;\r\n\r\n// Test order randomization\r\n  if ( urlParams.seed === true ) {\r\n\r\n    // Generate a random seed if the option is specified without a value\r\n    QUnit.config.seed = Math.random().toString( 36 ).slice( 2 );\r\n  } else if ( urlParams.seed ) {\r\n    QUnit.config.seed = urlParams.seed;\r\n  }\r\n\r\n// Add URL-parameter-mapped config values with UI form rendering data\r\n  QUnit.config.urlConfig.push(\r\n    {\r\n      id: \"hidepassed\",\r\n      label: \"Hide passed tests\",\r\n      tooltip: \"Only show tests and assertions that fail. Stored as query-strings.\"\r\n    },\r\n    {\r\n      id: \"noglobals\",\r\n      label: \"Check for Globals\",\r\n      tooltip: \"Enabling this will test if any test introduces new properties on the \" +\r\n      \"global object (`window` in Browsers). Stored as query-strings.\"\r\n    },\r\n    {\r\n      id: \"notrycatch\",\r\n      label: \"No try-catch\",\r\n      tooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging \" +\r\n      \"exceptions in IE reasonable. Stored as query-strings.\"\r\n    }\r\n  );\r\n\r\n  QUnit.begin( function() {\r\n    var i, option,\r\n      urlConfig = QUnit.config.urlConfig;\r\n\r\n    for ( i = 0; i < urlConfig.length; i++ ) {\r\n\r\n      // Options can be either strings or objects with nonempty \"id\" properties\r\n      option = QUnit.config.urlConfig[ i ];\r\n      if ( typeof option !== \"string\" ) {\r\n        option = option.id;\r\n      }\r\n\r\n      if ( QUnit.config[ option ] === undefined ) {\r\n        QUnit.config[ option ] = urlParams[ option ];\r\n      }\r\n    }\r\n  } );\r\n\r\n  function getUrlParams() {\r\n    var i, param, name, value;\r\n    var urlParams = {};\r\n    var params = location.search.slice( 1 ).split( \"&\" );\r\n    var length = params.length;\r\n\r\n    for ( i = 0; i < length; i++ ) {\r\n      if ( params[ i ] ) {\r\n        param = params[ i ].split( \"=\" );\r\n        name = decodeURIComponent( param[ 0 ] );\r\n\r\n        // Allow just a key to turn on a flag, e.g., test.html?noglobals\r\n        value = param.length === 1 ||\r\n          decodeURIComponent( param.slice( 1 ).join( \"=\" ) ) ;\r\n        if ( urlParams[ name ] ) {\r\n          urlParams[ name ] = [].concat( urlParams[ name ], value );\r\n        } else {\r\n          urlParams[ name ] = value;\r\n        }\r\n      }\r\n    }\r\n\r\n    return urlParams;\r\n  }\r\n\r\n// Don't load the HTML Reporter on non-browser environments\r\n  if ( typeof window === \"undefined\" || !window.document ) {\r\n    return;\r\n  }\r\n\r\n// Deprecated QUnit.init - Ref #530\r\n// Re-initialize the configuration options\r\n  QUnit.init = function() {\r\n    var config = QUnit.config;\r\n\r\n    config.stats = { all: 0, bad: 0 };\r\n    config.moduleStats = { all: 0, bad: 0 };\r\n    config.started = 0;\r\n    config.updateRate = 1000;\r\n    config.blocking = false;\r\n    config.autostart = true;\r\n    config.autorun = false;\r\n    config.filter = \"\";\r\n    config.queue = [];\r\n\r\n    appendInterface();\r\n  };\r\n\r\n  var config = QUnit.config,\r\n    document = window.document,\r\n    collapseNext = false,\r\n    hasOwn = Object.prototype.hasOwnProperty,\r\n    unfilteredUrl = setUrl( { filter: undefined, module: undefined,\r\n      moduleId: undefined, testId: undefined } ),\r\n    defined = {\r\n      sessionStorage: ( function() {\r\n        var x = \"qunit-test-string\";\r\n        try {\r\n          sessionStorage.setItem( x, x );\r\n          sessionStorage.removeItem( x );\r\n          return true;\r\n        } catch ( e ) {\r\n          return false;\r\n        }\r\n      }() )\r\n    },\r\n    modulesList = [];\r\n\r\n  /**\r\n   * Escape text for attribute or text content.\r\n   */\r\n  function escapeText( s ) {\r\n    if ( !s ) {\r\n      return \"\";\r\n    }\r\n    s = s + \"\";\r\n\r\n    // Both single quotes and double quotes (for attributes)\r\n    return s.replace( /['\"<>&]/g, function( s ) {\r\n      switch ( s ) {\r\n        case \"'\":\r\n          return \"&#039;\";\r\n        case \"\\\"\":\r\n          return \"&quot;\";\r\n        case \"<\":\r\n          return \"&lt;\";\r\n        case \">\":\r\n          return \"&gt;\";\r\n        case \"&\":\r\n          return \"&amp;\";\r\n      }\r\n    } );\r\n  }\r\n\r\n  /**\r\n   * @param {HTMLElement} elem\r\n   * @param {string} type\r\n   * @param {Function} fn\r\n   */\r\n  function addEvent( elem, type, fn ) {\r\n    if ( elem.addEventListener ) {\r\n\r\n      // Standards-based browsers\r\n      elem.addEventListener( type, fn, false );\r\n    } else if ( elem.attachEvent ) {\r\n\r\n      // Support: IE <9\r\n      elem.attachEvent( \"on\" + type, function() {\r\n        var event = window.event;\r\n        if ( !event.target ) {\r\n          event.target = event.srcElement || document;\r\n        }\r\n\r\n        fn.call( elem, event );\r\n      } );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @param {Array|NodeList} elems\r\n   * @param {string} type\r\n   * @param {Function} fn\r\n   */\r\n  function addEvents( elems, type, fn ) {\r\n    var i = elems.length;\r\n    while ( i-- ) {\r\n      addEvent( elems[ i ], type, fn );\r\n    }\r\n  }\r\n\r\n  function hasClass( elem, name ) {\r\n    return ( \" \" + elem.className + \" \" ).indexOf( \" \" + name + \" \" ) >= 0;\r\n  }\r\n\r\n  function addClass( elem, name ) {\r\n    if ( !hasClass( elem, name ) ) {\r\n      elem.className += ( elem.className ? \" \" : \"\" ) + name;\r\n    }\r\n  }\r\n\r\n  function toggleClass( elem, name, force ) {\r\n    if ( force || typeof force === \"undefined\" && !hasClass( elem, name ) ) {\r\n      addClass( elem, name );\r\n    } else {\r\n      removeClass( elem, name );\r\n    }\r\n  }\r\n\r\n  function removeClass( elem, name ) {\r\n    var set = \" \" + elem.className + \" \";\r\n\r\n    // Class name may appear multiple times\r\n    while ( set.indexOf( \" \" + name + \" \" ) >= 0 ) {\r\n      set = set.replace( \" \" + name + \" \", \" \" );\r\n    }\r\n\r\n    // Trim for prettiness\r\n    elem.className = typeof set.trim === \"function\" ? set.trim() : set.replace( /^\\s+|\\s+$/g, \"\" );\r\n  }\r\n\r\n  function id( name ) {\r\n    return document.getElementById && document.getElementById( name );\r\n  }\r\n\r\n  function getUrlConfigHtml() {\r\n    var i, j, val,\r\n      escaped, escapedTooltip,\r\n      selection = false,\r\n      urlConfig = config.urlConfig,\r\n      urlConfigHtml = \"\";\r\n\r\n    for ( i = 0; i < urlConfig.length; i++ ) {\r\n\r\n      // Options can be either strings or objects with nonempty \"id\" properties\r\n      val = config.urlConfig[ i ];\r\n      if ( typeof val === \"string\" ) {\r\n        val = {\r\n          id: val,\r\n          label: val\r\n        };\r\n      }\r\n\r\n      escaped = escapeText( val.id );\r\n      escapedTooltip = escapeText( val.tooltip );\r\n\r\n      if ( !val.value || typeof val.value === \"string\" ) {\r\n        urlConfigHtml += \"<input id='qunit-urlconfig-\" + escaped +\r\n          \"' name='\" + escaped + \"' type='checkbox'\" +\r\n          ( val.value ? \" value='\" + escapeText( val.value ) + \"'\" : \"\" ) +\r\n          ( config[ val.id ] ? \" checked='checked'\" : \"\" ) +\r\n          \" title='\" + escapedTooltip + \"' /><label for='qunit-urlconfig-\" + escaped +\r\n          \"' title='\" + escapedTooltip + \"'>\" + val.label + \"</label>\";\r\n      } else {\r\n        urlConfigHtml += \"<label for='qunit-urlconfig-\" + escaped +\r\n          \"' title='\" + escapedTooltip + \"'>\" + val.label +\r\n          \": </label><select id='qunit-urlconfig-\" + escaped +\r\n          \"' name='\" + escaped + \"' title='\" + escapedTooltip + \"'><option></option>\";\r\n\r\n        if ( QUnit.is( \"array\", val.value ) ) {\r\n          for ( j = 0; j < val.value.length; j++ ) {\r\n            escaped = escapeText( val.value[ j ] );\r\n            urlConfigHtml += \"<option value='\" + escaped + \"'\" +\r\n              ( config[ val.id ] === val.value[ j ] ?\r\n                ( selection = true ) && \" selected='selected'\" : \"\" ) +\r\n              \">\" + escaped + \"</option>\";\r\n          }\r\n        } else {\r\n          for ( j in val.value ) {\r\n            if ( hasOwn.call( val.value, j ) ) {\r\n              urlConfigHtml += \"<option value='\" + escapeText( j ) + \"'\" +\r\n                ( config[ val.id ] === j ?\r\n                  ( selection = true ) && \" selected='selected'\" : \"\" ) +\r\n                \">\" + escapeText( val.value[ j ] ) + \"</option>\";\r\n            }\r\n          }\r\n        }\r\n        if ( config[ val.id ] && !selection ) {\r\n          escaped = escapeText( config[ val.id ] );\r\n          urlConfigHtml += \"<option value='\" + escaped +\r\n            \"' selected='selected' disabled='disabled'>\" + escaped + \"</option>\";\r\n        }\r\n        urlConfigHtml += \"</select>\";\r\n      }\r\n    }\r\n\r\n    return urlConfigHtml;\r\n  }\r\n\r\n// Handle \"click\" events on toolbar checkboxes and \"change\" for select menus.\r\n// Updates the URL with the new state of `config.urlConfig` values.\r\n  function toolbarChanged() {\r\n    var updatedUrl, value, tests,\r\n      field = this,\r\n      params = {};\r\n\r\n    // Detect if field is a select menu or a checkbox\r\n    if ( \"selectedIndex\" in field ) {\r\n      value = field.options[ field.selectedIndex ].value || undefined;\r\n    } else {\r\n      value = field.checked ? ( field.defaultValue || true ) : undefined;\r\n    }\r\n\r\n    params[ field.name ] = value;\r\n    updatedUrl = setUrl( params );\r\n\r\n    // Check if we can apply the change without a page refresh\r\n    if ( \"hidepassed\" === field.name && \"replaceState\" in window.history ) {\r\n      QUnit.urlParams[ field.name ] = value;\r\n      config[ field.name ] = value || false;\r\n      tests = id( \"qunit-tests\" );\r\n      if ( tests ) {\r\n        toggleClass( tests, \"hidepass\", value || false );\r\n      }\r\n      window.history.replaceState( null, \"\", updatedUrl );\r\n    } else {\r\n      window.location = updatedUrl;\r\n    }\r\n  }\r\n\r\n  function setUrl( params ) {\r\n    var key, arrValue, i,\r\n      querystring = \"?\",\r\n      location = window.location;\r\n\r\n    params = QUnit.extend( QUnit.extend( {}, QUnit.urlParams ), params );\r\n\r\n    for ( key in params ) {\r\n\r\n      // Skip inherited or undefined properties\r\n      if ( hasOwn.call( params, key ) && params[ key ] !== undefined ) {\r\n\r\n        // Output a parameter for each value of this key (but usually just one)\r\n        arrValue = [].concat( params[ key ] );\r\n        for ( i = 0; i < arrValue.length; i++ ) {\r\n          querystring += encodeURIComponent( key );\r\n          if ( arrValue[ i ] !== true ) {\r\n            querystring += \"=\" + encodeURIComponent( arrValue[ i ] );\r\n          }\r\n          querystring += \"&\";\r\n        }\r\n      }\r\n    }\r\n    return location.protocol + \"//\" + location.host +\r\n      location.pathname + querystring.slice( 0, -1 );\r\n  }\r\n\r\n  function applyUrlParams() {\r\n    var selectedModule,\r\n      modulesList = id( \"qunit-modulefilter\" ),\r\n      filter = id( \"qunit-filter-input\" ).value;\r\n\r\n    selectedModule = modulesList ?\r\n      decodeURIComponent( modulesList.options[ modulesList.selectedIndex ].value ) :\r\n      undefined;\r\n\r\n    window.location = setUrl( {\r\n      module: ( selectedModule === \"\" ) ? undefined : selectedModule,\r\n      filter: ( filter === \"\" ) ? undefined : filter,\r\n\r\n      // Remove moduleId and testId filters\r\n      moduleId: undefined,\r\n      testId: undefined\r\n    } );\r\n  }\r\n\r\n  function toolbarUrlConfigContainer() {\r\n    var urlConfigContainer = document.createElement( \"span\" );\r\n\r\n    urlConfigContainer.innerHTML = getUrlConfigHtml();\r\n    addClass( urlConfigContainer, \"qunit-url-config\" );\r\n\r\n    // For oldIE support:\r\n    // * Add handlers to the individual elements instead of the container\r\n    // * Use \"click\" instead of \"change\" for checkboxes\r\n    addEvents( urlConfigContainer.getElementsByTagName( \"input\" ), \"click\", toolbarChanged );\r\n    addEvents( urlConfigContainer.getElementsByTagName( \"select\" ), \"change\", toolbarChanged );\r\n\r\n    return urlConfigContainer;\r\n  }\r\n\r\n  function toolbarLooseFilter() {\r\n    var filter = document.createElement( \"form\" ),\r\n      label = document.createElement( \"label\" ),\r\n      input = document.createElement( \"input\" ),\r\n      button = document.createElement( \"button\" );\r\n\r\n    addClass( filter, \"qunit-filter\" );\r\n\r\n    label.innerHTML = \"Filter: \";\r\n\r\n    input.type = \"text\";\r\n    input.value = config.filter || \"\";\r\n    input.name = \"filter\";\r\n    input.id = \"qunit-filter-input\";\r\n\r\n    button.innerHTML = \"Go\";\r\n\r\n    label.appendChild( input );\r\n\r\n    filter.appendChild( label );\r\n    filter.appendChild( button );\r\n    addEvent( filter, \"submit\", function( ev ) {\r\n      applyUrlParams();\r\n\r\n      if ( ev && ev.preventDefault ) {\r\n        ev.preventDefault();\r\n      }\r\n\r\n      return false;\r\n    } );\r\n\r\n    return filter;\r\n  }\r\n\r\n  function toolbarModuleFilterHtml() {\r\n    var i,\r\n      moduleFilterHtml = \"\";\r\n\r\n    if ( !modulesList.length ) {\r\n      return false;\r\n    }\r\n\r\n    moduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label>\" +\r\n      \"<select id='qunit-modulefilter' name='modulefilter'><option value='' \" +\r\n      ( QUnit.urlParams.module === undefined ? \"selected='selected'\" : \"\" ) +\r\n      \">< All Modules ></option>\";\r\n\r\n    for ( i = 0; i < modulesList.length; i++ ) {\r\n      moduleFilterHtml += \"<option value='\" +\r\n        escapeText( encodeURIComponent( modulesList[ i ] ) ) + \"' \" +\r\n        ( QUnit.urlParams.module === modulesList[ i ] ? \"selected='selected'\" : \"\" ) +\r\n        \">\" + escapeText( modulesList[ i ] ) + \"</option>\";\r\n    }\r\n    moduleFilterHtml += \"</select>\";\r\n\r\n    return moduleFilterHtml;\r\n  }\r\n\r\n  function toolbarModuleFilter() {\r\n    var toolbar = id( \"qunit-testrunner-toolbar\" ),\r\n      moduleFilter = document.createElement( \"span\" ),\r\n      moduleFilterHtml = toolbarModuleFilterHtml();\r\n\r\n    if ( !toolbar || !moduleFilterHtml ) {\r\n      return false;\r\n    }\r\n\r\n    moduleFilter.setAttribute( \"id\", \"qunit-modulefilter-container\" );\r\n    moduleFilter.innerHTML = moduleFilterHtml;\r\n\r\n    addEvent( moduleFilter.lastChild, \"change\", applyUrlParams );\r\n\r\n    toolbar.appendChild( moduleFilter );\r\n  }\r\n\r\n  function appendToolbar() {\r\n    var toolbar = id( \"qunit-testrunner-toolbar\" );\r\n\r\n    if ( toolbar ) {\r\n      toolbar.appendChild( toolbarUrlConfigContainer() );\r\n      toolbar.appendChild( toolbarLooseFilter() );\r\n      toolbarModuleFilter();\r\n    }\r\n  }\r\n\r\n  function appendHeader() {\r\n    var header = id( \"qunit-header\" );\r\n\r\n    if ( header ) {\r\n      header.innerHTML = \"<a href='\" + escapeText( unfilteredUrl ) + \"'>\" + header.innerHTML +\r\n        \"</a> \";\r\n    }\r\n  }\r\n\r\n  function appendBanner() {\r\n    var banner = id( \"qunit-banner\" );\r\n\r\n    if ( banner ) {\r\n      banner.className = \"\";\r\n    }\r\n  }\r\n\r\n  function appendTestResults() {\r\n    var tests = id( \"qunit-tests\" ),\r\n      result = id( \"qunit-testresult\" );\r\n\r\n    if ( result ) {\r\n      result.parentNode.removeChild( result );\r\n    }\r\n\r\n    if ( tests ) {\r\n      tests.innerHTML = \"\";\r\n      result = document.createElement( \"p\" );\r\n      result.id = \"qunit-testresult\";\r\n      result.className = \"result\";\r\n      tests.parentNode.insertBefore( result, tests );\r\n      result.innerHTML = \"Running...<br />&#160;\";\r\n    }\r\n  }\r\n\r\n  function storeFixture() {\r\n    var fixture = id( \"qunit-fixture\" );\r\n    if ( fixture ) {\r\n      config.fixture = fixture.innerHTML;\r\n    }\r\n  }\r\n\r\n  function appendFilteredTest() {\r\n    var testId = QUnit.config.testId;\r\n    if ( !testId || testId.length <= 0 ) {\r\n      return \"\";\r\n    }\r\n    return \"<div id='qunit-filteredTest'>Rerunning selected tests: \" +\r\n      escapeText( testId.join( \", \" ) ) +\r\n      \" <a id='qunit-clearFilter' href='\" +\r\n      escapeText( unfilteredUrl ) +\r\n      \"'>Run all tests</a></div>\";\r\n  }\r\n\r\n  function appendUserAgent() {\r\n    var userAgent = id( \"qunit-userAgent\" );\r\n\r\n    if ( userAgent ) {\r\n      userAgent.innerHTML = \"\";\r\n      userAgent.appendChild(\r\n        document.createTextNode(\r\n          \"QUnit \" + QUnit.version + \"; \" + navigator.userAgent\r\n        )\r\n      );\r\n    }\r\n  }\r\n\r\n  function appendInterface() {\r\n    var qunit = id( \"qunit\" );\r\n\r\n    if ( qunit ) {\r\n      qunit.innerHTML =\r\n        \"<h1 id='qunit-header'>\" + escapeText( document.title ) + \"</h1>\" +\r\n        \"<h2 id='qunit-banner'></h2>\" +\r\n        \"<div id='qunit-testrunner-toolbar'></div>\" +\r\n        appendFilteredTest() +\r\n        \"<h2 id='qunit-userAgent'></h2>\" +\r\n        \"<ol id='qunit-tests'></ol>\";\r\n    }\r\n\r\n    appendHeader();\r\n    appendBanner();\r\n    appendTestResults();\r\n    appendUserAgent();\r\n    appendToolbar();\r\n  }\r\n\r\n  function appendTestsList( modules ) {\r\n    var i, l, x, z, test, moduleObj;\r\n\r\n    for ( i = 0, l = modules.length; i < l; i++ ) {\r\n      moduleObj = modules[ i ];\r\n\r\n      for ( x = 0, z = moduleObj.tests.length; x < z; x++ ) {\r\n        test = moduleObj.tests[ x ];\r\n\r\n        appendTest( test.name, test.testId, moduleObj.name );\r\n      }\r\n    }\r\n  }\r\n\r\n  function appendTest( name, testId, moduleName ) {\r\n    var title, rerunTrigger, testBlock, assertList,\r\n      tests = id( \"qunit-tests\" );\r\n\r\n    if ( !tests ) {\r\n      return;\r\n    }\r\n\r\n    title = document.createElement( \"strong\" );\r\n    title.innerHTML = getNameHtml( name, moduleName );\r\n\r\n    rerunTrigger = document.createElement( \"a\" );\r\n    rerunTrigger.innerHTML = \"Rerun\";\r\n    rerunTrigger.href = setUrl( { testId: testId } );\r\n\r\n    testBlock = document.createElement( \"li\" );\r\n    testBlock.appendChild( title );\r\n    testBlock.appendChild( rerunTrigger );\r\n    testBlock.id = \"qunit-test-output-\" + testId;\r\n\r\n    assertList = document.createElement( \"ol\" );\r\n    assertList.className = \"qunit-assert-list\";\r\n\r\n    testBlock.appendChild( assertList );\r\n\r\n    tests.appendChild( testBlock );\r\n  }\r\n\r\n// HTML Reporter initialization and load\r\n  QUnit.begin( function( details ) {\r\n    var i, moduleObj, tests;\r\n\r\n    // Sort modules by name for the picker\r\n    for ( i = 0; i < details.modules.length; i++ ) {\r\n      moduleObj = details.modules[ i ];\r\n      if ( moduleObj.name ) {\r\n        modulesList.push( moduleObj.name );\r\n      }\r\n    }\r\n    modulesList.sort( function( a, b ) {\r\n      return a.localeCompare( b );\r\n    } );\r\n\r\n    // Capture fixture HTML from the page\r\n    storeFixture();\r\n\r\n    // Initialize QUnit elements\r\n    appendInterface();\r\n    appendTestsList( details.modules );\r\n    tests = id( \"qunit-tests\" );\r\n    if ( tests && config.hidepassed ) {\r\n      addClass( tests, \"hidepass\" );\r\n    }\r\n  } );\r\n\r\n  QUnit.done( function( details ) {\r\n    var i, key,\r\n      banner = id( \"qunit-banner\" ),\r\n      tests = id( \"qunit-tests\" ),\r\n      html = [\r\n        \"Tests completed in \",\r\n        details.runtime,\r\n        \" milliseconds.<br />\",\r\n        \"<span class='passed'>\",\r\n        details.passed,\r\n        \"</span> assertions of <span class='total'>\",\r\n        details.total,\r\n        \"</span> passed, <span class='failed'>\",\r\n        details.failed,\r\n        \"</span> failed.\"\r\n      ].join( \"\" );\r\n\r\n    if ( banner ) {\r\n      banner.className = details.failed ? \"qunit-fail\" : \"qunit-pass\";\r\n    }\r\n\r\n    if ( tests ) {\r\n      id( \"qunit-testresult\" ).innerHTML = html;\r\n    }\r\n\r\n    if ( config.altertitle && document.title ) {\r\n\r\n      // Show ✖ for good, ✔ for bad suite result in title\r\n      // use escape sequences in case file gets loaded with non-utf-8-charset\r\n      document.title = [\r\n        ( details.failed ? \"\\u2716\" : \"\\u2714\" ),\r\n        document.title.replace( /^[\\u2714\\u2716] /i, \"\" )\r\n      ].join( \" \" );\r\n    }\r\n\r\n    // Clear own sessionStorage items if all tests passed\r\n    if ( config.reorder && defined.sessionStorage && details.failed === 0 ) {\r\n      for ( i = 0; i < sessionStorage.length; i++ ) {\r\n        key = sessionStorage.key( i++ );\r\n        if ( key.indexOf( \"qunit-test-\" ) === 0 ) {\r\n          sessionStorage.removeItem( key );\r\n        }\r\n      }\r\n    }\r\n\r\n    // Scroll back to top to show results\r\n    if ( config.scrolltop && window.scrollTo ) {\r\n      window.scrollTo( 0, 0 );\r\n    }\r\n  } );\r\n\r\n  function getNameHtml( name, module ) {\r\n    var nameHtml = \"\";\r\n\r\n    if ( module ) {\r\n      nameHtml = \"<span class='module-name'>\" + escapeText( module ) + \"</span>: \";\r\n    }\r\n\r\n    nameHtml += \"<span class='test-name'>\" + escapeText( name ) + \"</span>\";\r\n\r\n    return nameHtml;\r\n  }\r\n\r\n  QUnit.testStart( function( details ) {\r\n    var running, testBlock, bad;\r\n\r\n    testBlock = id( \"qunit-test-output-\" + details.testId );\r\n    if ( testBlock ) {\r\n      testBlock.className = \"running\";\r\n    } else {\r\n\r\n      // Report later registered tests\r\n      appendTest( details.name, details.testId, details.module );\r\n    }\r\n\r\n    running = id( \"qunit-testresult\" );\r\n    if ( running ) {\r\n      bad = QUnit.config.reorder && defined.sessionStorage &&\r\n        +sessionStorage.getItem( \"qunit-test-\" + details.module + \"-\" + details.name );\r\n\r\n      running.innerHTML = ( bad ?\r\n        \"Rerunning previously failed test: <br />\" :\r\n        \"Running: <br />\" ) +\r\n        getNameHtml( details.name, details.module );\r\n    }\r\n\r\n  } );\r\n\r\n  function stripHtml( string ) {\r\n\r\n    // Strip tags, html entity and whitespaces\r\n    return string.replace( /<\\/?[^>]+(>|$)/g, \"\" ).replace( /\\&quot;/g, \"\" ).replace( /\\s+/g, \"\" );\r\n  }\r\n\r\n  QUnit.log( function( details ) {\r\n    var assertList, assertLi,\r\n      message, expected, actual, diff,\r\n      showDiff = false,\r\n      testItem = id( \"qunit-test-output-\" + details.testId );\r\n\r\n    if ( !testItem ) {\r\n      return;\r\n    }\r\n\r\n    message = escapeText( details.message ) || ( details.result ? \"okay\" : \"failed\" );\r\n    message = \"<span class='test-message'>\" + message + \"</span>\";\r\n    message += \"<span class='runtime'>@ \" + details.runtime + \" ms</span>\";\r\n\r\n    // The pushFailure doesn't provide details.expected\r\n    // when it calls, it's implicit to also not show expected and diff stuff\r\n    // Also, we need to check details.expected existence, as it can exist and be undefined\r\n    if ( !details.result && hasOwn.call( details, \"expected\" ) ) {\r\n      if ( details.negative ) {\r\n        expected = \"NOT \" + QUnit.dump.parse( details.expected );\r\n      } else {\r\n        expected = QUnit.dump.parse( details.expected );\r\n      }\r\n\r\n      actual = QUnit.dump.parse( details.actual );\r\n      message += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" +\r\n        escapeText( expected ) +\r\n        \"</pre></td></tr>\";\r\n\r\n      if ( actual !== expected ) {\r\n\r\n        message += \"<tr class='test-actual'><th>Result: </th><td><pre>\" +\r\n          escapeText( actual ) + \"</pre></td></tr>\";\r\n\r\n        // Don't show diff if actual or expected are booleans\r\n        if ( !( /^(true|false)$/.test( actual ) ) &&\r\n          !( /^(true|false)$/.test( expected ) ) ) {\r\n          diff = QUnit.diff( expected, actual );\r\n          showDiff = stripHtml( diff ).length !==\r\n            stripHtml( expected ).length +\r\n            stripHtml( actual ).length;\r\n        }\r\n\r\n        // Don't show diff if expected and actual are totally different\r\n        if ( showDiff ) {\r\n          message += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" +\r\n            diff + \"</pre></td></tr>\";\r\n        }\r\n      } else if ( expected.indexOf( \"[object Array]\" ) !== -1 ||\r\n        expected.indexOf( \"[object Object]\" ) !== -1 ) {\r\n        message += \"<tr class='test-message'><th>Message: </th><td>\" +\r\n          \"Diff suppressed as the depth of object is more than current max depth (\" +\r\n          QUnit.config.maxDepth + \").<p>Hint: Use <code>QUnit.dump.maxDepth</code> to \" +\r\n          \" run with a higher max depth or <a href='\" +\r\n          escapeText( setUrl( { maxDepth: -1 } ) ) + \"'>\" +\r\n          \"Rerun</a> without max depth.</p></td></tr>\";\r\n      } else {\r\n        message += \"<tr class='test-message'><th>Message: </th><td>\" +\r\n          \"Diff suppressed as the expected and actual results have an equivalent\" +\r\n          \" serialization</td></tr>\";\r\n      }\r\n\r\n      if ( details.source ) {\r\n        message += \"<tr class='test-source'><th>Source: </th><td><pre>\" +\r\n          escapeText( details.source ) + \"</pre></td></tr>\";\r\n      }\r\n\r\n      message += \"</table>\";\r\n\r\n      // This occurs when pushFailure is set and we have an extracted stack trace\r\n    } else if ( !details.result && details.source ) {\r\n      message += \"<table>\" +\r\n        \"<tr class='test-source'><th>Source: </th><td><pre>\" +\r\n        escapeText( details.source ) + \"</pre></td></tr>\" +\r\n        \"</table>\";\r\n    }\r\n\r\n    assertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\r\n\r\n    assertLi = document.createElement( \"li\" );\r\n    assertLi.className = details.result ? \"pass\" : \"fail\";\r\n    assertLi.innerHTML = message;\r\n    assertList.appendChild( assertLi );\r\n  } );\r\n\r\n  QUnit.testDone( function( details ) {\r\n    var testTitle, time, testItem, assertList,\r\n      good, bad, testCounts, skipped, sourceName,\r\n      tests = id( \"qunit-tests\" );\r\n\r\n    if ( !tests ) {\r\n      return;\r\n    }\r\n\r\n    testItem = id( \"qunit-test-output-\" + details.testId );\r\n\r\n    assertList = testItem.getElementsByTagName( \"ol\" )[ 0 ];\r\n\r\n    good = details.passed;\r\n    bad = details.failed;\r\n\r\n    // Store result when possible\r\n    if ( config.reorder && defined.sessionStorage ) {\r\n      if ( bad ) {\r\n        sessionStorage.setItem( \"qunit-test-\" + details.module + \"-\" + details.name, bad );\r\n      } else {\r\n        sessionStorage.removeItem( \"qunit-test-\" + details.module + \"-\" + details.name );\r\n      }\r\n    }\r\n\r\n    if ( bad === 0 ) {\r\n\r\n      // Collapse the passing tests\r\n      addClass( assertList, \"qunit-collapsed\" );\r\n    } else if ( bad && config.collapse && !collapseNext ) {\r\n\r\n      // Skip collapsing the first failing test\r\n      collapseNext = true;\r\n    } else {\r\n\r\n      // Collapse remaining tests\r\n      addClass( assertList, \"qunit-collapsed\" );\r\n    }\r\n\r\n    // The testItem.firstChild is the test name\r\n    testTitle = testItem.firstChild;\r\n\r\n    testCounts = bad ?\r\n      \"<b class='failed'>\" + bad + \"</b>, \" + \"<b class='passed'>\" + good + \"</b>, \" :\r\n      \"\";\r\n\r\n    testTitle.innerHTML += \" <b class='counts'>(\" + testCounts +\r\n      details.assertions.length + \")</b>\";\r\n\r\n    if ( details.skipped ) {\r\n      testItem.className = \"skipped\";\r\n      skipped = document.createElement( \"em\" );\r\n      skipped.className = \"qunit-skipped-label\";\r\n      skipped.innerHTML = \"skipped\";\r\n      testItem.insertBefore( skipped, testTitle );\r\n    } else {\r\n      addEvent( testTitle, \"click\", function() {\r\n        toggleClass( assertList, \"qunit-collapsed\" );\r\n      } );\r\n\r\n      testItem.className = bad ? \"fail\" : \"pass\";\r\n\r\n      time = document.createElement( \"span\" );\r\n      time.className = \"runtime\";\r\n      time.innerHTML = details.runtime + \" ms\";\r\n      testItem.insertBefore( time, assertList );\r\n    }\r\n\r\n    // Show the source of the test when showing assertions\r\n    if ( details.source ) {\r\n      sourceName = document.createElement( \"p\" );\r\n      sourceName.innerHTML = \"<strong>Source: </strong>\" + details.source;\r\n      addClass( sourceName, \"qunit-source\" );\r\n      if ( bad === 0 ) {\r\n        addClass( sourceName, \"qunit-collapsed\" );\r\n      }\r\n      addEvent( testTitle, \"click\", function() {\r\n        toggleClass( sourceName, \"qunit-collapsed\" );\r\n      } );\r\n      testItem.appendChild( sourceName );\r\n    }\r\n  } );\r\n\r\n// Avoid readyState issue with phantomjs\r\n// Ref: #818\r\n  var notPhantom = ( function( p ) {\r\n    return !( p && p.version && p.version.major > 0 );\r\n  } )( window.phantom );\r\n\r\n  if ( notPhantom && document.readyState === \"complete\" ) {\r\n    QUnit.load();\r\n  } else {\r\n    addEvent( window, \"load\", QUnit.load );\r\n  }\r\n\r\n  /*\r\n * This file is a modified version of google-diff-match-patch's JavaScript implementation\r\n * (https://code.google.com/p/google-diff-match-patch/source/browse/trunk/javascript/diff_match_patch_uncompressed.js),\r\n * modifications are licensed as more fully set forth in LICENSE.txt.\r\n *\r\n * The original source of google-diff-match-patch is attributable and licensed as follows:\r\n *\r\n * Copyright 2006 Google Inc.\r\n * https://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * https://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n * More Info:\r\n *  https://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Usage: QUnit.diff(expected, actual)\r\n *\r\n */\r\n  QUnit.diff = ( function() {\r\n    function DiffMatchPatch() {\r\n    }\r\n\r\n    //  DIFF FUNCTIONS\r\n\r\n    /**\r\n     * The data structure representing a diff is an array of tuples:\r\n     * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\r\n     * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n     */\r\n    var DIFF_DELETE = -1,\r\n      DIFF_INSERT = 1,\r\n      DIFF_EQUAL = 0;\r\n\r\n    /**\r\n     * Find the differences between two texts.  Simplifies the problem by stripping\r\n     * any common prefix or suffix off the texts before diffing.\r\n     * @param {string} text1 Old string to be diffed.\r\n     * @param {string} text2 New string to be diffed.\r\n     * @param {boolean=} optChecklines Optional speedup flag. If present and false,\r\n     *     then don't run a line-level diff first to identify the changed areas.\r\n     *     Defaults to true, which does a faster, slightly less optimal diff.\r\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\r\n     */\r\n    DiffMatchPatch.prototype.DiffMain = function( text1, text2, optChecklines ) {\r\n      var deadline, checklines, commonlength,\r\n        commonprefix, commonsuffix, diffs;\r\n\r\n      // The diff must be complete in up to 1 second.\r\n      deadline = ( new Date() ).getTime() + 1000;\r\n\r\n      // Check for null inputs.\r\n      if ( text1 === null || text2 === null ) {\r\n        throw new Error( \"Null input. (DiffMain)\" );\r\n      }\r\n\r\n      // Check for equality (speedup).\r\n      if ( text1 === text2 ) {\r\n        if ( text1 ) {\r\n          return [\r\n            [ DIFF_EQUAL, text1 ]\r\n          ];\r\n        }\r\n        return [];\r\n      }\r\n\r\n      if ( typeof optChecklines === \"undefined\" ) {\r\n        optChecklines = true;\r\n      }\r\n\r\n      checklines = optChecklines;\r\n\r\n      // Trim off common prefix (speedup).\r\n      commonlength = this.diffCommonPrefix( text1, text2 );\r\n      commonprefix = text1.substring( 0, commonlength );\r\n      text1 = text1.substring( commonlength );\r\n      text2 = text2.substring( commonlength );\r\n\r\n      // Trim off common suffix (speedup).\r\n      commonlength = this.diffCommonSuffix( text1, text2 );\r\n      commonsuffix = text1.substring( text1.length - commonlength );\r\n      text1 = text1.substring( 0, text1.length - commonlength );\r\n      text2 = text2.substring( 0, text2.length - commonlength );\r\n\r\n      // Compute the diff on the middle block.\r\n      diffs = this.diffCompute( text1, text2, checklines, deadline );\r\n\r\n      // Restore the prefix and suffix.\r\n      if ( commonprefix ) {\r\n        diffs.unshift( [ DIFF_EQUAL, commonprefix ] );\r\n      }\r\n      if ( commonsuffix ) {\r\n        diffs.push( [ DIFF_EQUAL, commonsuffix ] );\r\n      }\r\n      this.diffCleanupMerge( diffs );\r\n      return diffs;\r\n    };\r\n\r\n    /**\r\n     * Reduce the number of edits by eliminating operationally trivial equalities.\r\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\r\n     */\r\n    DiffMatchPatch.prototype.diffCleanupEfficiency = function( diffs ) {\r\n      var changes, equalities, equalitiesLength, lastequality,\r\n        pointer, preIns, preDel, postIns, postDel;\r\n      changes = false;\r\n      equalities = []; // Stack of indices where equalities are found.\r\n      equalitiesLength = 0; // Keeping our own length var is faster in JS.\r\n      /** @type {?string} */\r\n      lastequality = null;\r\n\r\n      // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n      pointer = 0; // Index of current position.\r\n\r\n      // Is there an insertion operation before the last equality.\r\n      preIns = false;\r\n\r\n      // Is there a deletion operation before the last equality.\r\n      preDel = false;\r\n\r\n      // Is there an insertion operation after the last equality.\r\n      postIns = false;\r\n\r\n      // Is there a deletion operation after the last equality.\r\n      postDel = false;\r\n      while ( pointer < diffs.length ) {\r\n\r\n        // Equality found.\r\n        if ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) {\r\n          if ( diffs[ pointer ][ 1 ].length < 4 && ( postIns || postDel ) ) {\r\n\r\n            // Candidate found.\r\n            equalities[ equalitiesLength++ ] = pointer;\r\n            preIns = postIns;\r\n            preDel = postDel;\r\n            lastequality = diffs[ pointer ][ 1 ];\r\n          } else {\r\n\r\n            // Not a candidate, and can never become one.\r\n            equalitiesLength = 0;\r\n            lastequality = null;\r\n          }\r\n          postIns = postDel = false;\r\n\r\n          // An insertion or deletion.\r\n        } else {\r\n\r\n          if ( diffs[ pointer ][ 0 ] === DIFF_DELETE ) {\r\n            postDel = true;\r\n          } else {\r\n            postIns = true;\r\n          }\r\n\r\n          /*\r\n\t\t\t\t * Five types to be split:\r\n\t\t\t\t * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n\t\t\t\t * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n\t\t\t\t * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n\t\t\t\t * <ins>A</del>X<ins>C</ins><del>D</del>\r\n\t\t\t\t * <ins>A</ins><del>B</del>X<del>C</del>\r\n\t\t\t\t */\r\n          if ( lastequality && ( ( preIns && preDel && postIns && postDel ) ||\r\n            ( ( lastequality.length < 2 ) &&\r\n              ( preIns + preDel + postIns + postDel ) === 3 ) ) ) {\r\n\r\n            // Duplicate record.\r\n            diffs.splice(\r\n              equalities[ equalitiesLength - 1 ],\r\n              0,\r\n              [ DIFF_DELETE, lastequality ]\r\n            );\r\n\r\n            // Change second copy to insert.\r\n            diffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\r\n            equalitiesLength--; // Throw away the equality we just deleted;\r\n            lastequality = null;\r\n            if ( preIns && preDel ) {\r\n\r\n              // No changes made which could affect previous entry, keep going.\r\n              postIns = postDel = true;\r\n              equalitiesLength = 0;\r\n            } else {\r\n              equalitiesLength--; // Throw away the previous equality.\r\n              pointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\r\n              postIns = postDel = false;\r\n            }\r\n            changes = true;\r\n          }\r\n        }\r\n        pointer++;\r\n      }\r\n\r\n      if ( changes ) {\r\n        this.diffCleanupMerge( diffs );\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Convert a diff array into a pretty HTML report.\r\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\r\n     * @param {integer} string to be beautified.\r\n     * @return {string} HTML representation.\r\n     */\r\n    DiffMatchPatch.prototype.diffPrettyHtml = function( diffs ) {\r\n      var op, data, x,\r\n        html = [];\r\n      for ( x = 0; x < diffs.length; x++ ) {\r\n        op = diffs[ x ][ 0 ]; // Operation (insert, delete, equal)\r\n        data = diffs[ x ][ 1 ]; // Text of change.\r\n        switch ( op ) {\r\n          case DIFF_INSERT:\r\n            html[ x ] = \"<ins>\" + escapeText( data ) + \"</ins>\";\r\n            break;\r\n          case DIFF_DELETE:\r\n            html[ x ] = \"<del>\" + escapeText( data ) + \"</del>\";\r\n            break;\r\n          case DIFF_EQUAL:\r\n            html[ x ] = \"<span>\" + escapeText( data ) + \"</span>\";\r\n            break;\r\n        }\r\n      }\r\n      return html.join( \"\" );\r\n    };\r\n\r\n    /**\r\n     * Determine the common prefix of two strings.\r\n     * @param {string} text1 First string.\r\n     * @param {string} text2 Second string.\r\n     * @return {number} The number of characters common to the start of each\r\n     *     string.\r\n     */\r\n    DiffMatchPatch.prototype.diffCommonPrefix = function( text1, text2 ) {\r\n      var pointermid, pointermax, pointermin, pointerstart;\r\n\r\n      // Quick check for common null cases.\r\n      if ( !text1 || !text2 || text1.charAt( 0 ) !== text2.charAt( 0 ) ) {\r\n        return 0;\r\n      }\r\n\r\n      // Binary search.\r\n      // Performance analysis: https://neil.fraser.name/news/2007/10/09/\r\n      pointermin = 0;\r\n      pointermax = Math.min( text1.length, text2.length );\r\n      pointermid = pointermax;\r\n      pointerstart = 0;\r\n      while ( pointermin < pointermid ) {\r\n        if ( text1.substring( pointerstart, pointermid ) ===\r\n          text2.substring( pointerstart, pointermid ) ) {\r\n          pointermin = pointermid;\r\n          pointerstart = pointermin;\r\n        } else {\r\n          pointermax = pointermid;\r\n        }\r\n        pointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\r\n      }\r\n      return pointermid;\r\n    };\r\n\r\n    /**\r\n     * Determine the common suffix of two strings.\r\n     * @param {string} text1 First string.\r\n     * @param {string} text2 Second string.\r\n     * @return {number} The number of characters common to the end of each string.\r\n     */\r\n    DiffMatchPatch.prototype.diffCommonSuffix = function( text1, text2 ) {\r\n      var pointermid, pointermax, pointermin, pointerend;\r\n\r\n      // Quick check for common null cases.\r\n      if ( !text1 ||\r\n        !text2 ||\r\n        text1.charAt( text1.length - 1 ) !== text2.charAt( text2.length - 1 ) ) {\r\n        return 0;\r\n      }\r\n\r\n      // Binary search.\r\n      // Performance analysis: https://neil.fraser.name/news/2007/10/09/\r\n      pointermin = 0;\r\n      pointermax = Math.min( text1.length, text2.length );\r\n      pointermid = pointermax;\r\n      pointerend = 0;\r\n      while ( pointermin < pointermid ) {\r\n        if ( text1.substring( text1.length - pointermid, text1.length - pointerend ) ===\r\n          text2.substring( text2.length - pointermid, text2.length - pointerend ) ) {\r\n          pointermin = pointermid;\r\n          pointerend = pointermin;\r\n        } else {\r\n          pointermax = pointermid;\r\n        }\r\n        pointermid = Math.floor( ( pointermax - pointermin ) / 2 + pointermin );\r\n      }\r\n      return pointermid;\r\n    };\r\n\r\n    /**\r\n     * Find the differences between two texts.  Assumes that the texts do not\r\n     * have any common prefix or suffix.\r\n     * @param {string} text1 Old string to be diffed.\r\n     * @param {string} text2 New string to be diffed.\r\n     * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n     *     line-level diff first to identify the changed areas.\r\n     *     If true, then run a faster, slightly less optimal diff.\r\n     * @param {number} deadline Time when the diff should be complete by.\r\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffCompute = function( text1, text2, checklines, deadline ) {\r\n      var diffs, longtext, shorttext, i, hm,\r\n        text1A, text2A, text1B, text2B,\r\n        midCommon, diffsA, diffsB;\r\n\r\n      if ( !text1 ) {\r\n\r\n        // Just add some text (speedup).\r\n        return [\r\n          [ DIFF_INSERT, text2 ]\r\n        ];\r\n      }\r\n\r\n      if ( !text2 ) {\r\n\r\n        // Just delete some text (speedup).\r\n        return [\r\n          [ DIFF_DELETE, text1 ]\r\n        ];\r\n      }\r\n\r\n      longtext = text1.length > text2.length ? text1 : text2;\r\n      shorttext = text1.length > text2.length ? text2 : text1;\r\n      i = longtext.indexOf( shorttext );\r\n      if ( i !== -1 ) {\r\n\r\n        // Shorter text is inside the longer text (speedup).\r\n        diffs = [\r\n          [ DIFF_INSERT, longtext.substring( 0, i ) ],\r\n          [ DIFF_EQUAL, shorttext ],\r\n          [ DIFF_INSERT, longtext.substring( i + shorttext.length ) ]\r\n        ];\r\n\r\n        // Swap insertions for deletions if diff is reversed.\r\n        if ( text1.length > text2.length ) {\r\n          diffs[ 0 ][ 0 ] = diffs[ 2 ][ 0 ] = DIFF_DELETE;\r\n        }\r\n        return diffs;\r\n      }\r\n\r\n      if ( shorttext.length === 1 ) {\r\n\r\n        // Single character string.\r\n        // After the previous speedup, the character can't be an equality.\r\n        return [\r\n          [ DIFF_DELETE, text1 ],\r\n          [ DIFF_INSERT, text2 ]\r\n        ];\r\n      }\r\n\r\n      // Check to see if the problem can be split in two.\r\n      hm = this.diffHalfMatch( text1, text2 );\r\n      if ( hm ) {\r\n\r\n        // A half-match was found, sort out the return data.\r\n        text1A = hm[ 0 ];\r\n        text1B = hm[ 1 ];\r\n        text2A = hm[ 2 ];\r\n        text2B = hm[ 3 ];\r\n        midCommon = hm[ 4 ];\r\n\r\n        // Send both pairs off for separate processing.\r\n        diffsA = this.DiffMain( text1A, text2A, checklines, deadline );\r\n        diffsB = this.DiffMain( text1B, text2B, checklines, deadline );\r\n\r\n        // Merge the results.\r\n        return diffsA.concat( [\r\n          [ DIFF_EQUAL, midCommon ]\r\n        ], diffsB );\r\n      }\r\n\r\n      if ( checklines && text1.length > 100 && text2.length > 100 ) {\r\n        return this.diffLineMode( text1, text2, deadline );\r\n      }\r\n\r\n      return this.diffBisect( text1, text2, deadline );\r\n    };\r\n\r\n    /**\r\n     * Do the two texts share a substring which is at least half the length of the\r\n     * longer text?\r\n     * This speedup can produce non-minimal diffs.\r\n     * @param {string} text1 First string.\r\n     * @param {string} text2 Second string.\r\n     * @return {Array.<string>} Five element Array, containing the prefix of\r\n     *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n     *     text2 and the common middle.  Or null if there was no match.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffHalfMatch = function( text1, text2 ) {\r\n      var longtext, shorttext, dmp,\r\n        text1A, text2B, text2A, text1B, midCommon,\r\n        hm1, hm2, hm;\r\n\r\n      longtext = text1.length > text2.length ? text1 : text2;\r\n      shorttext = text1.length > text2.length ? text2 : text1;\r\n      if ( longtext.length < 4 || shorttext.length * 2 < longtext.length ) {\r\n        return null; // Pointless.\r\n      }\r\n      dmp = this; // 'this' becomes 'window' in a closure.\r\n\r\n      /**\r\n       * Does a substring of shorttext exist within longtext such that the substring\r\n       * is at least half the length of longtext?\r\n       * Closure, but does not reference any external variables.\r\n       * @param {string} longtext Longer string.\r\n       * @param {string} shorttext Shorter string.\r\n       * @param {number} i Start index of quarter length substring within longtext.\r\n       * @return {Array.<string>} Five element Array, containing the prefix of\r\n       *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n       *     of shorttext and the common middle.  Or null if there was no match.\r\n       * @private\r\n       */\r\n      function diffHalfMatchI( longtext, shorttext, i ) {\r\n        var seed, j, bestCommon, prefixLength, suffixLength,\r\n          bestLongtextA, bestLongtextB, bestShorttextA, bestShorttextB;\r\n\r\n        // Start with a 1/4 length substring at position i as a seed.\r\n        seed = longtext.substring( i, i + Math.floor( longtext.length / 4 ) );\r\n        j = -1;\r\n        bestCommon = \"\";\r\n        while ( ( j = shorttext.indexOf( seed, j + 1 ) ) !== -1 ) {\r\n          prefixLength = dmp.diffCommonPrefix( longtext.substring( i ),\r\n            shorttext.substring( j ) );\r\n          suffixLength = dmp.diffCommonSuffix( longtext.substring( 0, i ),\r\n            shorttext.substring( 0, j ) );\r\n          if ( bestCommon.length < suffixLength + prefixLength ) {\r\n            bestCommon = shorttext.substring( j - suffixLength, j ) +\r\n              shorttext.substring( j, j + prefixLength );\r\n            bestLongtextA = longtext.substring( 0, i - suffixLength );\r\n            bestLongtextB = longtext.substring( i + prefixLength );\r\n            bestShorttextA = shorttext.substring( 0, j - suffixLength );\r\n            bestShorttextB = shorttext.substring( j + prefixLength );\r\n          }\r\n        }\r\n        if ( bestCommon.length * 2 >= longtext.length ) {\r\n          return [ bestLongtextA, bestLongtextB,\r\n            bestShorttextA, bestShorttextB, bestCommon\r\n          ];\r\n        } else {\r\n          return null;\r\n        }\r\n      }\r\n\r\n      // First check if the second quarter is the seed for a half-match.\r\n      hm1 = diffHalfMatchI( longtext, shorttext,\r\n        Math.ceil( longtext.length / 4 ) );\r\n\r\n      // Check again based on the third quarter.\r\n      hm2 = diffHalfMatchI( longtext, shorttext,\r\n        Math.ceil( longtext.length / 2 ) );\r\n      if ( !hm1 && !hm2 ) {\r\n        return null;\r\n      } else if ( !hm2 ) {\r\n        hm = hm1;\r\n      } else if ( !hm1 ) {\r\n        hm = hm2;\r\n      } else {\r\n\r\n        // Both matched.  Select the longest.\r\n        hm = hm1[ 4 ].length > hm2[ 4 ].length ? hm1 : hm2;\r\n      }\r\n\r\n      // A half-match was found, sort out the return data.\r\n      text1A, text1B, text2A, text2B;\r\n      if ( text1.length > text2.length ) {\r\n        text1A = hm[ 0 ];\r\n        text1B = hm[ 1 ];\r\n        text2A = hm[ 2 ];\r\n        text2B = hm[ 3 ];\r\n      } else {\r\n        text2A = hm[ 0 ];\r\n        text2B = hm[ 1 ];\r\n        text1A = hm[ 2 ];\r\n        text1B = hm[ 3 ];\r\n      }\r\n      midCommon = hm[ 4 ];\r\n      return [ text1A, text1B, text2A, text2B, midCommon ];\r\n    };\r\n\r\n    /**\r\n     * Do a quick line-level diff on both strings, then rediff the parts for\r\n     * greater accuracy.\r\n     * This speedup can produce non-minimal diffs.\r\n     * @param {string} text1 Old string to be diffed.\r\n     * @param {string} text2 New string to be diffed.\r\n     * @param {number} deadline Time when the diff should be complete by.\r\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffLineMode = function( text1, text2, deadline ) {\r\n      var a, diffs, linearray, pointer, countInsert,\r\n        countDelete, textInsert, textDelete, j;\r\n\r\n      // Scan the text on a line-by-line basis first.\r\n      a = this.diffLinesToChars( text1, text2 );\r\n      text1 = a.chars1;\r\n      text2 = a.chars2;\r\n      linearray = a.lineArray;\r\n\r\n      diffs = this.DiffMain( text1, text2, false, deadline );\r\n\r\n      // Convert the diff back to original text.\r\n      this.diffCharsToLines( diffs, linearray );\r\n\r\n      // Eliminate freak matches (e.g. blank lines)\r\n      this.diffCleanupSemantic( diffs );\r\n\r\n      // Rediff any replacement blocks, this time character-by-character.\r\n      // Add a dummy entry at the end.\r\n      diffs.push( [ DIFF_EQUAL, \"\" ] );\r\n      pointer = 0;\r\n      countDelete = 0;\r\n      countInsert = 0;\r\n      textDelete = \"\";\r\n      textInsert = \"\";\r\n      while ( pointer < diffs.length ) {\r\n        switch ( diffs[ pointer ][ 0 ] ) {\r\n          case DIFF_INSERT:\r\n            countInsert++;\r\n            textInsert += diffs[ pointer ][ 1 ];\r\n            break;\r\n          case DIFF_DELETE:\r\n            countDelete++;\r\n            textDelete += diffs[ pointer ][ 1 ];\r\n            break;\r\n          case DIFF_EQUAL:\r\n\r\n            // Upon reaching an equality, check for prior redundancies.\r\n            if ( countDelete >= 1 && countInsert >= 1 ) {\r\n\r\n              // Delete the offending records and add the merged ones.\r\n              diffs.splice( pointer - countDelete - countInsert,\r\n                countDelete + countInsert );\r\n              pointer = pointer - countDelete - countInsert;\r\n              a = this.DiffMain( textDelete, textInsert, false, deadline );\r\n              for ( j = a.length - 1; j >= 0; j-- ) {\r\n                diffs.splice( pointer, 0, a[ j ] );\r\n              }\r\n              pointer = pointer + a.length;\r\n            }\r\n            countInsert = 0;\r\n            countDelete = 0;\r\n            textDelete = \"\";\r\n            textInsert = \"\";\r\n            break;\r\n        }\r\n        pointer++;\r\n      }\r\n      diffs.pop(); // Remove the dummy entry at the end.\r\n\r\n      return diffs;\r\n    };\r\n\r\n    /**\r\n     * Find the 'middle snake' of a diff, split the problem in two\r\n     * and return the recursively constructed diff.\r\n     * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\r\n     * @param {string} text1 Old string to be diffed.\r\n     * @param {string} text2 New string to be diffed.\r\n     * @param {number} deadline Time at which to bail if not yet complete.\r\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffBisect = function( text1, text2, deadline ) {\r\n      var text1Length, text2Length, maxD, vOffset, vLength,\r\n        v1, v2, x, delta, front, k1start, k1end, k2start,\r\n        k2end, k2Offset, k1Offset, x1, x2, y1, y2, d, k1, k2;\r\n\r\n      // Cache the text lengths to prevent multiple calls.\r\n      text1Length = text1.length;\r\n      text2Length = text2.length;\r\n      maxD = Math.ceil( ( text1Length + text2Length ) / 2 );\r\n      vOffset = maxD;\r\n      vLength = 2 * maxD;\r\n      v1 = new Array( vLength );\r\n      v2 = new Array( vLength );\r\n\r\n      // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n      // integers and undefined.\r\n      for ( x = 0; x < vLength; x++ ) {\r\n        v1[ x ] = -1;\r\n        v2[ x ] = -1;\r\n      }\r\n      v1[ vOffset + 1 ] = 0;\r\n      v2[ vOffset + 1 ] = 0;\r\n      delta = text1Length - text2Length;\r\n\r\n      // If the total number of characters is odd, then the front path will collide\r\n      // with the reverse path.\r\n      front = ( delta % 2 !== 0 );\r\n\r\n      // Offsets for start and end of k loop.\r\n      // Prevents mapping of space beyond the grid.\r\n      k1start = 0;\r\n      k1end = 0;\r\n      k2start = 0;\r\n      k2end = 0;\r\n      for ( d = 0; d < maxD; d++ ) {\r\n\r\n        // Bail out if deadline is reached.\r\n        if ( ( new Date() ).getTime() > deadline ) {\r\n          break;\r\n        }\r\n\r\n        // Walk the front path one step.\r\n        for ( k1 = -d + k1start; k1 <= d - k1end; k1 += 2 ) {\r\n          k1Offset = vOffset + k1;\r\n          if ( k1 === -d || ( k1 !== d && v1[ k1Offset - 1 ] < v1[ k1Offset + 1 ] ) ) {\r\n            x1 = v1[ k1Offset + 1 ];\r\n          } else {\r\n            x1 = v1[ k1Offset - 1 ] + 1;\r\n          }\r\n          y1 = x1 - k1;\r\n          while ( x1 < text1Length && y1 < text2Length &&\r\n          text1.charAt( x1 ) === text2.charAt( y1 ) ) {\r\n            x1++;\r\n            y1++;\r\n          }\r\n          v1[ k1Offset ] = x1;\r\n          if ( x1 > text1Length ) {\r\n\r\n            // Ran off the right of the graph.\r\n            k1end += 2;\r\n          } else if ( y1 > text2Length ) {\r\n\r\n            // Ran off the bottom of the graph.\r\n            k1start += 2;\r\n          } else if ( front ) {\r\n            k2Offset = vOffset + delta - k1;\r\n            if ( k2Offset >= 0 && k2Offset < vLength && v2[ k2Offset ] !== -1 ) {\r\n\r\n              // Mirror x2 onto top-left coordinate system.\r\n              x2 = text1Length - v2[ k2Offset ];\r\n              if ( x1 >= x2 ) {\r\n\r\n                // Overlap detected.\r\n                return this.diffBisectSplit( text1, text2, x1, y1, deadline );\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        // Walk the reverse path one step.\r\n        for ( k2 = -d + k2start; k2 <= d - k2end; k2 += 2 ) {\r\n          k2Offset = vOffset + k2;\r\n          if ( k2 === -d || ( k2 !== d && v2[ k2Offset - 1 ] < v2[ k2Offset + 1 ] ) ) {\r\n            x2 = v2[ k2Offset + 1 ];\r\n          } else {\r\n            x2 = v2[ k2Offset - 1 ] + 1;\r\n          }\r\n          y2 = x2 - k2;\r\n          while ( x2 < text1Length && y2 < text2Length &&\r\n          text1.charAt( text1Length - x2 - 1 ) ===\r\n          text2.charAt( text2Length - y2 - 1 ) ) {\r\n            x2++;\r\n            y2++;\r\n          }\r\n          v2[ k2Offset ] = x2;\r\n          if ( x2 > text1Length ) {\r\n\r\n            // Ran off the left of the graph.\r\n            k2end += 2;\r\n          } else if ( y2 > text2Length ) {\r\n\r\n            // Ran off the top of the graph.\r\n            k2start += 2;\r\n          } else if ( !front ) {\r\n            k1Offset = vOffset + delta - k2;\r\n            if ( k1Offset >= 0 && k1Offset < vLength && v1[ k1Offset ] !== -1 ) {\r\n              x1 = v1[ k1Offset ];\r\n              y1 = vOffset + x1 - k1Offset;\r\n\r\n              // Mirror x2 onto top-left coordinate system.\r\n              x2 = text1Length - x2;\r\n              if ( x1 >= x2 ) {\r\n\r\n                // Overlap detected.\r\n                return this.diffBisectSplit( text1, text2, x1, y1, deadline );\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Diff took too long and hit the deadline or\r\n      // number of diffs equals number of characters, no commonality at all.\r\n      return [\r\n        [ DIFF_DELETE, text1 ],\r\n        [ DIFF_INSERT, text2 ]\r\n      ];\r\n    };\r\n\r\n    /**\r\n     * Given the location of the 'middle snake', split the diff in two parts\r\n     * and recurse.\r\n     * @param {string} text1 Old string to be diffed.\r\n     * @param {string} text2 New string to be diffed.\r\n     * @param {number} x Index of split point in text1.\r\n     * @param {number} y Index of split point in text2.\r\n     * @param {number} deadline Time at which to bail if not yet complete.\r\n     * @return {!Array.<!DiffMatchPatch.Diff>} Array of diff tuples.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffBisectSplit = function( text1, text2, x, y, deadline ) {\r\n      var text1a, text1b, text2a, text2b, diffs, diffsb;\r\n      text1a = text1.substring( 0, x );\r\n      text2a = text2.substring( 0, y );\r\n      text1b = text1.substring( x );\r\n      text2b = text2.substring( y );\r\n\r\n      // Compute both diffs serially.\r\n      diffs = this.DiffMain( text1a, text2a, false, deadline );\r\n      diffsb = this.DiffMain( text1b, text2b, false, deadline );\r\n\r\n      return diffs.concat( diffsb );\r\n    };\r\n\r\n    /**\r\n     * Reduce the number of edits by eliminating semantically trivial equalities.\r\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\r\n     */\r\n    DiffMatchPatch.prototype.diffCleanupSemantic = function( diffs ) {\r\n      var changes, equalities, equalitiesLength, lastequality,\r\n        pointer, lengthInsertions2, lengthDeletions2, lengthInsertions1,\r\n        lengthDeletions1, deletion, insertion, overlapLength1, overlapLength2;\r\n      changes = false;\r\n      equalities = []; // Stack of indices where equalities are found.\r\n      equalitiesLength = 0; // Keeping our own length var is faster in JS.\r\n      /** @type {?string} */\r\n      lastequality = null;\r\n\r\n      // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n      pointer = 0; // Index of current position.\r\n\r\n      // Number of characters that changed prior to the equality.\r\n      lengthInsertions1 = 0;\r\n      lengthDeletions1 = 0;\r\n\r\n      // Number of characters that changed after the equality.\r\n      lengthInsertions2 = 0;\r\n      lengthDeletions2 = 0;\r\n      while ( pointer < diffs.length ) {\r\n        if ( diffs[ pointer ][ 0 ] === DIFF_EQUAL ) { // Equality found.\r\n          equalities[ equalitiesLength++ ] = pointer;\r\n          lengthInsertions1 = lengthInsertions2;\r\n          lengthDeletions1 = lengthDeletions2;\r\n          lengthInsertions2 = 0;\r\n          lengthDeletions2 = 0;\r\n          lastequality = diffs[ pointer ][ 1 ];\r\n        } else { // An insertion or deletion.\r\n          if ( diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\r\n            lengthInsertions2 += diffs[ pointer ][ 1 ].length;\r\n          } else {\r\n            lengthDeletions2 += diffs[ pointer ][ 1 ].length;\r\n          }\r\n\r\n          // Eliminate an equality that is smaller or equal to the edits on both\r\n          // sides of it.\r\n          if ( lastequality && ( lastequality.length <=\r\n            Math.max( lengthInsertions1, lengthDeletions1 ) ) &&\r\n            ( lastequality.length <= Math.max( lengthInsertions2,\r\n              lengthDeletions2 ) ) ) {\r\n\r\n            // Duplicate record.\r\n            diffs.splice(\r\n              equalities[ equalitiesLength - 1 ],\r\n              0,\r\n              [ DIFF_DELETE, lastequality ]\r\n            );\r\n\r\n            // Change second copy to insert.\r\n            diffs[ equalities[ equalitiesLength - 1 ] + 1 ][ 0 ] = DIFF_INSERT;\r\n\r\n            // Throw away the equality we just deleted.\r\n            equalitiesLength--;\r\n\r\n            // Throw away the previous equality (it needs to be reevaluated).\r\n            equalitiesLength--;\r\n            pointer = equalitiesLength > 0 ? equalities[ equalitiesLength - 1 ] : -1;\r\n\r\n            // Reset the counters.\r\n            lengthInsertions1 = 0;\r\n            lengthDeletions1 = 0;\r\n            lengthInsertions2 = 0;\r\n            lengthDeletions2 = 0;\r\n            lastequality = null;\r\n            changes = true;\r\n          }\r\n        }\r\n        pointer++;\r\n      }\r\n\r\n      // Normalize the diff.\r\n      if ( changes ) {\r\n        this.diffCleanupMerge( diffs );\r\n      }\r\n\r\n      // Find any overlaps between deletions and insertions.\r\n      // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n      //   -> <del>abc</del>xxx<ins>def</ins>\r\n      // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n      //   -> <ins>def</ins>xxx<del>abc</del>\r\n      // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n      pointer = 1;\r\n      while ( pointer < diffs.length ) {\r\n        if ( diffs[ pointer - 1 ][ 0 ] === DIFF_DELETE &&\r\n          diffs[ pointer ][ 0 ] === DIFF_INSERT ) {\r\n          deletion = diffs[ pointer - 1 ][ 1 ];\r\n          insertion = diffs[ pointer ][ 1 ];\r\n          overlapLength1 = this.diffCommonOverlap( deletion, insertion );\r\n          overlapLength2 = this.diffCommonOverlap( insertion, deletion );\r\n          if ( overlapLength1 >= overlapLength2 ) {\r\n            if ( overlapLength1 >= deletion.length / 2 ||\r\n              overlapLength1 >= insertion.length / 2 ) {\r\n\r\n              // Overlap found.  Insert an equality and trim the surrounding edits.\r\n              diffs.splice(\r\n                pointer,\r\n                0,\r\n                [ DIFF_EQUAL, insertion.substring( 0, overlapLength1 ) ]\r\n              );\r\n              diffs[ pointer - 1 ][ 1 ] =\r\n                deletion.substring( 0, deletion.length - overlapLength1 );\r\n              diffs[ pointer + 1 ][ 1 ] = insertion.substring( overlapLength1 );\r\n              pointer++;\r\n            }\r\n          } else {\r\n            if ( overlapLength2 >= deletion.length / 2 ||\r\n              overlapLength2 >= insertion.length / 2 ) {\r\n\r\n              // Reverse overlap found.\r\n              // Insert an equality and swap and trim the surrounding edits.\r\n              diffs.splice(\r\n                pointer,\r\n                0,\r\n                [ DIFF_EQUAL, deletion.substring( 0, overlapLength2 ) ]\r\n              );\r\n\r\n              diffs[ pointer - 1 ][ 0 ] = DIFF_INSERT;\r\n              diffs[ pointer - 1 ][ 1 ] =\r\n                insertion.substring( 0, insertion.length - overlapLength2 );\r\n              diffs[ pointer + 1 ][ 0 ] = DIFF_DELETE;\r\n              diffs[ pointer + 1 ][ 1 ] =\r\n                deletion.substring( overlapLength2 );\r\n              pointer++;\r\n            }\r\n          }\r\n          pointer++;\r\n        }\r\n        pointer++;\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Determine if the suffix of one string is the prefix of another.\r\n     * @param {string} text1 First string.\r\n     * @param {string} text2 Second string.\r\n     * @return {number} The number of characters common to the end of the first\r\n     *     string and the start of the second string.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffCommonOverlap = function( text1, text2 ) {\r\n      var text1Length, text2Length, textLength,\r\n        best, length, pattern, found;\r\n\r\n      // Cache the text lengths to prevent multiple calls.\r\n      text1Length = text1.length;\r\n      text2Length = text2.length;\r\n\r\n      // Eliminate the null case.\r\n      if ( text1Length === 0 || text2Length === 0 ) {\r\n        return 0;\r\n      }\r\n\r\n      // Truncate the longer string.\r\n      if ( text1Length > text2Length ) {\r\n        text1 = text1.substring( text1Length - text2Length );\r\n      } else if ( text1Length < text2Length ) {\r\n        text2 = text2.substring( 0, text1Length );\r\n      }\r\n      textLength = Math.min( text1Length, text2Length );\r\n\r\n      // Quick check for the worst case.\r\n      if ( text1 === text2 ) {\r\n        return textLength;\r\n      }\r\n\r\n      // Start by looking for a single character match\r\n      // and increase length until no match is found.\r\n      // Performance analysis: https://neil.fraser.name/news/2010/11/04/\r\n      best = 0;\r\n      length = 1;\r\n      while ( true ) {\r\n        pattern = text1.substring( textLength - length );\r\n        found = text2.indexOf( pattern );\r\n        if ( found === -1 ) {\r\n          return best;\r\n        }\r\n        length += found;\r\n        if ( found === 0 || text1.substring( textLength - length ) ===\r\n          text2.substring( 0, length ) ) {\r\n          best = length;\r\n          length++;\r\n        }\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Split two texts into an array of strings.  Reduce the texts to a string of\r\n     * hashes where each Unicode character represents one line.\r\n     * @param {string} text1 First string.\r\n     * @param {string} text2 Second string.\r\n     * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n     *     An object containing the encoded text1, the encoded text2 and\r\n     *     the array of unique strings.\r\n     *     The zeroth element of the array of unique strings is intentionally blank.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffLinesToChars = function( text1, text2 ) {\r\n      var lineArray, lineHash, chars1, chars2;\r\n      lineArray = []; // E.g. lineArray[4] === 'Hello\\n'\r\n      lineHash = {};  // E.g. lineHash['Hello\\n'] === 4\r\n\r\n      // '\\x00' is a valid character, but various debuggers don't like it.\r\n      // So we'll insert a junk entry to avoid generating a null character.\r\n      lineArray[ 0 ] = \"\";\r\n\r\n      /**\r\n       * Split a text into an array of strings.  Reduce the texts to a string of\r\n       * hashes where each Unicode character represents one line.\r\n       * Modifies linearray and linehash through being a closure.\r\n       * @param {string} text String to encode.\r\n       * @return {string} Encoded string.\r\n       * @private\r\n       */\r\n      function diffLinesToCharsMunge( text ) {\r\n        var chars, lineStart, lineEnd, lineArrayLength, line;\r\n        chars = \"\";\r\n\r\n        // Walk the text, pulling out a substring for each line.\r\n        // text.split('\\n') would would temporarily double our memory footprint.\r\n        // Modifying text would create many large strings to garbage collect.\r\n        lineStart = 0;\r\n        lineEnd = -1;\r\n\r\n        // Keeping our own length variable is faster than looking it up.\r\n        lineArrayLength = lineArray.length;\r\n        while ( lineEnd < text.length - 1 ) {\r\n          lineEnd = text.indexOf( \"\\n\", lineStart );\r\n          if ( lineEnd === -1 ) {\r\n            lineEnd = text.length - 1;\r\n          }\r\n          line = text.substring( lineStart, lineEnd + 1 );\r\n          lineStart = lineEnd + 1;\r\n\r\n          if ( lineHash.hasOwnProperty ? lineHash.hasOwnProperty( line ) :\r\n            ( lineHash[ line ] !== undefined ) ) {\r\n            chars += String.fromCharCode( lineHash[ line ] );\r\n          } else {\r\n            chars += String.fromCharCode( lineArrayLength );\r\n            lineHash[ line ] = lineArrayLength;\r\n            lineArray[ lineArrayLength++ ] = line;\r\n          }\r\n        }\r\n        return chars;\r\n      }\r\n\r\n      chars1 = diffLinesToCharsMunge( text1 );\r\n      chars2 = diffLinesToCharsMunge( text2 );\r\n      return {\r\n        chars1: chars1,\r\n        chars2: chars2,\r\n        lineArray: lineArray\r\n      };\r\n    };\r\n\r\n    /**\r\n     * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n     * text.\r\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\r\n     * @param {!Array.<string>} lineArray Array of unique strings.\r\n     * @private\r\n     */\r\n    DiffMatchPatch.prototype.diffCharsToLines = function( diffs, lineArray ) {\r\n      var x, chars, text, y;\r\n      for ( x = 0; x < diffs.length; x++ ) {\r\n        chars = diffs[ x ][ 1 ];\r\n        text = [];\r\n        for ( y = 0; y < chars.length; y++ ) {\r\n          text[ y ] = lineArray[ chars.charCodeAt( y ) ];\r\n        }\r\n        diffs[ x ][ 1 ] = text.join( \"\" );\r\n      }\r\n    };\r\n\r\n    /**\r\n     * Reorder and merge like edit sections.  Merge equalities.\r\n     * Any edit section can move as long as it doesn't cross an equality.\r\n     * @param {!Array.<!DiffMatchPatch.Diff>} diffs Array of diff tuples.\r\n     */\r\n    DiffMatchPatch.prototype.diffCleanupMerge = function( diffs ) {\r\n      var pointer, countDelete, countInsert, textInsert, textDelete,\r\n        commonlength, changes, diffPointer, position;\r\n      diffs.push( [ DIFF_EQUAL, \"\" ] ); // Add a dummy entry at the end.\r\n      pointer = 0;\r\n      countDelete = 0;\r\n      countInsert = 0;\r\n      textDelete = \"\";\r\n      textInsert = \"\";\r\n      commonlength;\r\n      while ( pointer < diffs.length ) {\r\n        switch ( diffs[ pointer ][ 0 ] ) {\r\n          case DIFF_INSERT:\r\n            countInsert++;\r\n            textInsert += diffs[ pointer ][ 1 ];\r\n            pointer++;\r\n            break;\r\n          case DIFF_DELETE:\r\n            countDelete++;\r\n            textDelete += diffs[ pointer ][ 1 ];\r\n            pointer++;\r\n            break;\r\n          case DIFF_EQUAL:\r\n\r\n            // Upon reaching an equality, check for prior redundancies.\r\n            if ( countDelete + countInsert > 1 ) {\r\n              if ( countDelete !== 0 && countInsert !== 0 ) {\r\n\r\n                // Factor out any common prefixes.\r\n                commonlength = this.diffCommonPrefix( textInsert, textDelete );\r\n                if ( commonlength !== 0 ) {\r\n                  if ( ( pointer - countDelete - countInsert ) > 0 &&\r\n                    diffs[ pointer - countDelete - countInsert - 1 ][ 0 ] ===\r\n                    DIFF_EQUAL ) {\r\n                    diffs[ pointer - countDelete - countInsert - 1 ][ 1 ] +=\r\n                      textInsert.substring( 0, commonlength );\r\n                  } else {\r\n                    diffs.splice( 0, 0, [ DIFF_EQUAL,\r\n                      textInsert.substring( 0, commonlength )\r\n                    ] );\r\n                    pointer++;\r\n                  }\r\n                  textInsert = textInsert.substring( commonlength );\r\n                  textDelete = textDelete.substring( commonlength );\r\n                }\r\n\r\n                // Factor out any common suffixies.\r\n                commonlength = this.diffCommonSuffix( textInsert, textDelete );\r\n                if ( commonlength !== 0 ) {\r\n                  diffs[ pointer ][ 1 ] = textInsert.substring( textInsert.length -\r\n                    commonlength ) + diffs[ pointer ][ 1 ];\r\n                  textInsert = textInsert.substring( 0, textInsert.length -\r\n                    commonlength );\r\n                  textDelete = textDelete.substring( 0, textDelete.length -\r\n                    commonlength );\r\n                }\r\n              }\r\n\r\n              // Delete the offending records and add the merged ones.\r\n              if ( countDelete === 0 ) {\r\n                diffs.splice( pointer - countInsert,\r\n                  countDelete + countInsert, [ DIFF_INSERT, textInsert ] );\r\n              } else if ( countInsert === 0 ) {\r\n                diffs.splice( pointer - countDelete,\r\n                  countDelete + countInsert, [ DIFF_DELETE, textDelete ] );\r\n              } else {\r\n                diffs.splice(\r\n                  pointer - countDelete - countInsert,\r\n                  countDelete + countInsert,\r\n                  [ DIFF_DELETE, textDelete ], [ DIFF_INSERT, textInsert ]\r\n                );\r\n              }\r\n              pointer = pointer - countDelete - countInsert +\r\n                ( countDelete ? 1 : 0 ) + ( countInsert ? 1 : 0 ) + 1;\r\n            } else if ( pointer !== 0 && diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL ) {\r\n\r\n              // Merge this equality with the previous one.\r\n              diffs[ pointer - 1 ][ 1 ] += diffs[ pointer ][ 1 ];\r\n              diffs.splice( pointer, 1 );\r\n            } else {\r\n              pointer++;\r\n            }\r\n            countInsert = 0;\r\n            countDelete = 0;\r\n            textDelete = \"\";\r\n            textInsert = \"\";\r\n            break;\r\n        }\r\n      }\r\n      if ( diffs[ diffs.length - 1 ][ 1 ] === \"\" ) {\r\n        diffs.pop(); // Remove the dummy entry at the end.\r\n      }\r\n\r\n      // Second pass: look for single edits surrounded on both sides by equalities\r\n      // which can be shifted sideways to eliminate an equality.\r\n      // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n      changes = false;\r\n      pointer = 1;\r\n\r\n      // Intentionally ignore the first and last element (don't need checking).\r\n      while ( pointer < diffs.length - 1 ) {\r\n        if ( diffs[ pointer - 1 ][ 0 ] === DIFF_EQUAL &&\r\n          diffs[ pointer + 1 ][ 0 ] === DIFF_EQUAL ) {\r\n\r\n          diffPointer = diffs[ pointer ][ 1 ];\r\n          position = diffPointer.substring(\r\n            diffPointer.length - diffs[ pointer - 1 ][ 1 ].length\r\n          );\r\n\r\n          // This is a single edit surrounded by equalities.\r\n          if ( position === diffs[ pointer - 1 ][ 1 ] ) {\r\n\r\n            // Shift the edit over the previous equality.\r\n            diffs[ pointer ][ 1 ] = diffs[ pointer - 1 ][ 1 ] +\r\n              diffs[ pointer ][ 1 ].substring( 0, diffs[ pointer ][ 1 ].length -\r\n                diffs[ pointer - 1 ][ 1 ].length );\r\n            diffs[ pointer + 1 ][ 1 ] =\r\n              diffs[ pointer - 1 ][ 1 ] + diffs[ pointer + 1 ][ 1 ];\r\n            diffs.splice( pointer - 1, 1 );\r\n            changes = true;\r\n          } else if ( diffPointer.substring( 0, diffs[ pointer + 1 ][ 1 ].length ) ===\r\n            diffs[ pointer + 1 ][ 1 ] ) {\r\n\r\n            // Shift the edit over the next equality.\r\n            diffs[ pointer - 1 ][ 1 ] += diffs[ pointer + 1 ][ 1 ];\r\n            diffs[ pointer ][ 1 ] =\r\n              diffs[ pointer ][ 1 ].substring( diffs[ pointer + 1 ][ 1 ].length ) +\r\n              diffs[ pointer + 1 ][ 1 ];\r\n            diffs.splice( pointer + 1, 1 );\r\n            changes = true;\r\n          }\r\n        }\r\n        pointer++;\r\n      }\r\n\r\n      // If shifts were made, the diff needs reordering and another shift sweep.\r\n      if ( changes ) {\r\n        this.diffCleanupMerge( diffs );\r\n      }\r\n    };\r\n\r\n    return function( o, n ) {\r\n      var diff, output, text;\r\n      diff = new DiffMatchPatch();\r\n      output = diff.DiffMain( o, n );\r\n      diff.diffCleanupEfficiency( output );\r\n      text = diff.diffPrettyHtml( output );\r\n\r\n      return text;\r\n    };\r\n  }() );\r\n\r\n}() );\r\n\r\nPATH_ROOT = [0];\r\nPOST_ORDER = \"POST_ORDER\";\r\nPRE_ORDER = \"PRE_ORDER\";\r\nBFS = \"BFS\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    let traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    let traversalStateChild = traversalState.get(subTreeChild);\r\n    let currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nfunction visitTree(traversalSpecs, tree) {\r\n  let { store, lenses, traverse } = traversalSpecs;\r\n  let { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  let { getChildren, getLabel, setTree } = lenses;\r\n  let { visit, seed: seedOrSeedConstructor } = traverse;\r\n  let traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  let seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  let empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  // necessary to avoid destructive updates on input parameters\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    let subTree = takeAndRemoveOne(currentStore);\r\n    let subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nfunction breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  let { getChildren } = lenses;\r\n  let traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nfunction preorderTraverseTree(lenses, traverse, tree) {\r\n  let { getChildren } = lenses;\r\n  let traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nfunction postOrderTraverseTree(lenses, traverse, tree) {\r\n  let { getChildren } = lenses;\r\n  let isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  let { seed, visit } = traverse;\r\n  let predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  let decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat(tree)\r\n  };\r\n  let traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        if (predicate(tree, traversalState)) {\r\n          visit(result, traversalState, tree);\r\n        }\r\n\r\n        return result;\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nfunction reduceTree(lenses, traverse, tree) {\r\n  let strategy = traverse.strategy;\r\n  let strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nfunction forEachInTree(lenses, traverse, tree) {\r\n  let { strategy, action } = traverse;\r\n\r\n  let strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  let treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, setChildren : function, setLabel : function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nfunction mapOverTree(lenses, mapFn, tree) {\r\n  let { getChildren, constructTree, getLabel } = lenses;\r\n  let getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  let stringify = path => path.join(\".\");\r\n  let treeTraveerse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      let { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      let mappedLabel = mapFn(getLabel(tree));\r\n      let mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      let mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  let pathMap = postOrderTraverseTree(lenses, treeTraveerse, tree);\r\n  let mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nfunction pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  let { getChildren } = lenses;\r\n  let pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  let prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\nQUnit.module(\"Testing tree traversal\", {});\r\n\r\n\r\nQUnit.test(\"main case - hashed-tree traversal - map over\", function exec_test(assert) {\r\n  const traces = [];\r\n  const sep = '.';\r\n\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  function makeParentCursor(childCursor, sep) {\r\n    // remove the last element\r\n    // NOTE : edge case where there is no parent (i.e. childCursor is root) should not happen\r\n    // by property of the traversal algorithm?\r\n    return childCursor.split(sep).splice(-1, 1)\r\n  }\r\n\r\n  const lenses = {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label : hash[cursor], hash, cursor}\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        debugger\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      // CONTRACT : all children should have the same parent, i.e. x.0, x.1, x.2 etc.\r\n      // TODO : test mapOver\r\n      const { label : value, hash, cursor} = label;\r\n      const parentCursor = makeParentCursor(cursor, sep);\r\n\r\n      return {\r\n        cursor: parentCursor,\r\n        hash\r\n      }\r\n    },\r\n  };\r\n\r\n  const hash = {\r\n    \"0\": \"root\",\r\n    \"0.0\": \"combinatorName\",\r\n    \"0.1\": \"componentName\",\r\n    \"0.2\": \"emits\",\r\n    \"0.3\": \"id\",\r\n    \"0.4\": \"logType\",\r\n    \"0.5\": \"path\",\r\n    \"0.6\": \"settings\",\r\n    \"0.2.0\": \"identifier\",\r\n    \"0.2.1\": \"notification\",\r\n    \"0.2.2\": \"type\",\r\n    \"0.2.1.0\": \"kind\",\r\n    \"0.2.1.1\": \"value\",\r\n    \"0.2.1.1.0\": \"key\"\r\n  };\r\n  const obj = {\r\n      cursor: \"0\",\r\n      hash\r\n    }\r\n  ;\r\n\r\n  function mapOverHashTree(lenses, mapFn, obj) {\r\n    return mapOverTree(lenses, ({label, hash, cursor }) => ({\r\n      label : mapFn(label), hash, cursor\r\n    }), obj);\r\n  }\r\n\r\n  const actual = mapOverHashTree(lenses, label => 'M-' + label, obj);\r\n  const expected = {};\r\n\r\n  assert.deepEqual(actual, expected, `Works!`);\r\n});\r\n"]}