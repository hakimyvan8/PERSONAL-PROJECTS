{"version":3,"file":"kingly.umd.js","sources":["../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js","../src/index.js"],"sourcesContent":["export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, MACHINE_CREATION_ERROR_MSG,\r\n  NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop, group:noop, groupEnd: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\n/**\r\n * @description takes an output and turns it into an array\r\n * @param {*} output\r\n * @returns {*[]|null} if the output is null: null, if output is an array: output, else: [output]\r\n */\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {HistoryState} _history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {HistoryState}\r\n * @modifies history\r\n */\r\nexport function updateHistory(_history, stateAncestors, state_from_name) {\r\n  // 27.08.2020: Now that I expose history state I have to make sure that it is not mutated!!\r\n  // We have a fixed format here, so we use native `assign` at deepest level\r\n  const history = {\r\n    [DEEP]: Object.assign({}, _history[DEEP]),\r\n    [SHALLOW]: Object.assign({}, _history[SHALLOW]),\r\n  };\r\n\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function(...*): True | Error} contract Contract that either fulfills or returns an error\r\n * @param {Array<*>} arrayParams Parameters to be passed to the contract\r\n * @returns {undefined|{when, location, info, message}|Object} either true (fulfilled contract)\r\n * or an object with optional properties for diagnostic and tracing purposes\r\n * about the cause of the error if the contract is not fulfilled\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport function wrapUpdateStateFn(userProvidedUpdateStateFn, {throwKinglyError, tracer}){\r\n  return (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n}\r\n\r\nexport function throwKinglyErrorFactory (console,tracer)  {\r\n  return obj => {\r\n  throw new KinglyError(obj, console, tracer)\r\n  }\r\n};\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n  emptyConsole,\r\n  findInitTransition,\r\n  getAncestorMap,\r\n  getEventTransitionsMaps,\r\n  getHistoryStatesMap,\r\n  getHistoryUnderlyingState,\r\n  getStatesPath,\r\n  getStatesTransitionsMap,\r\n  getStateEventTransitionsMaps,\r\n  getStatesType,\r\n  getTargetStatesMap,\r\n  isActionFactory,\r\n  isControlState,\r\n  isEvent,\r\n  isFunction,\r\n  isHistoryControlState,\r\n  noop\r\n} from \"./helpers\"\r\n// @ts-ignore\r\nimport { objectTreeLenses, PRE_ORDER, traverseObj } from \"fp-rosetree\"\r\nimport { CONTRACTS_EVAL, INIT_EVENT, INIT_STATE, MACHINE_CREATION_ERROR_MSG } from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n  name: 'noDuplicatedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { getLabel } = objectTreeLenses;\r\n    const traverse = {\r\n      strategy: PRE_ORDER,\r\n      seed: { duplicatedStates: [], statesHashMap: {} },\r\n      visit: (acc, traversalState, tree) => {\r\n        const { duplicatedStates, statesHashMap } = acc;\r\n        const treeLabel = getLabel(tree);\r\n        const controlState = Object.keys(treeLabel)[0];\r\n        if (controlState in statesHashMap) {\r\n          return {\r\n            duplicatedStates: duplicatedStates.concat(controlState),\r\n            statesHashMap\r\n          }\r\n        }\r\n        else {\r\n          return {\r\n            duplicatedStates,\r\n            statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const { duplicatedStates } = traverseObj(traverse, fsmDef.states);\r\n\r\n    const isFulfilled = duplicatedStates.length === 0;\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n        info: { duplicatedStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n  name: 'noReservedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n      blame: {\r\n        message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n        info: { reservedStates: [INIT_STATE], statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n  name: 'atLeastOneState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).length > 0,\r\n      blame: {\r\n        message: `Machine configuration must define at least one control state! Cf. log`,\r\n        info: { statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n  name: 'isInitialControlStateDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition, statesType }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const stateList = Object.keys(statesType);\r\n    if (initialControlState) {\r\n      return {\r\n        isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n        blame: {\r\n          message: `Configured initial control state must be a declared state. Cf. log`,\r\n          info: { initialControlState, declaredStates: stateList }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n\r\n  },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n  name: 'eventsAreStrings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    return {\r\n      isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n      blame: {\r\n        message: `Events must be an array of strings!`,\r\n        info: { events: fsmDef.events }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n  name: 'validInitialConfig',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState } = fsmDef;\r\n\r\n    if (initTransition && initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else if (!initTransition && !initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n  },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n  name: 'validInitialTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const initTransitions = transitions.reduce((acc, transition) => {\r\n      transition.from === INIT_STATE && acc.push(transition);\r\n      return acc\r\n    }, []);\r\n    // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n    // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n    // enforce the part of the contract which require to have no actions for initial transitions...\r\n    const isFulfilled =\r\n      (initialControlState && !initTransition) ||\r\n      (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n        && (\r\n          isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n          || areCconditionalTransitions(initTransition)\r\n          // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n        )\r\n      );\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Invalid configuration for initial transition! Cf. log`,\r\n        info: { initTransition, initTransitions, initialControlState }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n  name: 'initEventOnlyInCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n    const atomicInitTransitions = atomicStates.map(\r\n      atomicState => ({\r\n        [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n      })\r\n    ).filter(obj => Object.values(obj)[0]);\r\n\r\n    const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n    return {\r\n      isFulfilled: hasInitEventOnlyInCompoundStates,\r\n      blame: {\r\n        message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n        info: { initTransitions: atomicInitTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n  name: 'validInitialTransitionForCompoundState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n    const compoundStatesInitTransitions = compoundStates.map(\r\n      compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n    const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n    if (!allHaveInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state without an entry transition! Cf. log`,\r\n          info: {\r\n            hasEntryTransitions: compoundStates.map(\r\n              state => ({ [state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT]) }))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { guards, to } = initTransition;\r\n        if (!guards) {\r\n          //  T7a\r\n          return typeof to === 'string'\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(targetState => typeof targetState === 'string')\r\n        }\r\n      });\r\n    if (!allHaveValidInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n          info: { entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n    ;\r\n\r\n    const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { from, guards, to } = initTransition;\r\n\r\n        // Don't forget to also eliminate the case when from = to\r\n        // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n        // other from declared states\r\n        if (!guards) {\r\n          return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(to => {\r\n            return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n          })\r\n        }\r\n      });\r\n    if (!allHaveTargetStatesWithinHierarchy) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n          info: { states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n  name: 'validEventLessTransitions',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const stateList = Object.keys(statesType);\r\n    const failingOriginControlStates = stateList.map(state => {\r\n      return {\r\n        [state]: statesTransitionsMap[state] &&\r\n        `${void 0}` in statesTransitionsMap[state] &&\r\n        Object.keys(statesTransitionsMap[state]).length !== 1\r\n      }\r\n    }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n    const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n        info: { failingOriginControlStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n  name: 'allStateTransitionsOnOneSingleRow',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n      const events = Object.keys(stateEventTransitionsMaps[state]);\r\n      const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n      if (wrongEventConfig.length > 0) {\r\n        acc[state] = wrongEventConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n        info: { statesTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n  name: 'noConflictingTransitionsWithAncestorState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n    const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n      const states = Object.keys(eventTransitionsMaps[event]);\r\n      // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n      const wrongStateConfig = states\r\n        .filter(state => state !== INIT_STATE)\r\n        .map(state => ancestorMap[state] && {\r\n          [state]: ancestorMap[state].find(\r\n            ancestorState => states.indexOf(ancestorState) > -1\r\n          )\r\n        })\r\n        // removing cases : undefined and {[state]: undefined}\r\n        .filter(obj => {\r\n          return obj && Object.values(obj).filter(Boolean).length > 0\r\n        });\r\n\r\n      if (wrongStateConfig.length > 0) {\r\n        acc[event] = wrongStateConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n        info: { eventTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n  name: 'isHistoryStatesTargetStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, {}) => {\r\n    const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n      return isHistoryControlState(transition.from)\r\n        ? acc.concat(transition)\r\n        : acc\r\n    }, []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n        info: { wrongHistoryStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n  name: 'isHistoryStatesCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const wrongHistoryStates = originStateList.map(originState => {\r\n      if (originState === INIT_STATE) return []\r\n\r\n      const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n      return events.reduce((acc, event) => {\r\n        // I should only ever have one transition, that is checked in another contract\r\n        // !! if there are several transitions, we may have a false positive, but that is ok\r\n        // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n        // this will be recomputed correctly\r\n        const transition = stateEventTransitionsMaps[originState][event][0];\r\n        const { guards, to } = transition;\r\n        if (!guards) {\r\n          // Reminder: statesType[controlState] === true iff controlState is compound state\r\n          return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n            ? acc.concat(transition)\r\n            : acc\r\n        }\r\n        else {\r\n          return guards.reduce((acc, guard) => {\r\n            const { to } = guard;\r\n\r\n            return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n              ? acc.concat(transition)\r\n              : acc\r\n          }, acc)\r\n        }\r\n      }, [])\r\n    })\r\n      .reduce((acc, x) => acc.concat(x), []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n        info: { wrongHistoryStates, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n  name: 'isHistoryStatesExisting',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { historyStatesMap, statesType }) => {\r\n    const invalidTransitions = Array.from(historyStatesMap.entries())\r\n      .map(([historyState, flatTransitions]) => {\r\n        return !(historyState in statesType) && { historyState, flatTransitions }\r\n      })\r\n      .filter(Boolean);\r\n\r\n    const howMany = Object.keys(invalidTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n        info: { invalidTransitions, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n  const { from, event, guards, to, action } = transition;\r\n\r\n  return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n  const { to, predicate, action } = guard;\r\n\r\n  return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n  const { from, event, guards, to } = transition;\r\n\r\n  return guards && Array.isArray(guards) && guards.length > 0\r\n    && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n  name: 'isValidFsmDef',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions, states, events, initialExtendedState } = fsmDef;\r\n    const isValidTransitions = transitions && Array.isArray(transitions);\r\n    const isValidStates = states && typeof(states) === 'object';\r\n    const isValidEvents = events && Array.isArray(events);\r\n    if (!isValidTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The transitions property for a machine definition must be an array!`,\r\n          info: { transitions }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidStates) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The states property for a machine definition must be an object!`,\r\n          info: { states }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidEvents) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The events property for a machine definition must be an array!`,\r\n          info: { events }\r\n        }\r\n      }\r\n    }\r\n    // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n    // this is done in other contracts\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n  name: 'haveTransitionsValidTypes',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions } = fsmDef;\r\n    const wrongTransitions = transitions\r\n      .map((transition, transitionIndex) => {\r\n        return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n          transition,\r\n          index: transitionIndex\r\n        }\r\n      })\r\n      .filter(Boolean)\r\n\r\n    const howMany = Object.keys(wrongTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n        info: { wrongTransitions, transitions }\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n  name: 'areEventsDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { eventTransitionsMaps }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps);\r\n    const declaredEventList = fsmDef.events;\r\n    const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n      .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n      .filter(Boolean);\r\n    const eventsNotDeclaredButTriggeringTransitions = eventList\r\n      .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n      .filter(Boolean)\r\n      // Filtering out init events which must not be declared, being reserved events\r\n      // Filtering out undefined events linked to eventless transitions\r\n      .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n    const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n      && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n        info: { eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n  name: 'areStatesDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, targetStatesMap, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n    const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n      stateList.forEach(state => acc[state] = true)\r\n      return acc\r\n    }, {}));\r\n    const declaredStateList = Object.keys(statesType);\r\n    const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n      .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n      .filter(Boolean);\r\n    const statesNotDeclaredButTriggeringTransitions = stateList\r\n      .map(stateInTransition =>\r\n        stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n      .filter(Boolean);\r\n\r\n    const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n      && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n        info: { statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n  name: 'isValidSettings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef) => {\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n  name: 'isInitialStateOriginState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap }) => {\r\n\r\n    if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one transition with the initial state as target state! CF. log`,\r\n          info: { targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n  name: 'isValidSelfTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap, statesType }) => {\r\n    const targetStates = Array.from(targetStatesMap.keys());\r\n    const wrongSelfTransitions = targetStates\r\n      .map(targetState => {\r\n        const flatTransitions = targetStatesMap.get(targetState);\r\n        return flatTransitions\r\n          .map(flatTransition => {\r\n            const { from, event } = flatTransition;\r\n            if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n              return { state: targetState, flatTransition }\r\n            }\r\n          })\r\n          .filter(Boolean)\r\n      })\r\n      .filter(x => x.length > 0);\r\n\r\n    return {\r\n      isFulfilled: wrongSelfTransitions.length === 0,\r\n      blame: {\r\n        message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n        info: { wrongSelfTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const fsmContracts = {\r\n  injected: (fsmDef, settings) => {\r\n    return {\r\n      statesType: getStatesType(fsmDef.states),\r\n      initTransition: findInitTransition(fsmDef.transitions),\r\n      statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n      stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n      eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n      ancestorMap: getAncestorMap(fsmDef.states),\r\n      statesPath: getStatesPath(fsmDef.states),\r\n      historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n      targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n    }\r\n  },\r\n  description: 'FSM structure',\r\n  contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n  const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n  const trace = settings && settings.debug && settings.debug.trace || noop;\r\n  const contractsDescription = contractsDef.description;\r\n\r\n  return function checkContracts(...args) {\r\n    const failingContracts = [];\r\n    const computedArgs = contractsDef.injected.apply(null, args);\r\n    const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n      const { name: contractName, predicate, shouldThrow } = contract;\r\n      const fullArgs = args.concat(computedArgs);\r\n      const { isFulfilled, blame } = predicate.apply(null, fullArgs);\r\n      const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n      const { message, info } = blame || {};\r\n\r\n      if (isFulfilled) return acc\r\n      else {\r\n        failingContracts.push({ name: contractName, message, info });\r\n        console.error(blameMessageHeader);\r\n        console.error([contractName, message].join(': '));\r\n        console.debug('Supporting error data:', info);\r\n\r\n        if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n        else {\r\n          return false\r\n        }\r\n      }\r\n    }, true)\r\n\r\n    const contractsEval = { isFulfilled, failingContracts };\r\n    trace({ [CONTRACTS_EVAL]: contractsEval })\r\n\r\n    return contractsEval\r\n  }\r\n}\r\n\r\n// @ts-ignore error here is due to variable number of arguments, not worth spending time there\r\nexport const fsmContractChecker = (fsmDef, settings,\r\n                                   fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\nexport function runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer }) {\r\n  if (checkContracts) {\r\n    const { failingContracts } = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: { fsmDef, settings, failingContracts },\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: { cs: void 0, es: void 0, hs: void 0 }\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","//@ts-check\r\nimport {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap,\r\n  throwKinglyErrorFactory, wrapUpdateStateFn\r\n} from \"./helpers\";\r\nimport { runContracts } from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * @description Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state`: Hash matching keys (state names) to whether that state is a nested state\r\n * `hash_states`: Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hashStates: {}, isGroupState: Object<String,Boolean>}}\r\n */\r\nfunction buildNestedStateStructure(states) {\r\n  const root_name = \"State\";\r\n  let hashStates = {};\r\n  let isGroupState = {};\r\n\r\n  // Add the starting state\r\n  states = { nok: states };\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hashStates[state_name] = new curr_constructor();\r\n      hashStates[state_name].name = state_name;\r\n      const parent_name = (hashStates[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hashStates[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        isGroupState[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hashStates[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hashStates[INIT_STATE] = new State();\r\n  hashStates[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hashStates: hashStates,\r\n    isGroupState: isGroupState\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const { initialControlState, transitions } = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{ from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY }])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} [settings]\r\n * @returns {Error | Stateful_FSM}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withProtectedState\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @returns {Error | Pure_FSM}\r\n */\r\nexport function createPureStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withPureInterface\r\n}\r\n\r\n/**\r\n * @description Creates an instance of state machine from a set of states, transitions,\r\n * and accepted events. The initial extended state for the machine is included\r\n * in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {{withProtectedState: Stateful_FSM, withPureInterface: Pure_FSM}|Error}\r\n */\r\nexport function createStateMachineAPIs(fsmDef, settings) {\r\n  const {\r\n    states: controlStates,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const { debug, devTool, displayName } = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = throwKinglyErrorFactory(console, tracer);\r\n\r\n  // Check contracts if the API user wants to,\r\n  // but don't throw errors, return them and possibly log them\r\n  if (checkContracts) {\r\n    const e = runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer });\r\n    if (e instanceof Error) return e\r\n  }\r\n\r\n  // Wrap user-provided update state function to capture errors\r\n  const wrappedUpdateState = wrapUpdateStateFn(userProvidedUpdateStateFn, { throwKinglyError, tracer });\r\n  // We also massage the shape of the user-provided transitions,\r\n  // unifying the two ways of providing an initial state for the machine\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create auxiliary data structures to quickly answer common queries:\r\n  // - is `stateName` a state that has an initial transition configured\r\n  //   (top-level, or compound state) : `isInitState[stateName]`\r\n  // - is `stateName` a transient state, i.e. with an configured\r\n  //   initial or eventless transitions: `isAutoState[stateName]`\r\n  // - is `stateName` a compound state: `isGroupState[stateName]`\r\n  // - what computation to run in `stateName`:\r\n  //   `hashStates[stateName][event]` has the event handler for `event`\r\n  //    NOTE: we use JS prototypal inheritance to make this work even when\r\n  //    A < ... < B. and the event handler in configured on parent A, and not on B\r\n  //    When the machine is in state B, it must answer to the event as A would\r\n  const hashStatesStruct = buildNestedStateStructure(controlStates);\r\n  // @type {Object<state_name,boolean>}\r\n  let isInitState = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let isAutoState = {};\r\n  // @type {Object<state_name,boolean>}\r\n  const isGroupState = hashStatesStruct.isGroupState;\r\n  let hashStates = hashStatesStruct.hashStates;\r\n\r\n  // Fill in the auxiliary data structures\r\n  transitions.forEach(function (transition) {\r\n    let { from, to, action, event, guards: arr_predicate } = transition;\r\n    // CASE: ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{ predicate: void 0, to: to, action: action }];\r\n\r\n    // CASE: transition has a init event\r\n    // NOTE: there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      isInitState[from] = true;\r\n    }\r\n\r\n    let from_proto = hashStates[from];\r\n\r\n    // CASE: automatic transitions: no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      isAutoState[from] = true;\r\n    }\r\n    // CASE: automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (isGroupState[from] && isInitState[from]) {\r\n      isAutoState[from] = true;\r\n    }\r\n\r\n    // NTH: this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce(\r\n      (acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index },\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: { event, guard, from, to, index, shouldTransitionBeTaken },\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState_, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: { extendedState, event, event_data, settings, guard, from, to, index, action },\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index, action, actionResult },\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const { updates, outputs } = actionResult;\r\n\r\n              // Leave the current state\r\n              leaveState(from, extendedState_, hashStates);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const newControlState = enterNextState(to, updates, hashStates);\r\n              console.info(\"ENTERING NEXT STATE: \", cs);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return { stop: true, outputs };\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: { eventData: event_data, settings, guard, from, to, index, action: actionName },\r\n                  machineState: { cs: current_state, es: extendedState, hs: history }\r\n                }\r\n              });\r\n              return { stop: false, outputs: null };\r\n            }\r\n          };\r\n\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return { stop: false, outputs: null };\r\n      }\r\n    );\r\n  });\r\n\r\n  // Setting up the initial state of the machine in closure\r\n  // That is the control state, history state, and extended state\r\n  // NOTE: the user-provided update function by contract cannot update in place\r\n  // There is thus no need to clone the initial extended state.\r\n  const { stateList, stateAncestors } = computeHistoryMaps(controlStates);\r\n  let history = initHistoryDataStructure(stateList);\r\n  let extendedState = initialExtendedState;\r\n  let cs = INIT_STATE;\r\n\r\n  // Run the machine's initial transition\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: { fsmDef, settings, error: e },\r\n        machineState: { cs: INIT_STATE, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    console && console.error(`An error occurred when starting the machine`, e)\r\n\r\n    return e\r\n  }\r\n\r\n  const fsmAPIs = {\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine. The function receives the input to be\r\n     *   processed by the machine, and outputs the results of the machine computation. In the general case, the machine\r\n     *   computes an array of values. The array can be empty, and when not, it may contain null values. The machine may\r\n     *   also return null (in csae of an input that the machine is not configured to react to) instead of returning an\r\n     *   array.\r\n     * @param {*} input\r\n     * @returns {FSM_Outputs|Error}\r\n     * @throws if an error is produced that is not an error recognized by Kingly. This generally means an unexpected\r\n     *   exception has occurred.\r\n     */\r\n    withProtectedState: function fsm(input) {\r\n      try {\r\n        const { eventName, eventData } = destructureEvent(input);\r\n\r\n        tracer({\r\n          type: INPUT_MSG,\r\n          trace: {\r\n            info: { eventName, eventData },\r\n            machineState: { cs: cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        const outputs = sendEvent(input, false);\r\n\r\n        debug && console.info(\"OUTPUTS:\", outputs);\r\n        tracer({\r\n          type: OUTPUTS_MSG,\r\n          trace: {\r\n            outputs,\r\n            machineState: { cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        return outputs\r\n      }\r\n      catch (e) {\r\n        if (e instanceof KinglyError) {\r\n          // We don't break the program, but we can't continue as if nothing happened: we return the error\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return e\r\n        }\r\n        else {\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An unknown error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n          console.error(`yyield > unexpected error!`, e);\r\n          // We should only catch the errors we are responsible for!\r\n          throw e\r\n        }\r\n      }\r\n    },\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine but requires to be passed both the\r\n     *   machine internal state and an input from which to compute the machine outputs. According to the parameter\r\n     *   passed as internal state, the machine may: 1. (undefined) compute outputs from the last state of the machine,\r\n     *   1. (null) compute outputs, restarting from its initial state, 3. (truthy) compute outputs from the given state\r\n     *   of the machine\r\n     * @param {*} input\r\n     * @param {FSM_Internal_State} fsmState\r\n     * @returns {{outputs: FSM_Outputs|Error, fsmState: FSM_Internal_State}}\r\n     */\r\n    withPureInterface: function compute(input, fsmState) {\r\n      if (fsmState === void 0) {\r\n        // Don't update the state of the state machine\r\n        // This means the machine will continue processing inputs\r\n        // using its current state\r\n      }\r\n      else if (fsmState === null) {\r\n        // Reinitialize the machine\r\n        extendedState = initialExtendedState;\r\n        history = initHistoryDataStructure(stateList);\r\n        hashStates[INIT_STATE].current_state_name = INIT_STATE;\r\n        start();\r\n      }\r\n      else {\r\n        // Reset the state (available in closure) of the state machine\r\n        const { cs: _cs, hs, es } = fsmState;\r\n        extendedState = es;\r\n        history = hs;\r\n        cs = _cs;\r\n      }\r\n\r\n      // run the machine\r\n      const outputs = fsmAPIs.withProtectedState(input);\r\n      // NOTE: history does not need to be cloned here! We do not update the\r\n      // history in place => No risk of accidentally modifying the history\r\n      // of another machine\r\n      // TODO: We should however definitely clone `extendedState` How to modify the API?\r\n      // Require a clone function in settings? with a default of JSON.stringify?\r\n      // or we shift the responsibility on the API user to do the cloning?\r\n      // Good: faster in the default case, simpler library too, no cloning when not needed\r\n      // Bad: library user can forget, so footgun...\r\n      // ADR: API that forces to signal a clone function, which can be DEFAULT_CLONE\r\n      return { outputs, fsmState: { cs, hs: history, es: extendedState } }\r\n    }\r\n  };\r\n\r\n  return fsmAPIs\r\n\r\n  // Auxiliary functions\r\n  //\r\n\r\n  /**\r\n   *\r\n   * @param {function(...*): True | Error} contract\r\n   * @param {Array<*>} arrayParams\r\n   * @returns {undefined}\r\n   * @throws KinglyError in case of one or more failing contracts\r\n   */\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  /**\r\n   * @description process an input (aka event) according to the machine specifications.\r\n   * @param {LabelledEvent} event_struct input to be processed by the machine\r\n   * @param {Boolean} isInternalEvent should be true iff the event is sent by Kingly, not by the\r\n   * API user. API user should always leave this undefined.\r\n   * This works around an edge case discovered through testing.\r\n   * With the fix implemented here, API users that send an INIT_EVENT will have it ignored.\r\n   * INIT_EVENT is reserved and API users should not use it. This fix is for robustness purposes.\r\n   * @returns {FSM_Outputs|null}\r\n   */\r\n  function sendEvent(event_struct, isInternalEvent) {\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const { eventName, eventData } = destructureEvent(event_struct);\r\n\r\n    console.group(\"send event \" + eventName || \"\");\r\n    console.log(event_struct);\r\n\r\n    // Edge case to deal with: INIT_EVENT sent and the current state is the initial state\r\n    // This is a side-effect of our implementation that leverages JS prototypes.\r\n    // The INIT_STATE is a super-state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation.\r\n    // This led to a bug where an API user would maliciously send the reserved INIT_EVENT,\r\n    // thus resetting the machine in its initial state, with an unpredictable extended state!\r\n    // That, in turn, results from a **design mistake** that I will not correct here, which consisted\r\n    // in letting API users configure an initial control state, OR initial INIT_EVENT transitions.\r\n    // ADR: the impact is small, the fix is ok. API users have more flexibility at the\r\n    // cost of implementation complexity. But next time, pick simplicity over flexibility.\r\n    if (!isInternalEvent && eventName === INIT_EVENT && cs !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { eventName, eventData },\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n      console.groupEnd();\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = processEvent(\r\n      hashStatesStruct.hashStates,\r\n      eventName,\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    console.groupEnd();\r\n\r\n    return outputs\r\n  }\r\n\r\n  function processEvent(hashStates, event, eventData, extendedState) {\r\n    const oldCurrentState = cs;\r\n    const eventHandler = hashStates[oldCurrentState][event];\r\n\r\n    // CASE : There is a transition associated to that event\r\n    if (eventHandler) {\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, eventData);\r\n\r\n      // The transition is evaluated:\r\n      // - no guards are satisfied => outputs = null\r\n      // - guards satisfied => outputs an array, possibly containing a null value\r\n      /** OUT: this event handler modifies the in-closure machine state (extendedState, cs, history state) */\r\n      const { stop, outputs: rawOutputs } = eventHandler(extendedState, eventData, oldCurrentState);\r\n      const newControlState = cs;\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the new control state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1:init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case, eventData will be passed on every INIT_EVENT\r\n      // 2. eventless transitions\r\n      // NOTE : the inside guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen: all AUTO transitions should advance!\r\n      if (isAutoState[newControlState]) {\r\n        if (newControlState !== oldCurrentState) {\r\n          const auto_event = isInitState[newControlState]\r\n            ? INIT_EVENT\r\n            : AUTO_EVENT;\r\n\r\n          tracer({\r\n            type: INTERNAL_INPUT_MSG,\r\n            trace: {\r\n              info: { eventName: auto_event, eventData: eventData },\r\n              event: { [auto_event]: eventData },\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          const nextOutputs = sendEvent({ [auto_event]: eventData }, true);\r\n\r\n          tracer({\r\n            type: INTERNAL_OUTPUTS_MSG,\r\n            trace: {\r\n              outputs: nextOutputs,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return [].concat(outputs).concat(nextOutputs);\r\n        }\r\n        else {\r\n          // We found an eventless transition that returns to the same control state!\r\n          // This is forbidden as this may generate infinite loops on that stationary control state\r\n          // We throw in that case, as this is a breach of contract, one which we should\r\n          // detect at configuration time.\r\n          console.error(`Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`);\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              info: { received: { [event]: eventData } },\r\n              message: `Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`,\r\n              machineState: { cs: cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n        }\r\n      }\r\n      else return outputs;\r\n    }\r\n    // CASE : There is no transition associated to that event from that state\r\n    else {\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${cs}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { received: { [event]: eventData } },\r\n          message: `There is no transition associated to the event |${event}| in state |${cs}|!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leaveState(from, extendedState, hash_states) {\r\n    history = updateHistory(history, stateAncestors, hash_states[from].name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enterNextState(to, updatedExtendedState, hash_states) {\r\n    let targetStateName;\r\n\r\n    // CASE: history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const historyType = to[DEEP] ? DEEP : to[SHALLOW] ? SHALLOW : void 0;\r\n      const historyTarget = to[historyType];\r\n\r\n      // Contract: history state MUST be associated to compound state (else there is no history to be had)\r\n      if (!isInitState[historyTarget]) {\r\n        const message = `Configured a history state unrelated to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`;\r\n        debug && console && console.error(message);\r\n        throwKinglyError({ message })\r\n      }\r\n\r\n      // Edge case: If there is no history for the compound state, then we evaluate the\r\n      // initial transition for that compound state, i.e. we set that state as target state\r\n      targetStateName = history[historyType][historyTarget] || historyTarget;\r\n    }\r\n    // CASE: not a history state\r\n    else if (to) {\r\n      targetStateName = hash_states[to].name;\r\n    }\r\n    // Dead branch: should never happen\r\n    else {\r\n      throwKinglyError({ message: \"enter_state : unknown case! Not a state name, and not a history state to enter!\" });\r\n    }\r\n    cs = targetStateName;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", targetStateName);\r\n    return targetStateName;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: { eventName: INIT_EVENT, eventData: initialExtendedState },\r\n        event: { [INIT_EVENT]: initialExtendedState },\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n\r\n    return sendEvent({ [INIT_EVENT]: initialExtendedState }, true);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @typedef {Object} WebComponentFactoryParams\r\n * @property {String} name Name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @property {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @property {Stateful_FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @property {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @property {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an\r\n *   effect moniker to a function performing the corresponding effect.\r\n * @property {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\n/**\r\n * @param {WebComponentFactoryParams} webComponentFactoryParams\r\n */\r\nexport function makeWebComponentFromFsm({ name, eventHandler, fsm, commandHandlers, effectHandlers, options }) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions instanceof Error) {\r\n            // NOTE: we do not throw here, the web component will fail but\r\n            // the rest of the page may go on. We log and swallow the errors\r\n            console && console.log(actions)\r\n          }\r\n          else if (actions === NO_ACTION) return;\r\n          else {\r\n            actions.forEach(action => {\r\n              if (action === NO_ACTION) return;\r\n              const { command, params } = action;\r\n              commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n            })\r\n          }\r\n          ;\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      // There are no attributes\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // There are no attributes\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n","// TODO : export only the two/three functions part of the API! might require updating tests imports\r\n// - move the converter to yed2kingly or a new single script with options (convert to knogly, to uml, etc.)\r\n// export * from './types'\r\nexport {createStateMachine, createPureStateMachine, makeWebComponentFromFsm, historyState} from './synchronous_fsm'\r\nexport * from './converter'\r\nexport {ACTION_IDENTITY, INIT_EVENT, INIT_STATE, SHALLOW, DEEP, NO_STATE_UPDATE, NO_OUTPUT} from './properties'\r\nexport {computeHistoryMaps, initHistoryDataStructure} from './helpers'\r\nexport {fsmContracts} from './contracts'\r\n\r\n"],"names":["SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","noop","emptyConsole","log","warn","info","debug","error","trace","group","groupEnd","emptyTracer","isFunction","x","isControlState","isHistoryControlState","isEvent","isActionFactory","get_fn_name","fn","tokens","exec","toString","wrap","str","join","times","n","Array","apply","length","map","Number","call","keys","obj","Object","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","is_history_control_state_of","state","substring","format_transition_label","_event","predicate","action","name","format_history_transition_state_name","get_all_transitions","guards","getDisplayName","replace","getStatesType","statesTree","getLabel","objectTreeLenses","isLeafLabel","traverse","strategy","PRE_ORDER","seed","visit","acc","traversalState","tree","treeLabel","traverseObj","getStatesPath","pathStr","get","path","getStatesTransitionsMap","transitions","reduce","getStateEventTransitionsMaps","concat","getEventTransitionsMaps","getHistoryStatesMap","reduceTransitions","flatTransition","guardIndex","transitionIndex","gen","underlyingControlState","getHistoryUnderlyingState","set","Map","getTargetStatesMap","getAncestorMap","getChildren","children","childrenControlStates","forEach","computeHistoryMaps","control_states","stateList","stateAncestors","JSON","stringify","parentPath","slice","parentControlState","_","ancestors","reduceFn","result","transitionStruct","undefined","guard","arrayizeOutput","output","isArray","getHistoryType","history","initHistoryDataStructure","initHistory","updateHistory","_history","state_from_name","assign","oldAncestor","newAncestor","findInitTransition","find","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","isActions","isEventStruct","trueOrError","Error","cause","destructureEvent","eventName","eventData","wrapUpdateStateFn","userProvidedUpdateStateFn","throwKinglyError","tracer","extendedState","fnName","e","location","stack","throwKinglyErrorFactory","console","KinglyError","m","errors","fm","infoMsg","fullMsg","noDuplicatedStates","shouldThrow","fsmDef","settings","duplicatedStates","statesHashMap","states","isFulfilled","blame","noReservedStates","statesType","indexOf","reservedStates","atLeastOneState","isInitialControlStateDeclared","initTransition","initialControlState","declaredStates","eventsAreStrings","events","every","validInitialConfig","validInitialTransition","initTransitions","push","isInconditionalTransition","areCconditionalTransitions","initEventOnlyInCompoundStates","statesTransitionsMap","statesPath","atomicStates","filter","atomicInitTransitions","atomicState","values","hasInitEventOnlyInCompoundStates","validInitialTransitionForCompoundState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","Boolean","hasEntryTransitions","allHaveValidInitTransitions","targetStates","targetState","entryTransitions","allHaveTargetStatesWithinHierarchy","validEventLessTransitions","failingOriginControlStates","allStateTransitionsOnOneSingleRow","stateEventTransitionsMaps","originStateList","statesTransitionsInfo","wrongEventConfig","noConflictingTransitionsWithAncestorState","eventTransitionsMaps","ancestorMap","eventList","ev","eventTransitionsInfo","wrongStateConfig","ancestorState","isHistoryStatesTargetStates","wrongHistoryStates","isHistoryStatesCompoundStates","originState","isHistoryStatesExisting","historyStatesMap","invalidTransitions","entries","historyState","flatTransitions","howMany","isValidGuard","isValidFsmDef","initialExtendedState","isValidTransitions","isValidStates","isValidEvents","haveTransitionsValidTypes","wrongTransitions","index","areEventsDeclared","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","areStatesDeclared","targetStatesMap","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","isValidSettings","isInitialStateOriginState","isValidSelfTransition","wrongSelfTransitions","fsmContracts","injected","description","contracts","makeContractHandler","contractsDef","contractsDescription","checkContracts","args","failingContracts","computedArgs","fullArgs","blameMessageHeader","contractsEval","fsmContractChecker","runContracts","type","machineState","cs","es","hs","alwaysTrue","buildNestedStateStructure","root_name","hashStates","isGroupState","nok","build_state_reducer","curr_constructor","state_name","state_config","parent_name","curr_constructor_new","displayName","prototype","State","current_state_name","normalizeTransitions","createStateMachine","res","createStateMachineAPIs","withProtectedState","createPureStateMachine","withPureInterface","controlStates","updateState","devTool","wrappedUpdateState","hashStatesStruct","isInitState","isAutoState","arr_predicate","from_proto","actionName","condition_checking_fn","condition_suffix","extendedState_","event_data","current_state","predicateName","shouldTransitionBeTaken","actionResult","leaveState","newControlState","enterNextState","stop","arr_predicate_reduce_fn","condition_checked","dummy","start","fsmAPIs","fsm","input","sendEvent","compute","fsmState","_cs","assertContract","hasFailed","event_struct","isInternalEvent","processEvent","oldCurrentState","eventHandler","rawOutputs","auto_event","nextOutputs","received","hash_states","updatedExtendedState","targetStateName","historyType","historyTarget","deep","shallow","makeWebComponentFromFsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","params","initialEvent","terminalEvent","complete","oldValue","newValue","HTMLElement","customElements","define","generateStatePlantUmlHeader","optDisplayName","toPlantUml","constructTree","getChildrenNumber","pathMap","childrenTranslation","translation","stateToPlantUML","translationMap","postOrderTraverseTree","mappedTree","clear","format_history_states","format_entry_transitions","translate_transitions","historyStatesObj","accTranslation","allTransitions","historyStates","historyTransitionTranslation","format_history_transitions","standardTransitionTranslation","format_standard_transitions","toDagreVisualizerFormat","arrayTreeLenses","_translatedStates","translatedStates","translatedTransitions","translatedGuards"],"mappings":"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"}