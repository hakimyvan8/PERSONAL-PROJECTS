{"version":3,"file":"umd.js","sources":["../src/std.ts","../src/errors.ts","../src/internals.ts","../src/disjunctions.ts"],"sourcesContent":["/*!\n * Copyright (c) 2017-2018 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Setoid } from \"funland\"\n\n/**\n * Interface for testing the equality of value objects.\n */\nexport interface IEquals<A> {\n  /**\n   * Indicates whether some other object is \"equal to\" this one.\n   *\n   * Properties:\n   *\n   *  - reflexive: for any value, `x.equals(x) == true`\n   *  - symmetric: for any values x and y, `x.equals(y) == y.equals(x)`\n   *  - transitive: `x.equals(y) && y.equals(z) => x.equals(z)`\n   *  - consistent: `x.equals(y)` always yields the same result\n   *\n   * Rule: equal objects MUST have equal hash codes!\n   */\n  equals(other: A): boolean\n\n  /**\n   * Returns a hash code value for this value.\n   *\n   * This method is supported for the benefit of hash tables.\n   *\n   * Properties:\n   *\n   *  - consistent: multiple invocations always yield the same result\n   *  - if `x.equals(y) == true` then `x.hashCode() == y.hashCode()`\n   *  - if `x.equals(y) == false` it is NOT required for their hash codes\n   *    to be equal, i.e. this function is not injective\n   */\n  hashCode(): number\n}\n\n/**\n * Test if the given reference is a value object.\n *\n * Value objects are objects that implement the [[IEquals]]\n * interface.\n *\n * @param ref is the reference to test\n */\nexport function isValueObject(ref: any): boolean {\n  return !!(ref &&\n    typeof ref.equals === \"function\" &&\n    typeof ref.hashCode === \"function\")\n}\n\n/**\n * Tests for universal equality.\n *\n * First attempting a reference check with `===`,\n * after which it tries to fallback on [[IEquals]], if the\n * left-hand side is implementing it.\n *\n * ```typescript\n * equals(10, 10) // true, because 10 === 10\n *\n * class Box implements IEquals<Box> {\n *   constructor(value: number) { this.value = value }\n *\n *   equals(other) { return this.value === other.value  }\n *   hashCode() { return this.value << 2 }\n * }\n *\n * // false, because they are not the same reference\n * new Box(10) === new Box(10)\n *\n * // true, because `Box#equals` gets called\n * equals(new Box(10), new Box(10))\n * ```\n */\nexport function is<A>(lh: A, rh: A): boolean {\n  if (lh === rh || (lh !== lh && rh !== rh)) {\n    return true\n  }\n  if (!lh || !rh) {\n    return false\n  }\n  /* istanbul ignore else */\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (typeof lh.valueOf === \"function\" && typeof rh.valueOf === \"function\") {\n    const lh2 = lh.valueOf()\n    const rh2 = rh.valueOf()\n    if (lh2 === rh2 || (lh2 !== lh2 && rh2 !== rh2)) {\n      return true\n    }\n    if (!lh2 || !rh2) {\n      return false\n    }\n  }\n  // noinspection PointlessBooleanExpressionJS\n  return !!(\n    isValueObject(lh) &&\n    (lh as any).equals(rh)\n  )\n}\n\n/** Alias for [[is]]. */\nexport function equals<A>(lh: A, rh: A): boolean {\n  return is(lh, rh)\n}\n\n/**\n * Returns a `Setoid` type-class instance that depends\n * universal equality, as defined by {@link is}.\n */\nexport const universalSetoid: Setoid<any> = { equals }\n\n/**\n * Universal hash-code function.\n *\n * Depending on the given value, it calculates the hash-code like so:\n *\n *  1. if it's a `number`, then it gets truncated\n *     to an integer and returned\n *  2. if it's a \"value object\" (see [[isValueObject]]), then\n *     its `hashCode` is used\n *  3. if a `valueOf()` function is provided, then the\n *     `hashCode` gets recursively invoked on its result\n *  4. if all else fails, the value gets coerced to a `String`\n *     and a hash code is calculated using [[hashCodeOfString]]\n *\n * @param ref is the value to use for calculating a hash code\n * @return an integer with the aforementioned properties\n */\nexport function hashCode(ref: any): number {\n  if (typeof ref === \"number\") {\n    return ref & ref\n  }\n  /* istanbul ignore else */\n  if (typeof ref.valueOf === \"function\") {\n    const v = ref.valueOf()\n    if (v !== ref) return hashCode(v)\n  }\n  if (isValueObject(ref)) {\n    return (ref as IEquals<any>).hashCode()\n  }\n  return hashCodeOfString(String(ref))\n}\n\n/**\n * Calculates a hash code out of any string.\n */\nexport function hashCodeOfString(str: string): number {\n  let hash = 0\n  /* tslint:disable-next-line:strict-type-predicates */\n  if (str == null || str.length === 0) return hash\n  for (let i = 0; i < str.length; i++) {\n    const character = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + character\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return hash\n}\n\n/** The identity function. */\nexport function id<A>(a: A): A {\n  return a\n}\n\n/**\n * Utility function for implementing mixins, based on the\n * [TypeScript Mixins]{@link https://www.typescriptlang.org/docs/handbook/mixins.html}\n * documentation.\n *\n * Sample:\n *\n * ```typescript\n * class Disposable { ... }\n * class Activatable { ... }\n * class SmartObject implements Disposable, Activatable { ... }\n *\n * applyMixins(SmartObject, [Disposable, Activatable]);\n * ```\n *\n * Using `implements` instead of `extends` for base classes\n * will make the type system treat them like interfaces instead of\n * classes. And by `applyMixins` we can also supply global\n * implementations for the non-abstract members.\n */\nexport function applyMixins(derivedCtor: {prototype: any}, baseCtors: {prototype: any}[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      if (!derivedCtor.prototype[name])\n        derivedCtor.prototype[name] = baseCtor.prototype[name]\n    })\n  })\n}\n","/*!\n * Copyright (c) 2017-2018 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Type alias for errors that can be thrown.\n *\n * Since in JavaScript any object can be thrown, the standard\n * `Error` class (capital `E`) is not useful as a type in signatures,\n * the needed type being effectively `any`, but we still need a type\n * alias for documentation purposes.\n *\n * And since `any` represents an untyped object that bypasses the\n * type system, Funfix is using `Object` for TypeScript and `mixed`\n * for Flow to represent such throwables.\n */\nexport type Throwable = Error | Object\n\n/**\n * A composite error represents a list of errors that were caught\n * while executing logic which delays re-throwing of errors.\n */\nexport class CompositeError extends Error {\n  private errorsRef: Array<Throwable>\n\n  constructor(errors: Array<Throwable>) {\n    let reasons = \"\"\n    for (const e of errors.slice(0, 2)) {\n      let message = \"\"\n      if (e instanceof Error) {\n        message = `${e.name}(${e.message})`\n      } else {\n        message = `${e}`\n      }\n      reasons += \", \" + message\n    }\n\n    reasons = reasons.slice(2)\n    if (errors.length > 2) reasons = reasons + \", ...\"\n    super(reasons)\n\n    this.name = \"CompositeError\"\n    this.errorsRef = errors\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = CompositeError\n    self.__proto__ = CompositeError.prototype\n  }\n\n  /**\n   * Returns the full list of caught errors.\n   */\n  public errors(): Array<Throwable> { return this.errorsRef.slice() }\n}\n\n/**\n * A dummy error that can be used for testing purposes.\n */\nexport class DummyError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"DummyError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = DummyError\n    self.__proto__ = DummyError.prototype\n  }\n}\n\n/**\n * Thrown by various accessor methods or partial functions to indicate\n * that the element being requested does not exist.\n */\nexport class NoSuchElementError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NoSuchElementError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = NoSuchElementError\n    self.__proto__ = NoSuchElementError.prototype\n  }\n}\n\n/**\n * Error throw in class constructors by implementations that\n * are sealed or final.\n */\nexport class IllegalInheritanceError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalInheritanceError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalInheritanceError\n    self.__proto__ = IllegalInheritanceError.prototype\n  }\n}\n\n/**\n * Signals that a function has been invoked at an illegal\n * or inappropriate time.\n *\n * In other words, environment or application is not in an\n * appropriate state for the requested operation.\n */\nexport class IllegalStateError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalStateError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalStateError\n    self.__proto__ = IllegalStateError.prototype\n  }\n}\n\n/**\n * Signals that a function has been invoked with illegal\n * arguments.\n */\nexport class IllegalArgumentError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"IllegalArgumentError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = IllegalArgumentError\n    self.__proto__ = IllegalArgumentError.prototype\n  }\n}\n\n/**\n * Signals that a function or a method is missing an implementation,\n * which should be provided in the future.\n */\nexport class NotImplementedError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"NotImplementedError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = NotImplementedError\n    self.__proto__ = NotImplementedError.prototype\n  }\n}\n\n/**\n * Signals that completion of a procedure took longer than anticipated.\n */\nexport class TimeoutError extends Error {\n  constructor(message?: string) {\n    super(message)\n    this.name = \"TimeoutError\"\n\n    // Workaround to make `instanceof` work in ES5\n    const self = this as any\n    self.constructor = TimeoutError\n    self.__proto__ = TimeoutError.prototype\n  }\n}\n","/*!\n * Copyright (c) 2017-2018 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Constructor, Setoid, Monad } from \"funland\"\n\n/**\n * Given a function, converts it into a method where `this` gets\n * passed around as the last argument.\n */\nexport function convertToMethod(f: Function): Function {\n  return function (this: any) {\n    const args = Array.prototype.slice.call(arguments)\n    args.push(this)\n    return f.apply(undefined, args)\n  }\n}\n\n/**\n * Given a constructor, searches for all Fantasy-Land compatible\n * methods registered on its `prototype` and also registers them\n * using Fantasy-Land compatible symbols.\n *\n * For example:\n *\n * ```typescript\n * class Box<A> {\n *   constructor(public readonly value: A) {}\n *\n *   // Setoid\n *   equals(that: Box<A>) {\n *     return that && this.value === that.value\n *   }\n *   // Functor\n *   map<B>(f: (a: A) => B): Box<B> {\n *     return new Box(f(this.value))\n *   }\n * }\n *\n * // Registering Fantasy-Land compatible symbols\n * fantasyLandRegister(Box)\n * ```\n *\n * The above registration call would make `fantasy-land/equals` and\n * `fantasy-land/functor` available on `Box.prototype`.\n *\n * @private\n * @Hidden\n */\nexport function fantasyLandRegister<A>(\n  cls: Constructor<A>,\n  monad?: Monad<any>,\n  setoid?: Setoid<any>): void {\n\n  const c = cls as any\n  const p = c.prototype\n\n  const fl = \"fantasy-land/\"\n  const equals = \"equals\"\n  const flEquals = fl + equals\n  const map = \"map\"\n  const flMap = fl + map\n  const ap = \"ap\"\n  const flAp = fl + ap\n  const flOf = fl + \"of\"\n  const chain = \"chain\"\n  const flChain = fl + chain\n  const chainRec = \"chainRec\"\n  const flChainRec = fl + chainRec\n\n  // Setoid\n  if (p[equals]) {\n    p[flEquals] = p[equals]\n  } else {\n    /* istanbul ignore else */\n    if (setoid) p[flEquals] = convertToMethod(setoid.equals)\n  }\n  // Functor\n  if (p[map]) {\n    p[flMap] = p[map]\n  } else {\n    /* istanbul ignore else */\n    if (monad) p[flMap] = convertToMethod(monad.map)\n  }\n  // Apply\n  if (p[ap]) {\n    p[flAp] = p[ap]\n  } else {\n    /* istanbul ignore else */\n    if (monad) p[flAp] = convertToMethod(monad.ap)\n  }\n  // Applicative\n  if (c[\"pure\"]) {\n    c[flOf] = c[\"pure\"]\n  } else {\n    /* istanbul ignore else */\n    if (monad) c[flOf] = monad.of\n  }\n  // Chain\n  if (p[chain]) {\n    p[flChain] = p[chain]\n  } else {\n    /* istanbul ignore else */\n    if (monad) p[flChain] = convertToMethod(monad.chain)\n  }\n  // ChainRec\n  if (c[chainRec]) {\n    c[flChainRec] = c[chainRec]\n  } else {\n    /* istanbul ignore else */\n    if (monad) c[flChainRec] = monad.chainRec\n  }\n}\n","/*!\n * Copyright (c) 2017-2018 by The Funfix Project Developers.\n * Some rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Setoid, Monad } from \"funland\"\nimport * as std from \"./std\"\nimport { HK, HK2 } from \"./kinds\"\nimport { Throwable, NoSuchElementError } from \"./errors\"\nimport { fantasyLandRegister } from \"./internals\"\n\n/**\n * Represents a value of one of two possible types (a disjoint union).\n *\n * A common use of Either is as an alternative to [[Option]] for dealing\n * with possible missing values. In this usage [[Option.none]] is replaced\n * with [[Either.left]] which can contain useful information and\n * [[Option.some]] is replaced with [[Either.right]].\n *\n * Convention dictates that `left` is used for failure and `right` is used\n * for success. Note that this `Either` type is right-biased, meaning that\n * operations such as `map`, `flatMap` and `filter` work on the `right` value\n * and if you want to work on the `left` value, then you need to do a `swap`.\n *\n * For example, you could use `Either<String, Int>` to detect whether an\n * input is a string or an number:\n *\n * ```typescript\n * function tryParseInt(str: string): Either<string, number> {\n *   const i = parseInt(value)\n *   return isNaN(i) ? Left(str) : Right(i)\n * }\n *\n * const result = tryParseInt(\"not an int\")\n * if (result.isRight()) {\n *   console.log(`Increment: ${result.get}`)\n * } else {\n *   console.log(`ERROR: could not parse ${result.swap.get}`)\n * }\n * ```\n *\n * @final\n */\nexport class Either<L, R> implements std.IEquals<Either<L, R>>, HK2<\"funfix/either\", L, R> {\n  public readonly value: L | R\n  private readonly _isRight: boolean\n\n  protected constructor(value: L | R, tag: \"left\" | \"right\") {\n    this._isRight = tag === \"right\"\n    this.value = value\n  }\n\n  /**\n   * Returns `true` if this is a `left`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isLeft() // true\n   * Right(10).isLeft() // false\n   * ```\n   */\n  isLeft(): this is TLeft<L> { return !this._isRight }\n\n  /**\n   * Returns `true` if this is a `right`, `false` otherwise.\n   *\n   * ```typescript\n   * Left(\"hello\").isRight() // false\n   * Right(10).isRight() // true\n   * ```\n   */\n  isRight(): this is TRight<R> { return this._isRight }\n\n  /**\n   * Returns true if this is a Right and its value is equal to `elem`\n   * (as determined by the `equals` protocol), returns `false` otherwise.\n   *\n   * ```typescript\n   * // True\n   * Right(\"something\").contains(\"something\")\n   *\n   * // False because the values are different\n   * Right(\"something\").contains(\"anything\") // false\n   *\n   * // False because the source is a `left`\n   * Left(\"something\").contains(\"something\") // false\n   * ```\n   */\n  contains(elem: R): this is TRight<R> {\n    return this._isRight && std.is(this.value, elem)\n  }\n\n  /**\n   * Returns `false` if the source is a `left`, or returns the result\n   * of the application of the given predicate to the `right` value.\n   *\n   * ```typescript\n   * // True, because it is a right and predicate holds\n   * Right(20).exists(n => n > 10)\n   *\n   * // False, because the predicate returns false\n   * Right(10).exists(n => n % 2 != 0)\n   *\n   * // False, because it is a left\n   * Left(10).exists(n => n == 10)\n   * ```\n   */\n  exists(p: (r: R) => boolean): this is TRight<R> {\n    return this._isRight && p(this.value as R)\n  }\n\n  /**\n   * Filters `right` values with the given predicate, returning\n   * the value generated by `zero` in case the source is a `right`\n   * value and the predicate doesn't hold.\n   *\n   * Possible outcomes:\n   *\n   *  - Returns the existing value of `right` if this is a `right` value and the\n   *    given predicate `p` holds for it\n   *  - Returns `Left(zero())` if this is a `right` value\n   *    and the given predicate `p` does not hold\n   *  - Returns the current \"left\" value, if the source is a `Left`\n   *\n   * ```typescript\n   * Right(12).filterOrElse(x => x > 10, () => -1) // Right(12)\n   * Right(7).filterOrElse(x => x > 10, () => -1)  // Left(-1)\n   * Left(7).filterOrElse(x => false, () => -1)    // Left(7)\n   * ```\n   */\n  filterOrElse<LL>(p: (r: R) => boolean, zero: () => LL): Either<L | LL, R> {\n    return this._isRight\n      ? (p(this.value as R) ? this as any : Left(zero()))\n      : this as any\n  }\n\n  /**\n   * Binds the given function across `right` values.\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Either` references.\n   */\n  flatMap<S>(f: (r: R) => Either<L, S>): Either<L, S> {\n    return this._isRight ? f(this.value as R) : (this as any)\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<S>(f: (r: R) => Either<L, S>): Either<L, S> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * `Applicative` apply operator.\n   *\n   * Resembles {@link map}, but the passed mapping function is\n   * lifted in the `Either` context.\n   */\n  ap<S>(ff: Either<L, (a: R) => S>): Either<L, S> {\n    return ff.flatMap(f => this.map(f))\n  }\n\n  /**\n   * Applies the `left` function to [[Left]] values, and the\n   * `right` function to [[Right]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Either<string, number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     str => `Could not parse string: ${str}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<S>(left: (l: L) => S, right: (r: R) => S): S {\n    return this._isRight ? right(this.value as R) : left(this.value as L)\n  }\n\n  /**\n   * Returns true if the source is a `left` or returns\n   * the result of the application of the given predicate to the\n   * `right` value.\n   *\n   * ```typescript\n   * // True, because it is a `left`\n   * Left(\"hello\").forAll(x => x > 10)\n   *\n   * // True, because the predicate holds\n   * Right(20).forAll(x => x > 10)\n   *\n   * // False, it's a right and the predicate doesn't hold\n   * Right(7).forAll(x => x > 10)\n   * ```\n   */\n  forAll(p: (r: R) => boolean): boolean {\n    return !this._isRight || p(this.value as R)\n  }\n\n  /**\n   * Returns the `Right` value, if the source has one,\n   * otherwise throws an exception.\n   *\n   * WARNING!\n   *\n   * This function is partial, the `Either` must be a `Right`, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the the `Either` is a `Left`\n   */\n  get(): R {\n    if (this._isRight) return this.value as R\n    throw new NoSuchElementError(\"left.get()\")\n  }\n\n  /**\n   * Returns the value from this `right` or the given `fallback`\n   * value if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElse(27) // 10\n   * Left(10).getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<RR>(fallback: RR): R | RR {\n    return this._isRight ? this.value as R : fallback\n  }\n\n  /**\n   * Returns the value from this `right` or a value generated\n   * by the given `thunk` if this is a `left`.\n   *\n   * ```typescript\n   * Right(10).getOrElseL(() => 27) // 10\n   * Left(10).getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<RR>(thunk: () => RR): R | RR {\n    return this._isRight ? this.value as R : thunk()\n  }\n\n  /**\n   * Transform the source if it is a `right` with the given\n   * mapping function.\n   *\n   * ```typescript\n   * Right(10).map(x => x + 17) // right(27)\n   * Left(10).map(x => x + 17)  // left(10)\n   * ```\n   */\n  map<C>(f: (r: R) => C): Either<L, C> {\n    return this._isRight\n      ? Right(f(this.value as R))\n      : (this as any)\n  }\n\n  /**\n   * Executes the given side-effecting function if the\n   * source is a `right` value.\n   *\n   * ```typescript\n   * Right(12).forAll(console.log) // prints 12\n   * Left(10).forAll(console.log)  // silent\n   * ```\n   */\n  forEach(cb: (r: R) => void): void {\n    if (this._isRight) cb(this.value as R)\n  }\n\n  /**\n   * If this is a `left`, then return the left value as a `right`\n   * or vice versa.\n   *\n   * ```typescript\n   * Right(10).swap() // left(10)\n   * Left(20).swap()  // right(20)\n   * ```\n   */\n  swap(): Either<R, L> {\n    return this._isRight\n      ? Left(this.value as R)\n      : Right(this.value as L)\n  }\n\n  /**\n   * Returns an `Option.some(right)` if the source is a `right` value,\n   * or `Option.none` in case the source is a `left` value.\n   */\n  toOption(): Option<R> {\n    return this._isRight ? Some(this.value as R) : None\n  }\n\n  /**\n   * Implements {@link IEquals.equals}.\n   *\n   * @param that is the right hand side of the equality check\n   */\n  equals(that: Either<L, R>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    return this._isRight === that._isRight && std.is(this.value, that.value)\n  }\n\n  /** Implements {@link IEquals.hashCode}. */\n  hashCode(): number {\n    return this._isRight\n      ? std.hashCode(this.value as R) << 2\n      : std.hashCode(this.value as L) << 3\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _URI!: \"funfix/either\"\n  /** @hidden */ readonly _A!: R\n  /** @hidden */ readonly _L!: L\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _Class: Either<any, any>\n\n  /**\n   * Builds a pure `Either` value.\n   *\n   * This operation is the pure `Applicative` operation for lifting\n   * a value in the `Either` context.\n   */\n  static pure<A>(value: A): Either<never, A> {\n    return new TRight(value)\n  }\n\n  /**\n   * Builds a left value, equivalent with {@link Left}.\n   */\n  static left<L, R>(value: L): Either<L, R> {\n    return Left(value)\n  }\n\n  /**\n   * Builds a right value, equivalent with {@link Right}.\n   */\n  static right<L, R>(value: R): Either<L, R> {\n    return Right(value)\n  }\n\n  /**\n   * Maps 2 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if both `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(3)\n   * Try.map2(Right(1), Right(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map2(Right(1), Left(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1, A2, L, R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>,\n    f: (a1: A1, a2: A2) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return fa1\n    if (fa2.isLeft()) return fa2\n    return Right(f(fa1.value as A1, fa2.value as A2))\n  }\n\n  /**\n   * Maps 3 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 3 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(6)\n   * Try.map3(Right(1), Right(2), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map3(Right(1), Left(\"error\"), Right(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1, A2, A3, L, R>(\n    fa1: Either<L, A1>, fa2: Either<L, A2>, fa3: Either<L, A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return fa1\n    if (fa2.isLeft()) return fa2\n    if (fa3.isLeft()) return fa3\n    return Right(f(fa1.value as A1, fa2.value as A2, fa3.value as A3))\n  }\n\n  /**\n   * Maps 4 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 4 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(10)\n   * Try.map4(Right(1), Right(2), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map4(Right(1), Left(\"error\"), Right(3), Right(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1, A2, A3, A4, L, R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return fa1\n    if (fa2.isLeft()) return fa2\n    if (fa3.isLeft()) return fa3\n    if (fa4.isLeft()) return fa4\n    return Right(f(fa1.value as A1, fa2.value as A2, fa3.value as A3, fa4.value as A4))\n  }\n\n  /**\n   * Maps 5 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 5 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(15)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1, A2, A3, A4, A5, L, R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return fa1\n    if (fa2.isLeft()) return fa2\n    if (fa3.isLeft()) return fa3\n    if (fa4.isLeft()) return fa4\n    if (fa5.isLeft()) return fa5\n    return Right(f(fa1.value as A1, fa2.value as A2, fa3.value as A3, fa4.value as A4, fa5.value as A5))\n  }\n\n  /**\n   * Maps 6 `Either` values by the mapping function, returning a new\n   * `Either` reference that is a `Right` only if all 6 `Either` values are\n   * `Right` values, otherwise it returns the first `Left` value noticed.\n   *\n   * ```typescript\n   * // Yields Right(21)\n   * Try.map5(Right(1), Right(2), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields Left, because the second arg is a Left\n   * Try.map5(Right(1), Left(\"error\"), Right(3), Right(4), Right(5), Right(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1, A2, A3, A4, A5, A6, L, R>(\n    fa1: Either<L,A1>, fa2: Either<L,A2>, fa3: Either<L,A3>, fa4: Either<L,A4>, fa5: Either<L,A5>, fa6: Either<L,A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Either<L, R> {\n\n    if (fa1.isLeft()) return fa1\n    if (fa2.isLeft()) return fa2\n    if (fa3.isLeft()) return fa3\n    if (fa4.isLeft()) return fa4\n    if (fa5.isLeft()) return fa5\n    if (fa6.isLeft()) return fa6\n    return Right(f(fa1.value as A1, fa2.value as A2, fa3.value as A3, fa4.value as A4, fa5.value as A5, fa6.value as A6))\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<L, A, B>(a: A, f: (a: A) => Either<L, Either<A, B>>): Either<L, B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (!result.isRight()) return result as any\n\n      const some = result.value\n      if (some.isRight()) return Right(some.value)\n      cursor = some.value as A\n    }\n  }\n}\n\n/**\n * Result of the [[Left]] data constructor, representing\n * \"left\" values in the [[Either]] disjunction.\n *\n * @final\n */\nexport class TLeft<L> extends Either<L, never> {\n  public readonly value!: L\n  constructor(value: L) { super(value, \"left\") }\n}\n\n/**\n * The `Left` data constructor represents the left side of the\n * [[Either]] disjoint union, as opposed to the [[Right]] side.\n */\nexport function Left<L>(value: L): TLeft<L> {\n  return new TLeft(value)\n}\n\n/**\n * Result of the [[Right]] data constructor, representing\n * \"right\" values in the [[Either]] disjunction.\n *\n * @final\n */\nexport class TRight<R> extends Either<never, R> {\n  public readonly value!: R\n  constructor(value: R) { super(value, \"right\") }\n}\n\n/**\n * The `Right` data constructor represents the right side of the\n * [[Either]] disjoint union, as opposed to the [[Left]] side.\n */\nexport function Right<R>(value: R): TRight<R> {\n  return new TRight(value)\n}\n\n/**\n * Type enumerating the type-classes that `Either` implements.\n */\nexport type EitherTypes = Setoid<Either<any, any>> & Monad<\"funfix/either\">\n\n/**\n * Type-class implementations, compatible with the `static-land`\n * and `funland` specifications.\n *\n * See [funland-js.org](https://funland-js.org).\n */\nexport const EitherModule: EitherTypes = {\n  // Setoid\n  equals: (x, y) => x ? x.equals(y) : !y,\n  // Functor\n  map: <L, A, B>(f: (a: A) => B, fa: Either<L, A>) =>\n    fa.map(f),\n  // Apply\n  ap: <L, A, B>(ff: Either<L, (a: A) => B>, fa: Either<L, A>): Either<L, B> =>\n    fa.ap(ff),\n  // Applicative\n  of: Either.pure,\n  // Chain\n  chain: <L, A, B>(f: (a: A) => Either<L, B>, fa: Either<L, A>): Either<L, B> =>\n    fa.flatMap(f),\n  // ChainRec\n  chainRec: <L, A, B>(f: <C>(next: (a: A) => C, done: (b: B) => C, a: A) => Either<L, C>, a: A): Either<L, B> =>\n    Either.tailRecM(a, a => f(Either.left as any, Either.right as any, a))\n}\n\n// Registers Fantasy-Land compatible symbols\nfantasyLandRegister(Either, EitherModule, EitherModule)\n\n/**\n * Represents optional values, inspired by Scala's `Option` and by\n * Haskell's `Maybe` data types.\n *\n * Option is an immutable data type, represented as a sum type, being\n * either a [[Some]], in case it contains a single element, or a [[None]],\n * in case it is empty.\n *\n * The most idiomatic way to use an `Option` instance is to treat it\n * as a collection or monad and use `map`,`flatMap`, `filter`,\n * or `forEach`.\n *\n * @final\n */\nexport class Option<A> implements std.IEquals<Option<A>>, HK<\"funfix/option\", A> {\n  // tslint:disable-next-line:variable-name\n  private readonly _isEmpty: boolean\n  public readonly value: undefined | A\n\n  protected constructor(ref: A | undefined, isEmpty?: boolean) {\n    /* tslint:disable-next-line:strict-type-predicates */\n    this._isEmpty = isEmpty != null ? isEmpty : (ref === null || ref === undefined)\n    this.value = ref\n  }\n\n  /**\n   * Returns the option's value.\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   *\n   * @throws [[NoSuchElementError]] in case the option is empty\n   */\n  get(): A {\n    if (!this._isEmpty) return this.value as A\n    throw new NoSuchElementError(\"Option.get\")\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the given `fallback`.\n   *\n   * See [[Option.getOrElseL]] for a lazy alternative.\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    if (!this._isEmpty) return this.value as A\n    else return fallback\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return `null`.\n   * ```\n   */\n  orNull(): A | null {\n    return !this._isEmpty ? this.value as A : null\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return `undefined`.\n   */\n  orUndefined(): A | undefined {\n    return !this._isEmpty ? this.value : undefined\n  }\n\n  /**\n   * Returns the option's value if the option is nonempty, otherwise\n   * return the result of evaluating `thunk`.\n   *\n   * See [[Option.getOrElse]] for a strict alternative.\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    if (!this._isEmpty) return this.value as A\n    else return thunk()\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given `fallback`.\n   */\n  orElse<AA>(fallback: Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return fallback\n  }\n\n  /**\n   * Returns this option if it is nonempty, otherwise returns the\n   * given result of evaluating the given `thunk`.\n   *\n   * @param thunk a no-params function that gets evaluated and\n   *        whose result is returned in case this option is empty\n   */\n  orElseL<AA>(thunk: () => Option<AA>): Option<A | AA> {\n    if (!this._isEmpty) return this\n    else return thunk()\n  }\n\n  /**\n   * Returns `true` if the option is empty, `false` otherwise.\n   */\n  isEmpty(): this is TNone { return this._isEmpty }\n\n  /**\n   * Returns `true` if the option is not empty, `false` otherwise.\n   */\n  nonEmpty(): this is TSome<A> { return !this._isEmpty }\n\n  /**\n   * Returns an option containing the result of applying `f` to\n   * this option's value, or an empty option if the source is empty.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in an `Option`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Option<B> {\n    return this._isEmpty ? None : Some(f(this.value as A))\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value if\n   * the option is nonempty, otherwise returns an empty option.\n   *\n   * NOTE: this is similar with `map`, except that `flatMap` the\n   * result returned by `f` is expected to be boxed in an `Option`\n   * already.\n   *\n   * Example:\n   *\n   * ```typescript\n   * const opt = Option.of(10)\n   *\n   * opt.flatMap(num => {\n   *   if (num % 2 == 0)\n   *     Some(num + 1)\n   *   else\n   *     None\n   * })\n   * ```\n   *\n   * @param f the mapping function that will transform the value\n   *          of this option if nonempty.\n   *\n   * @return a new option instance containing the value of the\n   *         source mapped by the given function\n   */\n  flatMap<B>(f: (a: A) => Option<B>): Option<B> {\n    if (this._isEmpty) return None\n    else return f(this.value as A)\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Option<B>): Option<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * `Applicative` apply operator.\n   *\n   * Resembles {@link map}, but the passed mapping function is\n   * lifted in the `Either` context.\n   */\n  ap<B>(ff: Option<(a: A) => B>): Option<B> {\n    return ff.flatMap(f => this.map(f))\n  }\n\n  /**\n   * Returns this option if it is nonempty AND applying the\n   * predicate `p` to the underlying value yields `true`,\n   * otherwise return an empty option.\n   *\n   * @param p is the predicate function that is used to\n   *        apply filtering on the option's value\n   *\n   * @return a new option instance containing the value of the\n   *         source filtered with the given predicate\n   */\n  filter<B extends A>(p: (a: A) => a is B): Option<B>\n  filter(p: (a: A) => boolean): Option<A>\n  filter(p: (a: A) => boolean): Option<A> {\n    if (this._isEmpty || !p(this.value as A)) return None\n    else return this\n  }\n\n  /**\n   * Returns the result of applying `f` to this option's value,\n   * or in case the option is empty, the return the result of\n   * evaluating the `fallback` function.\n   *\n   * This function is equivalent with:\n   *\n   * ```typescript\n   * opt.map(f).getOrElseL(fallback)\n   * ```\n   *\n   * @param fallback is the function to be evaluated in case this\n   *        option is empty\n   *\n   * @param f is the mapping function for transforming this option's\n   *        value in case it is nonempty\n   */\n  fold<B>(fallback: () => B, f: (a: A) => B): B {\n    if (this._isEmpty) return fallback()\n    return f(this.value as A)\n  }\n\n  /**\n   * Returns true if this option is nonempty and the value it\n   * holds is equal to the given `elem`.\n   */\n  contains(elem: A): boolean {\n    return !this._isEmpty && std.is(this.value, elem)\n  }\n\n  /**\n   * Returns `true` if this option is nonempty and the given\n   * predicate returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  exists(p: (a: A) => boolean): boolean {\n    return !this._isEmpty && p(this.value as A)\n  }\n\n  /**\n   * Returns true if this option is empty or the given predicate\n   * returns `true` when applied on this option's value.\n   *\n   * @param p is the predicate function to test\n   */\n  forAll(p: (a: A) => boolean): boolean {\n    return this._isEmpty || p(this.value as A)\n  }\n\n  /**\n   * Apply the given procedure `cb` to the option's value if\n   * this option is nonempty, otherwise do nothing.\n   *\n   * @param cb the procedure to apply\n   */\n  forEach(cb: (a: A) => void): void {\n    if (!this._isEmpty) cb(this.value as A)\n  }\n\n  /**\n   * Implements {@link IEquals.equals}.\n   *\n   * @param that is the right hand side of the equality check\n   */\n  equals(that: Option<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    if (this.nonEmpty() && that.nonEmpty()) {\n      return std.is(this.value, that.value)\n    }\n    return this.isEmpty() && that.isEmpty()\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    if (this._isEmpty) return 2433880\n    // tslint:disable-next-line:strict-type-predicates\n    else if (this.value == null) return 2433881 << 2\n    else return std.hashCode(this.value) << 2\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _URI!: \"funfix/option\"\n  /** @hidden */ readonly _A!: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _Class: Option<any>\n\n  /**\n   * Builds an [[Option]] reference that contains the given value.\n   *\n   * If the given value is `null` or `undefined` then the returned\n   * option will be empty.\n   */\n  static of<A>(value: A | null | undefined): Option<A> {\n    return value != null ? Some(value) : None\n  }\n\n  /**\n   * Builds an [[Option]] reference that contains the given reference.\n   *\n   * Note that `value` is allowed to be `null` or `undefined`, the\n   * returned option will still be non-empty. Use [[Option.of]]\n   * if you want to avoid this problem. This means:\n   *\n   * ```typescript\n   * const opt = Some<number | null>(null)\n   *\n   * opt.isEmpty()\n   * //=> false\n   *\n   * opt.get()\n   * //=> null\n   * ```\n   */\n  static some<A>(value: A): Option<A> {\n    return new Option(value, false)\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static none<A = never>(): Option<A> {\n    return None\n  }\n\n  /**\n   * Returns an empty [[Option]].\n   *\n   * Similar to [[Option.none]], but this one allows specifying a\n   * type parameter (in the context of TypeScript or Flow or other\n   * type system).\n   *\n   * NOTE: Because `Option` is immutable, this function returns the\n   * same cached reference is on different calls.\n   */\n  static empty<A>(): Option<A> {\n    return None\n  }\n\n  /**\n   * Alias for [[Some]].\n   */\n  static pure<A>(value: A): Option<A> { return Some(value) }\n\n  /**\n   * Maps 2 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if both option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(3)\n   * Option.map2(Some(1), Some(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map2(Some(1), None,\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(\n    fa1: Option<A1>, fa2: Option<A2>,\n    f: (a1: A1, a2: A2) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty()\n      ? Some(f(fa1.value, fa2.value))\n      : None\n  }\n\n  /**\n   * Maps 3 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 3 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(6)\n   * Option.map3(Some(1), Some(2), Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map3(Some(1), None, Some(3),\n   *   (a, b, c) => a + b + c\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty()\n      ? Some(f(fa1.value, fa2.value, fa3.value))\n      : None\n  }\n\n  /**\n   * Maps 4 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 4 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(10)\n   * Option.map4(Some(1), Some(2), Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map4(Some(1), None, Some(3), Some(4),\n   *   (a, b, c, d) => a + b + c + d\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty()\n      ? Some(f(fa1.value, fa2.value, fa3.value, fa4.value))\n      : None\n  }\n\n  /**\n   * Maps 5 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 5 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(15)\n   * Option.map5(Some(1), Some(2), Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map5(Some(1), None, Some(3), Some(4), Some(5),\n   *   (a, b, c, d, e) => a + b + c + d + e\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty()\n      ? Some(f(fa1.value, fa2.value, fa3.value, fa4.value, fa5.value))\n      : None\n  }\n\n  /**\n   * Maps 6 optional values by the mapping function, returning a new\n   * optional reference that is `Some` only if all 6 option values are\n   * `Some`, otherwise it returns a `None`.\n   *\n   * ```typescript\n   * // Yields Some(21)\n   * Option.map6(Some(1), Some(2), Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   *\n   * // Yields None, because the second arg is None\n   * Option.map6(Some(1), None, Some(3), Some(4), Some(5), Some(6),\n   *   (a, b, c, d, e, f) => a + b + c + d + e + f\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Option<A1>, fa2: Option<A2>, fa3: Option<A3>, fa4: Option<A4>, fa5: Option<A5>, fa6: Option<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Option<R> {\n\n    return fa1.nonEmpty() && fa2.nonEmpty() && fa3.nonEmpty() && fa4.nonEmpty() && fa5.nonEmpty() && fa6.nonEmpty()\n      ? Some(f(fa1.value, fa2.value, fa3.value, fa4.value, fa5.value, fa6.value))\n      : None\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Option<Either<A, B>>): Option<B> {\n    let cursor = a\n    while (true) {\n      const result = f(cursor)\n      if (result.nonEmpty()) {\n        const some = result.value\n        if (some.isRight()) return Some(some.value)\n        cursor = some.value as A\n      } else {\n        return None\n      }\n    }\n  }\n}\n\n/**\n * Result of the [[Some]] data constructor, representing\n * non-empty values in the [[Option]] disjunction.\n */\nexport class TSome<A> extends Option<A> {\n  public readonly value!: A\n  constructor(value: A) { super(value, false) }\n}\n\n/**\n * The `Some<A>` data constructor for [[Option]] represents existing\n * values of type `A`.\n *\n * Using this function is equivalent with [[Option.some]].\n */\nexport function Some<A>(value: A): TSome<A> {\n  return new TSome(value)\n}\n\n/**\n * Result of the [[Some]] data constructor, representing\n * non-empty values in the [[Option]] disjunction.\n */\nexport class TNone extends Option<never> {\n  public readonly value!: undefined\n  private constructor() { super(undefined, true) }\n}\n\n/**\n * The `None` data constructor for [[Option]] represents non-existing\n * values for any type.\n *\n * Using this reference directly is equivalent with [[Option.none]].\n */\nexport const None: TNone =\n  new (TNone as any)()\n\n/**\n * Type enumerating the type classes implemented by `Option`.\n */\nexport type OptionTypes =\n  Setoid<Option<any>> &\n  Monad<\"funfix/option\">\n\n/**\n * Type-class implementations, compatible with the `static-land`\n * and `funland` specification.\n *\n * See [funland-js.org](https://funland-js.org).\n */\nexport const OptionModule: OptionTypes = {\n  // Setoid\n  equals: (x, y) => x ? x.equals(y) : !y,\n  // Functor\n  map: <A, B>(f: (a: A) => B, fa: Option<A>) =>\n    fa.map(f),\n  // Apply\n  ap: <A, B>(ff: Option<(a: A) => B>, fa: Option<A>): Option<B> =>\n    fa.ap(ff),\n  // Applicative\n  of: Option.pure,\n  // Chain\n  chain: <A, B>(f: (a: A) => Option<B>, fa: Option<A>): Option<B> =>\n    fa.flatMap(f),\n  // ChainRec\n  chainRec: <A, B>(f: <C>(next: (a: A) => C, done: (b: B) => C, a: A) => Option<C>, a: A): Option<B> =>\n    Option.tailRecM(a, a => f(Either.left as any, Either.right as any, a))\n}\n\n// Registers Fantasy-Land compatible symbols\nfantasyLandRegister(Option, OptionModule, OptionModule)\n\n/**\n * The `Try` type represents a computation that may either result in an\n * exception, or return a successfully computed value. It's similar to,\n * but semantically different from the [[Either]] type.\n *\n * `Try` is a sum type and so instances of `Try` are either instances\n * of [[Success]] or of [[Failure]].\n *\n * For example, `Try` can be used to perform division on a user-defined\n * input, without the need to do explicit exception-handling in all of\n * the places that an exception might occur.\n *\n * Example:\n *\n * ```typescript\n * function divide(dividendS: string, divisorS: string): string {\n *   const dividend = Try(() => parseInt(dividendS))\n *     .filter(_ => _ === _) // filter out NaN\n *   const divisor = Try(() => parseInt(divisorS))\n *     .filter(_ => _ === _)  // filter out NaN\n *\n *   // map2 executes the given function only if both results are\n *   // successful; we could also express this with flatMap / chain\n *   const result = Try.map2(dividend, divisor,\n *     (a, b) => a / b\n *   )\n *\n *   result.fold(\n *     error => `failure: ${error}`\n *     result => `result: ${result}`\n *   )\n * }\n * ```\n *\n * An important property of `Try` is its ability to pipeline, or chain,\n * operations, catching exceptions along the way. The `flatMap` and `map`\n * combinators each essentially pass off either their successfully completed\n * value, wrapped in the [[Success]] type for it to be further operated upon\n * by the next combinator in the chain, or the exception wrapped in the\n * [[Failure]] type usually to be simply passed on down the chain.\n * Combinators such as `recover` and `recoverWith` are designed to provide\n * some type of global behavior in the case of failure.\n *\n * NOTE: all `Try` combinators will catch exceptions and return failure\n * unless otherwise specified in the documentation.\n */\nexport class Try<A> implements std.IEquals<Try<A>>, HK<\"funfix/try\", A> {\n  private _isSuccess: boolean\n  public readonly value: Throwable | A\n\n  protected constructor(value: Throwable | A, tag: \"failure\" | \"success\") {\n    this._isSuccess = tag === \"success\"\n    this.value = value\n  }\n\n  /**\n   * Returns `true` if the source is a [[Success]] result,\n   * or `false` in case it is a [[Failure]].\n   */\n  isSuccess(): this is TSuccess<A> { return this._isSuccess }\n\n  /**\n   * Returns `true` if the source is a [[Failure]],\n   * or `false` in case it is a [[Success]] result.\n   */\n  isFailure(): this is TFailure { return !this._isSuccess }\n\n  /**\n   * Returns a Try's successful value if it's a [[Success]] reference,\n   * otherwise throws an exception if it's a [[Failure]].\n   *\n   * WARNING!\n   *\n   * This function is partial, the option must be non-empty, otherwise\n   * a runtime exception will get thrown. Use with care.\n   */\n  get(): A {\n    if (!this._isSuccess) throw this.value\n    return this.value as A\n  }\n\n  /**\n   * Returns the value from a `Success` or the given `fallback`\n   * value if this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElse(27) // 10\n   * Failure(\"error\").getOrElse(27)  // 27\n   * ```\n   */\n  getOrElse<AA>(fallback: AA): A | AA {\n    return this._isSuccess ? this.value as A : fallback\n  }\n\n  /**\n   * Returns the value from a `Success` or the value generated\n   * by a given `thunk` in case this is a `Failure`.\n   *\n   * ```typescript\n   * Success(10).getOrElseL(() => 27) // 10\n   * Failure(\"error\").getOrElseL(() => 27)  // 27\n   * ```\n   */\n  getOrElseL<AA>(thunk: () => AA): A | AA {\n    return this._isSuccess ? this.value as A : thunk()\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or\n   * if the source is a [[Failure]] then return `null`.\n   *\n   * ```typescript\n   * Success(10).orNull()      // 10\n   * Failure(\"error\").orNull() // null\n   * ```\n   *\n   * This can be useful for use-cases such as:\n   *\n   * ```typescript\n   * Try.of(() => dict.user.profile.name).orNull()\n   * ```\n   */\n  orNull(): A | null {\n    return this._isSuccess ? this.value as A : null\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or\n   * if the source is a [[Failure]] then return `undefined`.\n   *\n   * ```typescript\n   * Success(10).orUndefined()      // 10\n   * Failure(\"error\").orUndefined() // undefined\n   * ```\n   *\n   * This can be useful for use-cases such as:\n   *\n   * ```typescript\n   * Try.of(() => dict.user.profile.name).orUndefined()\n   * ```\n   */\n  orUndefined(): A | undefined {\n    return this._isSuccess ? this.value as A : undefined\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if\n   * the source is a [[Failure]] then return the `fallback`.\n   *\n   * ```typescript\n   * Success(10).orElse(Success(17))      // 10\n   * Failure(\"error\").orElse(Success(17)) // 17\n   * ```\n   */\n  orElse<AA>(fallback: Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return fallback\n  }\n\n  /**\n   * Returns the current value if it's a [[Success]], or if the source\n   * is a [[Failure]] then return the value generated by the given\n   * `thunk`.\n   *\n   * ```typescript\n   * Success(10).orElseL(() => Success(17))      // 10\n   * Failure(\"error\").orElseL(() => Success(17)) // 17\n   * ```\n   */\n  orElseL<AA>(thunk: () => Try<AA>): Try<A | AA> {\n    if (this._isSuccess) return this\n    return thunk()\n  }\n\n  /**\n   * Inverts this `Try`. If this is a [[Failure]], returns its exception wrapped\n   * in a [[Success]]. If this is a `Success`, returns a `Failure` containing a\n   * [[NoSuchElementError]].\n   */\n  failed(): Try<Throwable> {\n    return this._isSuccess\n      ? Failure(new NoSuchElementError(\"try.failed()\"))\n      : Success(this.value as Throwable)\n  }\n\n  /**\n   * Applies the `failure` function to [[Failure]] values, and the\n   * `success` function to [[Success]] values and returns the result.\n   *\n   * ```typescript\n   * const maybeNum: Try<number> =\n   *   tryParseInt(\"not a number\")\n   *\n   * const result: string =\n   *   maybeNum.fold(\n   *     error => `Could not parse string: ${error}`,\n   *     num => `Success: ${num}`\n   *   )\n   * ```\n   */\n  fold<R>(failure: (error: Throwable) => R, success: (a: A) => R): R {\n    return this._isSuccess\n      ? success(this.value as A)\n      : failure(this.value as Throwable)\n  }\n\n  /**\n   * Returns a [[Failure]] if the source is a [[Success]], but the\n   * given `p` predicate is not satisfied.\n   *\n   * @throws NoSuchElementError in case the predicate doesn't hold\n   */\n  filter<B extends A>(p: (a: A) => a is B): Try<B>\n  filter(p: (a: A) => boolean): Try<A>\n  filter(p: (a: A) => boolean): Try<A> {\n    if (!this._isSuccess) return this\n    try {\n      if (p(this.value as A)) return this\n      return Failure(\n        new NoSuchElementError(\n          `Predicate does not hold for ${this.value as A}`\n        ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Returns the given function applied to the value if this is\n   * a [[Success]] or returns `this` if this is a [[Failure]].\n   *\n   * This operation is the monadic \"bind\" operation.\n   * It can be used to *chain* multiple `Try` references.\n   *\n   * ```typescript\n   * Try.of(() => parse(s1)).flatMap(num1 =>\n   *   Try.of(() => parse(s2)).map(num2 =>\n   *     num1 / num2\n   *   ))\n   * ```\n   */\n  flatMap<B>(f: (a: A) => Try<B>): Try<B> {\n    if (!this._isSuccess) return this as any\n    try {\n      return f(this.value as A)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias for [[flatMap]]. */\n  chain<B>(f: (a: A) => Try<B>): Try<B> {\n    return this.flatMap(f)\n  }\n\n  /**\n   * `Applicative` apply operator.\n   *\n   * Resembles {@link map}, but the passed mapping function is\n   * lifted in the `Either` context.\n   */\n  ap<B>(ff: Try<(a: A) => B>): Try<B> {\n    return ff.flatMap(f => this.map(f))\n  }\n\n  /**\n   * Returns a `Try` containing the result of applying `f` to\n   * this option's value, but only if it's a `Success`, or\n   * returns the current `Failure` without any modifications.\n   *\n   * NOTE: this is similar with `flatMap`, except with `map` the\n   * result of `f` doesn't need to be wrapped in a `Try`.\n   *\n   * @param f the mapping function that will transform the value\n   *          of this `Try` if successful.\n   *\n   * @return a new `Try` instance containing the value of the\n   *         source mapped by the given function\n   */\n  map<B>(f: (a: A) => B): Try<B> {\n    return this._isSuccess\n      ? Try.of(() => f(this.value as A))\n      : ((this as any) as Try<B>)\n  }\n\n  /**\n   * Applies the given function `cb` if this is a [[Success]], otherwise\n   * returns `void` if this is a [[Failure]].\n   */\n  forEach(cb: (a: A) => void): void {\n    if (this._isSuccess) cb(this.value as A)\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recover<AA>(f: (error: Throwable) => AA): Try<A | AA> {\n    return this._isSuccess\n      ? this\n      : Try.of(() => f(this.value as Throwable))\n  }\n\n  /**\n   * Applies the given function `f` if this is a `Failure`, otherwise\n   * returns `this` if this is a `Success`.\n   *\n   * This is like `map` for the exception.\n   *\n   * In the following example, if the `user.profile.email` exists,\n   * then it is returned as a successful value, otherwise\n   *\n   * ```typescript\n   * Try.of(() => user.profile.email).recover(e => {\n   *   // Access error? Default to empty.\n   *   if (e instanceof TypeError) return \"\"\n   *   throw e // We don't know what it is, rethrow\n   * })\n   *\n   * Note that on rethrow, the error is being caught in `recover` and\n   * it still returns it as a `Failure(e)`.\n   * ```\n   */\n  recoverWith<AA>(f: (error: Throwable) => Try<AA>): Try<A | AA> {\n    try {\n      return this._isSuccess ? this : f(this.value as Throwable)\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Transforms the source into an [[Option]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Some(v)`. If the source is a `Failure(e)`, then a `None`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toOption() // Some(\"value\")\n   * Failure(\"error\").toOption() // None\n   * ```\n   */\n  toOption(): Option<A> {\n    return this._isSuccess ? Some(this.value as A) : None\n  }\n\n  /**\n   * Transforms the source into an [[Either]].\n   *\n   * In case the source is a `Success(v)`, then it gets translated\n   * into a `Right(v)`. If the source is a `Failure(e)`, then a `Left(e)`\n   * value is returned.\n   *\n   * ```typescript\n   * Success(\"value\").toEither() // Right(\"value\")\n   * Failure(\"error\").toEither() // Left(\"error\")\n   * ```\n   */\n  toEither(): Either<Throwable, A> {\n    return this._isSuccess\n      ? Right(this.value as A)\n      : Left(this.value as Throwable)\n  }\n\n  /**\n   * Implements {@link IEquals.equals} with overridable equality for `A`.\n   */\n  equals(that: Try<A>): boolean {\n    // tslint:disable-next-line:strict-type-predicates\n    if (that == null) return false\n    return this._isSuccess\n      ? that._isSuccess && std.is(this.value as A, that.value as A)\n      : !that._isSuccess && std.is(this.value, that.value)\n  }\n\n  // Implemented from IEquals\n  hashCode(): number {\n    return this._isSuccess\n      ? std.hashCode(this.value as A)\n      : std.hashCode(this.value as Throwable)\n  }\n\n  // Implements HK<F, A>\n  /** @hidden */ readonly _URI!: \"funfix/try\"\n  /** @hidden */ readonly _A!: A\n\n  // Implements Constructor<T>\n  /** @hidden */ static readonly _Class: Try<any>\n\n  /**\n   * Evaluates the given `thunk` and returns either a [[Success]],\n   * in case the evaluation succeeded, or a [[Failure]], in case\n   * an exception was thrown.\n   *\n   * Example:\n   *\n   * ```typescript\n   * let effect = 0\n   *\n   * const e = Try.of(() => { effect += 1; return effect })\n   * e.get() // 1\n   * ```\n   */\n  static of<A>(thunk: () => A): Try<A> {\n    try {\n      return Success(thunk())\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /** Alias of [[Try.success]]. */\n  static pure<A>(value: A): Try<A> {\n    return Try.success(value)\n  }\n\n  /**\n   * Shorthand for `now(undefined as void)`, always returning\n   * the same reference as optimization.\n   */\n  static unit(): Try<void> {\n    return tryUnitRef\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a successful result\n   * (i.e. wrapped in [[Success]]).\n   */\n  static success<A>(value: A): Try<A> {\n    return Success(value)\n  }\n\n  /**\n   * Returns a [[Try]] reference that represents a failure\n   * (i.e. an exception wrapped in [[Failure]]).\n   */\n  static failure<A = never>(e: Throwable): Try<A> {\n    return Failure(e)\n  }\n\n  /**\n   * Alias for {@link Try.failure} and {@link Failure},\n   * wrapping any throwable into a `Try` value.\n   */\n  static raise<A = never>(e: Throwable): Try<A> {\n    return Failure(e)\n  }\n\n  /**\n   * Maps 2 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if both `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(3)\n   * Try.map2(Success(1), Success(2),\n   *   (a, b) => a + b\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map2(Success(1), Failure(\"error\"),\n   *   (a, b) => a + b\n   * )\n   * ```\n   *\n   * This operation is the `Applicative.map2`.\n   */\n  static map2<A1,A2,R>(\n    fa1: Try<A1>, fa2: Try<A2>,\n    f: (a1: A1, a2: A2) => R): Try<R> {\n\n    if (fa1.isFailure()) return fa1\n    if (fa2.isFailure()) return fa2\n    try {\n      return Success(f(fa1.value as A1, fa2.value as A2))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 3 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 3 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(6)\n   * Try.map3(Success(1), Success(2), Success(3),\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *\n   *   (a, b, c) => {\n   *     return a + b + c\n   *   }\n   * )\n   * ```\n   */\n  static map3<A1,A2,A3,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>,\n    f: (a1: A1, a2: A2, a3: A3) => R): Try<R> {\n\n    if (fa1.isFailure()) return fa1\n    if (fa2.isFailure()) return fa2\n    if (fa3.isFailure()) return fa3\n    try {\n      return Success(f(\n        fa1.value as A1,\n        fa2.value as A2,\n        fa3.value as A3\n      ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 4 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 4 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(10)\n   * Try.map4(Success(1), Success(2), Success(3), Success(4),\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map3(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *\n   *   (a, b, c, d) => {\n   *     return a + b + c + d\n   *   }\n   * )\n   * ```\n   */\n  static map4<A1,A2,A3,A4,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4) => R): Try<R> {\n\n    if (fa1.isFailure()) return fa1\n    if (fa2.isFailure()) return fa2\n    if (fa3.isFailure()) return fa3\n    if (fa4.isFailure()) return fa4\n    try {\n      return Success(f(\n        fa1.value as A1,\n        fa2.value as A2,\n        fa3.value as A3,\n        fa4.value as A4\n      ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 5 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 5 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(15)\n   * Try.map5(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map5(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *\n   *   (a, b, c, d, e) => {\n   *     return a + b + c + d + e\n   *   }\n   * )\n   * ```\n   */\n  static map5<A1,A2,A3,A4,A5,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5) => R): Try<R> {\n\n    if (fa1.isFailure()) return fa1\n    if (fa2.isFailure()) return fa2\n    if (fa3.isFailure()) return fa3\n    if (fa4.isFailure()) return fa4\n    if (fa5.isFailure()) return fa5\n    try {\n      return Success(f(\n        fa1.value as A1,\n        fa2.value as A2,\n        fa3.value as A3,\n        fa4.value as A4,\n        fa5.value as A5\n      ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Maps 6 `Try` values by the mapping function, returning a new\n   * `Try` reference that is a `Success` only if all 6 `Try` values are\n   * a `Success`, otherwise it returns the first `Failure` noticed.\n   *\n   * ```typescript\n   * // Yields Success(21)\n   * Try.map6(\n   *   Success(1),\n   *   Success(2),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   *\n   * // Yields Failure, because the second arg is a Failure\n   * Try.map6(\n   *   Success(1),\n   *   Failure(\"error\"),\n   *   Success(3),\n   *   Success(4),\n   *   Success(5),\n   *   Success(6),\n   *\n   *   (a, b, c, d, e, f) => {\n   *     return a + b + c + d + e + f\n   *   }\n   * )\n   * ```\n   */\n  static map6<A1,A2,A3,A4,A5,A6,R>(\n    fa1: Try<A1>, fa2: Try<A2>, fa3: Try<A3>, fa4: Try<A4>, fa5: Try<A5>, fa6: Try<A6>,\n    f: (a1: A1, a2: A2, a3: A3, a4: A4, a5: A5, a6: A6) => R): Try<R> {\n\n    if (fa1.isFailure()) return fa1\n    if (fa2.isFailure()) return fa2\n    if (fa3.isFailure()) return fa3\n    if (fa4.isFailure()) return fa4\n    if (fa5.isFailure()) return fa5\n    if (fa6.isFailure()) return fa6\n    try {\n      return Success(f(\n        fa1.value as A1,\n        fa2.value as A2,\n        fa3.value as A3,\n        fa4.value as A4,\n        fa5.value as A5,\n        fa6.value as A6\n      ))\n    } catch (e) {\n      return Failure(e)\n    }\n  }\n\n  /**\n   * Keeps calling `f` until a `Right(b)` is returned.\n   *\n   * Based on Phil Freeman's\n   * [Stack Safety for Free]{@link http://functorial.com/stack-safety-for-free/index.pdf}.\n   *\n   * Described in `FlatMap.tailRecM`.\n   */\n  static tailRecM<A, B>(a: A, f: (a: A) => Try<Either<A, B>>): Try<B> {\n    let cursor = a\n    while (true) {\n      try {\n        const result = f(cursor)\n        if (result.isFailure()) return result as any\n\n        const some = result.get()\n        if (some.isRight()) return Success(some.value)\n        cursor = some.value as A\n      } catch (e) {\n        return Failure(e)\n      }\n    }\n  }\n}\n\n/**\n * Result of the [[Success]] data constructor, representing\n * successful values in the [[Try]] disjunction.\n *\n * @final\n */\nexport class TSuccess<A> extends Try<A> {\n  public readonly value!: A\n  constructor(value: A) { super(value, \"success\") }\n}\n\n/**\n * The `Success` data constructor is for building [[Try]] values that\n * are successful results of computations, as opposed to [[Failure]].\n */\nexport function Success<A>(value: A): Try<A> {\n  return new TSuccess(value)\n}\n\n/**\n * The `Success` data constructor is for building [[Try]] values that\n * are successful results of computations, as opposed to [[Failure]].\n *\n * @final\n */\nexport class TFailure extends Try<never> {\n  public readonly value!: Throwable\n  constructor(value: Throwable) { super(value, \"failure\") }\n}\n\n/**\n * The `Failure` data constructor is for building [[Try]] values that\n * represent failures, as opposed to [[Success]].\n */\nexport function Failure(e: Throwable): Try<never> {\n  return new TFailure(e)\n}\n\n/**\n * Type enumerating the type classes implemented by `Try`.\n */\nexport type TryTypes =\n  Setoid<Try<any>> &\n  Monad<\"funfix/try\">\n\n/**\n * Type-class implementations, compatible with the `static-land`\n * and `funland` specifications.\n *\n * See [funland-js.org](https://funland-js.org).\n */\nexport const TryModule: TryTypes = {\n  // Setoid\n  equals: (x, y) => x ? x.equals(y) : !y,\n  // Functor\n  map: <A, B>(f: (a: A) => B, fa: Try<A>) =>\n    fa.map(f),\n  // Apply\n  ap: <A, B>(ff: Try<(a: A) => B>, fa: Try<A>): Try<B> =>\n    fa.ap(ff),\n  // Applicative\n  of: Try.pure,\n  // Chain\n  chain: <A, B>(f: (a: A) => Try<B>, fa: Try<A>): Try<B> =>\n    fa.flatMap(f),\n  // ChainRec\n  chainRec: <A, B>(f: <C>(next: (a: A) => C, done: (b: B) => C, a: A) => Try<C>, a: A): Try<B> =>\n    Try.tailRecM(a, a => f(Either.left as any, Either.right as any, a))\n}\n\n// Registers Fantasy-Land compatible symbols\nfantasyLandRegister(Try, TryModule, TryModule)\n\n/**\n * Reusable reference, to use in {@link Try.unit}.\n *\n * @private\n * @hidden\n */\nconst tryUnitRef: Try<void> = Success(undefined)\n"],"names":["ref","equals","hashCode","lh","rh","valueOf","lh2","rh2","isValueObject","is","universalSetoid","v","hashCodeOfString","String","str","hash","length","i","character","charCodeAt","a","derivedCtor","baseCtors","forEach","getOwnPropertyNames","baseCtor","prototype","name","errors","reasons","slice","e","message","Error","errorsRef","self","constructor","CompositeError","__proto__","DummyError","NoSuchElementError","IllegalInheritanceError","IllegalStateError","IllegalArgumentError","NotImplementedError","TimeoutError","f","args","Array","call","arguments","push","apply","undefined","cls","monad","setoid","c","p","fl","flEquals","map","flMap","ap","flAp","flOf","chain","flChain","chainRec","flChainRec","convertToMethod","of","value","tag","_isRight","elem","std","zero","Left","flatMap","ff","left","right","fallback","thunk","Right","cb","Some","None","that","TRight","fa1","fa2","isLeft","fa3","fa4","fa5","fa6","cursor","result","isRight","some","Either","TLeft","EitherModule","x","y","fa","pure","tailRecM","fantasyLandRegister","isEmpty","_isEmpty","nonEmpty","Option","TSome","TNone","OptionModule","_isSuccess","Failure","Success","failure","success","Try","tryUnitRef","isFailure","get","TSuccess","TFailure","TryModule"],"mappings":"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"}