{"version":3,"file":"kingly.es.min.js","sources":["../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js"],"sourcesContent":["export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, MACHINE_CREATION_ERROR_MSG,\r\n  NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop, group:noop, groupEnd: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\n/**\r\n * @description takes an output and turns it into an array\r\n * @param {*} output\r\n * @returns {*[]|null} if the output is null: null, if output is an array: output, else: [output]\r\n */\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {HistoryState} _history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {HistoryState}\r\n * @modifies history\r\n */\r\nexport function updateHistory(_history, stateAncestors, state_from_name) {\r\n  // 27.08.2020: Now that I expose history state I have to make sure that it is not mutated!!\r\n  // We have a fixed format here, so we use native `assign` at deepest level\r\n  const history = {\r\n    [DEEP]: Object.assign({}, _history[DEEP]),\r\n    [SHALLOW]: Object.assign({}, _history[SHALLOW]),\r\n  };\r\n\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function(...*): True | Error} contract Contract that either fulfills or returns an error\r\n * @param {Array<*>} arrayParams Parameters to be passed to the contract\r\n * @returns {undefined|{when, location, info, message}|Object} either true (fulfilled contract)\r\n * or an object with optional properties for diagnostic and tracing purposes\r\n * about the cause of the error if the contract is not fulfilled\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport function wrapUpdateStateFn(userProvidedUpdateStateFn, {throwKinglyError, tracer}){\r\n  return (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n}\r\n\r\nexport function throwKinglyErrorFactory (console,tracer)  {\r\n  return obj => {\r\n  throw new KinglyError(obj, console, tracer)\r\n  }\r\n};\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n  emptyConsole,\r\n  findInitTransition,\r\n  getAncestorMap,\r\n  getEventTransitionsMaps,\r\n  getHistoryStatesMap,\r\n  getHistoryUnderlyingState,\r\n  getStatesPath,\r\n  getStatesTransitionsMap,\r\n  getStateEventTransitionsMaps,\r\n  getStatesType,\r\n  getTargetStatesMap,\r\n  isActionFactory,\r\n  isControlState,\r\n  isEvent,\r\n  isFunction,\r\n  isHistoryControlState,\r\n  noop\r\n} from \"./helpers\"\r\n// @ts-ignore\r\nimport { objectTreeLenses, PRE_ORDER, traverseObj } from \"fp-rosetree\"\r\nimport { CONTRACTS_EVAL, INIT_EVENT, INIT_STATE, MACHINE_CREATION_ERROR_MSG } from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n  name: 'noDuplicatedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { getLabel } = objectTreeLenses;\r\n    const traverse = {\r\n      strategy: PRE_ORDER,\r\n      seed: { duplicatedStates: [], statesHashMap: {} },\r\n      visit: (acc, traversalState, tree) => {\r\n        const { duplicatedStates, statesHashMap } = acc;\r\n        const treeLabel = getLabel(tree);\r\n        const controlState = Object.keys(treeLabel)[0];\r\n        if (controlState in statesHashMap) {\r\n          return {\r\n            duplicatedStates: duplicatedStates.concat(controlState),\r\n            statesHashMap\r\n          }\r\n        }\r\n        else {\r\n          return {\r\n            duplicatedStates,\r\n            statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const { duplicatedStates } = traverseObj(traverse, fsmDef.states);\r\n\r\n    const isFulfilled = duplicatedStates.length === 0;\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n        info: { duplicatedStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n  name: 'noReservedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n      blame: {\r\n        message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n        info: { reservedStates: [INIT_STATE], statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n  name: 'atLeastOneState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).length > 0,\r\n      blame: {\r\n        message: `Machine configuration must define at least one control state! Cf. log`,\r\n        info: { statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n  name: 'isInitialControlStateDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition, statesType }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const stateList = Object.keys(statesType);\r\n    if (initialControlState) {\r\n      return {\r\n        isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n        blame: {\r\n          message: `Configured initial control state must be a declared state. Cf. log`,\r\n          info: { initialControlState, declaredStates: stateList }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n\r\n  },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n  name: 'eventsAreStrings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    return {\r\n      isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n      blame: {\r\n        message: `Events must be an array of strings!`,\r\n        info: { events: fsmDef.events }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n  name: 'validInitialConfig',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState } = fsmDef;\r\n\r\n    if (initTransition && initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else if (!initTransition && !initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n  },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n  name: 'validInitialTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const initTransitions = transitions.reduce((acc, transition) => {\r\n      transition.from === INIT_STATE && acc.push(transition);\r\n      return acc\r\n    }, []);\r\n    // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n    // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n    // enforce the part of the contract which require to have no actions for initial transitions...\r\n    const isFulfilled =\r\n      (initialControlState && !initTransition) ||\r\n      (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n        && (\r\n          isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n          || areCconditionalTransitions(initTransition)\r\n          // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n        )\r\n      );\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Invalid configuration for initial transition! Cf. log`,\r\n        info: { initTransition, initTransitions, initialControlState }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n  name: 'initEventOnlyInCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n    const atomicInitTransitions = atomicStates.map(\r\n      atomicState => ({\r\n        [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n      })\r\n    ).filter(obj => Object.values(obj)[0]);\r\n\r\n    const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n    return {\r\n      isFulfilled: hasInitEventOnlyInCompoundStates,\r\n      blame: {\r\n        message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n        info: { initTransitions: atomicInitTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n  name: 'validInitialTransitionForCompoundState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n    const compoundStatesInitTransitions = compoundStates.map(\r\n      compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n    const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n    if (!allHaveInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state without an entry transition! Cf. log`,\r\n          info: {\r\n            hasEntryTransitions: compoundStates.map(\r\n              state => ({ [state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT]) }))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { guards, to } = initTransition;\r\n        if (!guards) {\r\n          //  T7a\r\n          return typeof to === 'string'\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(targetState => typeof targetState === 'string')\r\n        }\r\n      });\r\n    if (!allHaveValidInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n          info: { entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n    ;\r\n\r\n    const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { from, guards, to } = initTransition;\r\n\r\n        // Don't forget to also eliminate the case when from = to\r\n        // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n        // other from declared states\r\n        if (!guards) {\r\n          return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(to => {\r\n            return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n          })\r\n        }\r\n      });\r\n    if (!allHaveTargetStatesWithinHierarchy) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n          info: { states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n  name: 'validEventLessTransitions',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const stateList = Object.keys(statesType);\r\n    const failingOriginControlStates = stateList.map(state => {\r\n      return {\r\n        [state]: statesTransitionsMap[state] &&\r\n        `${void 0}` in statesTransitionsMap[state] &&\r\n        Object.keys(statesTransitionsMap[state]).length !== 1\r\n      }\r\n    }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n    const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n        info: { failingOriginControlStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n  name: 'allStateTransitionsOnOneSingleRow',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n      const events = Object.keys(stateEventTransitionsMaps[state]);\r\n      const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n      if (wrongEventConfig.length > 0) {\r\n        acc[state] = wrongEventConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n        info: { statesTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n  name: 'noConflictingTransitionsWithAncestorState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n    const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n      const states = Object.keys(eventTransitionsMaps[event]);\r\n      // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n      const wrongStateConfig = states\r\n        .filter(state => state !== INIT_STATE)\r\n        .map(state => ancestorMap[state] && {\r\n          [state]: ancestorMap[state].find(\r\n            ancestorState => states.indexOf(ancestorState) > -1\r\n          )\r\n        })\r\n        // removing cases : undefined and {[state]: undefined}\r\n        .filter(obj => {\r\n          return obj && Object.values(obj).filter(Boolean).length > 0\r\n        });\r\n\r\n      if (wrongStateConfig.length > 0) {\r\n        acc[event] = wrongStateConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n        info: { eventTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n  name: 'isHistoryStatesTargetStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, {}) => {\r\n    const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n      return isHistoryControlState(transition.from)\r\n        ? acc.concat(transition)\r\n        : acc\r\n    }, []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n        info: { wrongHistoryStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n  name: 'isHistoryStatesCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const wrongHistoryStates = originStateList.map(originState => {\r\n      if (originState === INIT_STATE) return []\r\n\r\n      const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n      return events.reduce((acc, event) => {\r\n        // I should only ever have one transition, that is checked in another contract\r\n        // !! if there are several transitions, we may have a false positive, but that is ok\r\n        // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n        // this will be recomputed correctly\r\n        const transition = stateEventTransitionsMaps[originState][event][0];\r\n        const { guards, to } = transition;\r\n        if (!guards) {\r\n          // Reminder: statesType[controlState] === true iff controlState is compound state\r\n          return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n            ? acc.concat(transition)\r\n            : acc\r\n        }\r\n        else {\r\n          return guards.reduce((acc, guard) => {\r\n            const { to } = guard;\r\n\r\n            return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n              ? acc.concat(transition)\r\n              : acc\r\n          }, acc)\r\n        }\r\n      }, [])\r\n    })\r\n      .reduce((acc, x) => acc.concat(x), []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n        info: { wrongHistoryStates, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n  name: 'isHistoryStatesExisting',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { historyStatesMap, statesType }) => {\r\n    const invalidTransitions = Array.from(historyStatesMap.entries())\r\n      .map(([historyState, flatTransitions]) => {\r\n        return !(historyState in statesType) && { historyState, flatTransitions }\r\n      })\r\n      .filter(Boolean);\r\n\r\n    const howMany = Object.keys(invalidTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n        info: { invalidTransitions, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n  const { from, event, guards, to, action } = transition;\r\n\r\n  return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n  const { to, predicate, action } = guard;\r\n\r\n  return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n  const { from, event, guards, to } = transition;\r\n\r\n  return guards && Array.isArray(guards) && guards.length > 0\r\n    && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n  name: 'isValidFsmDef',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions, states, events, initialExtendedState } = fsmDef;\r\n    const isValidTransitions = transitions && Array.isArray(transitions);\r\n    const isValidStates = states && typeof(states) === 'object';\r\n    const isValidEvents = events && Array.isArray(events);\r\n    if (!isValidTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The transitions property for a machine definition must be an array!`,\r\n          info: { transitions }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidStates) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The states property for a machine definition must be an object!`,\r\n          info: { states }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidEvents) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The events property for a machine definition must be an array!`,\r\n          info: { events }\r\n        }\r\n      }\r\n    }\r\n    // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n    // this is done in other contracts\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n  name: 'haveTransitionsValidTypes',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions } = fsmDef;\r\n    const wrongTransitions = transitions\r\n      .map((transition, transitionIndex) => {\r\n        return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n          transition,\r\n          index: transitionIndex\r\n        }\r\n      })\r\n      .filter(Boolean)\r\n\r\n    const howMany = Object.keys(wrongTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n        info: { wrongTransitions, transitions }\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n  name: 'areEventsDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { eventTransitionsMaps }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps);\r\n    const declaredEventList = fsmDef.events;\r\n    const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n      .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n      .filter(Boolean);\r\n    const eventsNotDeclaredButTriggeringTransitions = eventList\r\n      .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n      .filter(Boolean)\r\n      // Filtering out init events which must not be declared, being reserved events\r\n      // Filtering out undefined events linked to eventless transitions\r\n      .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n    const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n      && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n        info: { eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n  name: 'areStatesDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, targetStatesMap, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n    const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n      stateList.forEach(state => acc[state] = true)\r\n      return acc\r\n    }, {}));\r\n    const declaredStateList = Object.keys(statesType);\r\n    const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n      .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n      .filter(Boolean);\r\n    const statesNotDeclaredButTriggeringTransitions = stateList\r\n      .map(stateInTransition =>\r\n        stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n      .filter(Boolean);\r\n\r\n    const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n      && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n        info: { statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n  name: 'isValidSettings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef) => {\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n  name: 'isInitialStateOriginState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap }) => {\r\n\r\n    if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one transition with the initial state as target state! CF. log`,\r\n          info: { targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n  name: 'isValidSelfTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap, statesType }) => {\r\n    const targetStates = Array.from(targetStatesMap.keys());\r\n    const wrongSelfTransitions = targetStates\r\n      .map(targetState => {\r\n        const flatTransitions = targetStatesMap.get(targetState);\r\n        return flatTransitions\r\n          .map(flatTransition => {\r\n            const { from, event } = flatTransition;\r\n            if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n              return { state: targetState, flatTransition }\r\n            }\r\n          })\r\n          .filter(Boolean)\r\n      })\r\n      .filter(x => x.length > 0);\r\n\r\n    return {\r\n      isFulfilled: wrongSelfTransitions.length === 0,\r\n      blame: {\r\n        message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n        info: { wrongSelfTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const fsmContracts = {\r\n  injected: (fsmDef, settings) => {\r\n    return {\r\n      statesType: getStatesType(fsmDef.states),\r\n      initTransition: findInitTransition(fsmDef.transitions),\r\n      statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n      stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n      eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n      ancestorMap: getAncestorMap(fsmDef.states),\r\n      statesPath: getStatesPath(fsmDef.states),\r\n      historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n      targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n    }\r\n  },\r\n  description: 'FSM structure',\r\n  contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n  const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n  const trace = settings && settings.debug && settings.debug.trace || noop;\r\n  const contractsDescription = contractsDef.description;\r\n\r\n  return function checkContracts(...args) {\r\n    const failingContracts = [];\r\n    const computedArgs = contractsDef.injected.apply(null, args);\r\n    const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n      const { name: contractName, predicate, shouldThrow } = contract;\r\n      const fullArgs = args.concat(computedArgs);\r\n      const { isFulfilled, blame } = predicate.apply(null, fullArgs);\r\n      const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n      const { message, info } = blame || {};\r\n\r\n      if (isFulfilled) return acc\r\n      else {\r\n        failingContracts.push({ name: contractName, message, info });\r\n        console.error(blameMessageHeader);\r\n        console.error([contractName, message].join(': '));\r\n        console.debug('Supporting error data:', info);\r\n\r\n        if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n        else {\r\n          return false\r\n        }\r\n      }\r\n    }, true)\r\n\r\n    const contractsEval = { isFulfilled, failingContracts };\r\n    trace({ [CONTRACTS_EVAL]: contractsEval })\r\n\r\n    return contractsEval\r\n  }\r\n}\r\n\r\n// @ts-ignore error here is due to variable number of arguments, not worth spending time there\r\nexport const fsmContractChecker = (fsmDef, settings,\r\n                                   fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\nexport function runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer }) {\r\n  if (checkContracts) {\r\n    const { failingContracts } = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: { fsmDef, settings, failingContracts },\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: { cs: void 0, es: void 0, hs: void 0 }\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","//@ts-check\r\nimport {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap,\r\n  throwKinglyErrorFactory, wrapUpdateStateFn\r\n} from \"./helpers\";\r\nimport { runContracts } from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * @description Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state`: Hash matching keys (state names) to whether that state is a nested state\r\n * `hash_states`: Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hashStates: {}, isGroupState: Object<String,Boolean>}}\r\n */\r\nfunction buildNestedStateStructure(states) {\r\n  const root_name = \"State\";\r\n  let hashStates = {};\r\n  let isGroupState = {};\r\n\r\n  // Add the starting state\r\n  states = { nok: states };\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hashStates[state_name] = new curr_constructor();\r\n      hashStates[state_name].name = state_name;\r\n      const parent_name = (hashStates[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hashStates[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        isGroupState[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hashStates[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hashStates[INIT_STATE] = new State();\r\n  hashStates[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hashStates: hashStates,\r\n    isGroupState: isGroupState\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const { initialControlState, transitions } = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{ from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY }])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} [settings]\r\n * @returns {Error | Stateful_FSM}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withProtectedState\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @returns {Error | Pure_FSM}\r\n */\r\nexport function createPureStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withPureInterface\r\n}\r\n\r\n/**\r\n * @description Creates an instance of state machine from a set of states, transitions,\r\n * and accepted events. The initial extended state for the machine is included\r\n * in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {{withProtectedState: Stateful_FSM, withPureInterface: Pure_FSM}|Error}\r\n */\r\nexport function createStateMachineAPIs(fsmDef, settings) {\r\n  const {\r\n    states: controlStates,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const { debug, devTool, displayName } = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = throwKinglyErrorFactory(console, tracer);\r\n\r\n  // Check contracts if the API user wants to,\r\n  // but don't throw errors, return them and possibly log them\r\n  if (checkContracts) {\r\n    const e = runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer });\r\n    if (e instanceof Error) return e\r\n  }\r\n\r\n  // Wrap user-provided update state function to capture errors\r\n  const wrappedUpdateState = wrapUpdateStateFn(userProvidedUpdateStateFn, { throwKinglyError, tracer });\r\n  // We also massage the shape of the user-provided transitions,\r\n  // unifying the two ways of providing an initial state for the machine\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create auxiliary data structures to quickly answer common queries:\r\n  // - is `stateName` a state that has an initial transition configured\r\n  //   (top-level, or compound state) : `isInitState[stateName]`\r\n  // - is `stateName` a transient state, i.e. with an configured\r\n  //   initial or eventless transitions: `isAutoState[stateName]`\r\n  // - is `stateName` a compound state: `isGroupState[stateName]`\r\n  // - what computation to run in `stateName`:\r\n  //   `hashStates[stateName][event]` has the event handler for `event`\r\n  //    NOTE: we use JS prototypal inheritance to make this work even when\r\n  //    A < ... < B. and the event handler in configured on parent A, and not on B\r\n  //    When the machine is in state B, it must answer to the event as A would\r\n  const hashStatesStruct = buildNestedStateStructure(controlStates);\r\n  // @type {Object<state_name,boolean>}\r\n  let isInitState = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let isAutoState = {};\r\n  // @type {Object<state_name,boolean>}\r\n  const isGroupState = hashStatesStruct.isGroupState;\r\n  let hashStates = hashStatesStruct.hashStates;\r\n\r\n  // Fill in the auxiliary data structures\r\n  transitions.forEach(function (transition) {\r\n    let { from, to, action, event, guards: arr_predicate } = transition;\r\n    // CASE: ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{ predicate: void 0, to: to, action: action }];\r\n\r\n    // CASE: transition has a init event\r\n    // NOTE: there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      isInitState[from] = true;\r\n    }\r\n\r\n    let from_proto = hashStates[from];\r\n\r\n    // CASE: automatic transitions: no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      isAutoState[from] = true;\r\n    }\r\n    // CASE: automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (isGroupState[from] && isInitState[from]) {\r\n      isAutoState[from] = true;\r\n    }\r\n\r\n    // NTH: this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce(\r\n      (acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index },\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: { event, guard, from, to, index, shouldTransitionBeTaken },\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState_, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: { extendedState, event, event_data, settings, guard, from, to, index, action },\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index, action, actionResult },\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const { updates, outputs } = actionResult;\r\n\r\n              // Leave the current state\r\n              leaveState(from, extendedState_, hashStates);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const newControlState = enterNextState(to, updates, hashStates);\r\n              console.info(\"ENTERING NEXT STATE: \", cs);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return { stop: true, outputs };\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: { eventData: event_data, settings, guard, from, to, index, action: actionName },\r\n                  machineState: { cs: current_state, es: extendedState, hs: history }\r\n                }\r\n              });\r\n              return { stop: false, outputs: null };\r\n            }\r\n          };\r\n\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return { stop: false, outputs: null };\r\n      }\r\n    );\r\n  });\r\n\r\n  // Setting up the initial state of the machine in closure\r\n  // That is the control state, history state, and extended state\r\n  // NOTE: the user-provided update function by contract cannot update in place\r\n  // There is thus no need to clone the initial extended state.\r\n  const { stateList, stateAncestors } = computeHistoryMaps(controlStates);\r\n  let history = initHistoryDataStructure(stateList);\r\n  let extendedState = initialExtendedState;\r\n  let cs = INIT_STATE;\r\n\r\n  // Run the machine's initial transition\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: { fsmDef, settings, error: e },\r\n        machineState: { cs: INIT_STATE, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    console && console.error(`An error occurred when starting the machine`, e)\r\n\r\n    return e\r\n  }\r\n\r\n  const fsmAPIs = {\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine. The function receives the input to be\r\n     *   processed by the machine, and outputs the results of the machine computation. In the general case, the machine\r\n     *   computes an array of values. The array can be empty, and when not, it may contain null values. The machine may\r\n     *   also return null (in csae of an input that the machine is not configured to react to) instead of returning an\r\n     *   array.\r\n     * @param {*} input\r\n     * @returns {FSM_Outputs|Error}\r\n     * @throws if an error is produced that is not an error recognized by Kingly. This generally means an unexpected\r\n     *   exception has occurred.\r\n     */\r\n    withProtectedState: function fsm(input) {\r\n      try {\r\n        const { eventName, eventData } = destructureEvent(input);\r\n\r\n        tracer({\r\n          type: INPUT_MSG,\r\n          trace: {\r\n            info: { eventName, eventData },\r\n            machineState: { cs: cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        const outputs = sendEvent(input, false);\r\n\r\n        debug && console.info(\"OUTPUTS:\", outputs);\r\n        tracer({\r\n          type: OUTPUTS_MSG,\r\n          trace: {\r\n            outputs,\r\n            machineState: { cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        return outputs\r\n      }\r\n      catch (e) {\r\n        if (e instanceof KinglyError) {\r\n          // We don't break the program, but we can't continue as if nothing happened: we return the error\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return e\r\n        }\r\n        else {\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An unknown error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n          console.error(`yyield > unexpected error!`, e);\r\n          // We should only catch the errors we are responsible for!\r\n          throw e\r\n        }\r\n      }\r\n    },\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine but requires to be passed both the\r\n     *   machine internal state and an input from which to compute the machine outputs. According to the parameter\r\n     *   passed as internal state, the machine may: 1. (undefined) compute outputs from the last state of the machine,\r\n     *   1. (null) compute outputs, restarting from its initial state, 3. (truthy) compute outputs from the given state\r\n     *   of the machine\r\n     * @param {*} input\r\n     * @param {FSM_Internal_State} fsmState\r\n     * @returns {{outputs: FSM_Outputs|Error, fsmState: FSM_Internal_State}}\r\n     */\r\n    withPureInterface: function compute(input, fsmState) {\r\n      if (fsmState === void 0) {\r\n        // Don't update the state of the state machine\r\n        // This means the machine will continue processing inputs\r\n        // using its current state\r\n      }\r\n      else if (fsmState === null) {\r\n        // Reinitialize the machine\r\n        extendedState = initialExtendedState;\r\n        history = initHistoryDataStructure(stateList);\r\n        hashStates[INIT_STATE].current_state_name = INIT_STATE;\r\n        start();\r\n      }\r\n      else {\r\n        // Reset the state (available in closure) of the state machine\r\n        const { cs: _cs, hs, es } = fsmState;\r\n        extendedState = es;\r\n        history = hs;\r\n        cs = _cs;\r\n      }\r\n\r\n      // run the machine\r\n      const outputs = fsmAPIs.withProtectedState(input);\r\n      // NOTE: history does not need to be cloned here! We do not update the\r\n      // history in place => No risk of accidentally modifying the history\r\n      // of another machine\r\n      // TODO: We should however definitely clone `extendedState` How to modify the API?\r\n      // Require a clone function in settings? with a default of JSON.stringify?\r\n      // or we shift the responsibility on the API user to do the cloning?\r\n      // Good: faster in the default case, simpler library too, no cloning when not needed\r\n      // Bad: library user can forget, so footgun...\r\n      // ADR: API that forces to signal a clone function, which can be DEFAULT_CLONE\r\n      return { outputs, fsmState: { cs, hs: history, es: extendedState } }\r\n    }\r\n  };\r\n\r\n  return fsmAPIs\r\n\r\n  // Auxiliary functions\r\n  //\r\n\r\n  /**\r\n   *\r\n   * @param {function(...*): True | Error} contract\r\n   * @param {Array<*>} arrayParams\r\n   * @returns {undefined}\r\n   * @throws KinglyError in case of one or more failing contracts\r\n   */\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  /**\r\n   * @description process an input (aka event) according to the machine specifications.\r\n   * @param {LabelledEvent} event_struct input to be processed by the machine\r\n   * @param {Boolean} isInternalEvent should be true iff the event is sent by Kingly, not by the\r\n   * API user. API user should always leave this undefined.\r\n   * This works around an edge case discovered through testing.\r\n   * With the fix implemented here, API users that send an INIT_EVENT will have it ignored.\r\n   * INIT_EVENT is reserved and API users should not use it. This fix is for robustness purposes.\r\n   * @returns {FSM_Outputs|null}\r\n   */\r\n  function sendEvent(event_struct, isInternalEvent) {\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const { eventName, eventData } = destructureEvent(event_struct);\r\n\r\n    console.group(\"send event \" + eventName || \"\");\r\n    console.log(event_struct);\r\n\r\n    // Edge case to deal with: INIT_EVENT sent and the current state is the initial state\r\n    // This is a side-effect of our implementation that leverages JS prototypes.\r\n    // The INIT_STATE is a super-state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation.\r\n    // This led to a bug where an API user would maliciously send the reserved INIT_EVENT,\r\n    // thus resetting the machine in its initial state, with an unpredictable extended state!\r\n    // That, in turn, results from a **design mistake** that I will not correct here, which consisted\r\n    // in letting API users configure an initial control state, OR initial INIT_EVENT transitions.\r\n    // ADR: the impact is small, the fix is ok. API users have more flexibility at the\r\n    // cost of implementation complexity. But next time, pick simplicity over flexibility.\r\n    if (!isInternalEvent && eventName === INIT_EVENT && cs !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { eventName, eventData },\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n      console.groupEnd();\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = processEvent(\r\n      hashStatesStruct.hashStates,\r\n      eventName,\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    console.groupEnd();\r\n\r\n    return outputs\r\n  }\r\n\r\n  function processEvent(hashStates, event, eventData, extendedState) {\r\n    const oldCurrentState = cs;\r\n    const eventHandler = hashStates[oldCurrentState][event];\r\n\r\n    // CASE : There is a transition associated to that event\r\n    if (eventHandler) {\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, eventData);\r\n\r\n      // The transition is evaluated:\r\n      // - no guards are satisfied => outputs = null\r\n      // - guards satisfied => outputs an array, possibly containing a null value\r\n      /** OUT: this event handler modifies the in-closure machine state (extendedState, cs, history state) */\r\n      const { stop, outputs: rawOutputs } = eventHandler(extendedState, eventData, oldCurrentState);\r\n      const newControlState = cs;\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the new control state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1:init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case, eventData will be passed on every INIT_EVENT\r\n      // 2. eventless transitions\r\n      // NOTE : the inside guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen: all AUTO transitions should advance!\r\n      if (isAutoState[newControlState]) {\r\n        if (newControlState !== oldCurrentState) {\r\n          const auto_event = isInitState[newControlState]\r\n            ? INIT_EVENT\r\n            : AUTO_EVENT;\r\n\r\n          tracer({\r\n            type: INTERNAL_INPUT_MSG,\r\n            trace: {\r\n              info: { eventName: auto_event, eventData: eventData },\r\n              event: { [auto_event]: eventData },\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          const nextOutputs = sendEvent({ [auto_event]: eventData }, true);\r\n\r\n          tracer({\r\n            type: INTERNAL_OUTPUTS_MSG,\r\n            trace: {\r\n              outputs: nextOutputs,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return [].concat(outputs).concat(nextOutputs);\r\n        }\r\n        else {\r\n          // We found an eventless transition that returns to the same control state!\r\n          // This is forbidden as this may generate infinite loops on that stationary control state\r\n          // We throw in that case, as this is a breach of contract, one which we should\r\n          // detect at configuration time.\r\n          console.error(`Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`);\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              info: { received: { [event]: eventData } },\r\n              message: `Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`,\r\n              machineState: { cs: cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n        }\r\n      }\r\n      else return outputs;\r\n    }\r\n    // CASE : There is no transition associated to that event from that state\r\n    else {\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${cs}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { received: { [event]: eventData } },\r\n          message: `There is no transition associated to the event |${event}| in state |${cs}|!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leaveState(from, extendedState, hash_states) {\r\n    history = updateHistory(history, stateAncestors, hash_states[from].name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enterNextState(to, updatedExtendedState, hash_states) {\r\n    let targetStateName;\r\n\r\n    // CASE: history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const historyType = to[DEEP] ? DEEP : to[SHALLOW] ? SHALLOW : void 0;\r\n      const historyTarget = to[historyType];\r\n\r\n      // Contract: history state MUST be associated to compound state (else there is no history to be had)\r\n      if (!isInitState[historyTarget]) {\r\n        const message = `Configured a history state unrelated to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`;\r\n        debug && console && console.error(message);\r\n        throwKinglyError({ message })\r\n      }\r\n\r\n      // Edge case: If there is no history for the compound state, then we evaluate the\r\n      // initial transition for that compound state, i.e. we set that state as target state\r\n      targetStateName = history[historyType][historyTarget] || historyTarget;\r\n    }\r\n    // CASE: not a history state\r\n    else if (to) {\r\n      targetStateName = hash_states[to].name;\r\n    }\r\n    // Dead branch: should never happen\r\n    else {\r\n      throwKinglyError({ message: \"enter_state : unknown case! Not a state name, and not a history state to enter!\" });\r\n    }\r\n    cs = targetStateName;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", targetStateName);\r\n    return targetStateName;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: { eventName: INIT_EVENT, eventData: initialExtendedState },\r\n        event: { [INIT_EVENT]: initialExtendedState },\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n\r\n    return sendEvent({ [INIT_EVENT]: initialExtendedState }, true);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @typedef {Object} WebComponentFactoryParams\r\n * @property {String} name Name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @property {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @property {Stateful_FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @property {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @property {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an\r\n *   effect moniker to a function performing the corresponding effect.\r\n * @property {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\n/**\r\n * @param {WebComponentFactoryParams} webComponentFactoryParams\r\n */\r\nexport function makeWebComponentFromFsm({ name, eventHandler, fsm, commandHandlers, effectHandlers, options }) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions instanceof Error) {\r\n            // NOTE: we do not throw here, the web component will fail but\r\n            // the rest of the page may go on. We log and swallow the errors\r\n            console && console.log(actions)\r\n          }\r\n          else if (actions === NO_ACTION) return;\r\n          else {\r\n            actions.forEach(action => {\r\n              if (action === NO_ACTION) return;\r\n              const { command, params } = action;\r\n              commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n            })\r\n          }\r\n          ;\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      // There are no attributes\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // There are no attributes\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n"],"names":["SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","PATH_ROOT","PRE_ORDER","clone","a","undefined","JSON","parse","stringify","merge","objA","objB","Object","assign","updatePathInTraversalState","traversalState","subTree","subTreeChildren","forEach","subTreeChild","index","traversalStateParent","get","traversalStateChild","currentChildPath","path","set","isAdded","isVisited","concat","updateVisitInTraversalState","tree","visitTree","traversalSpecs","store","lenses","traverse","empty","emptyOrEmptyConstructor","add","takeAndRemoveOne","isEmpty","getChildren","visit","seed","seedOrSeedConstructor","Map","currentStore","visitAcc","clear","breadthFirstTraverseTree","shift","length","subTrees","push","apply","preorderTraverseTree","unshift","postOrderTraverseTree","predicate","isLeaf","result","isLeafLabel","label","objectTreeLenses","getLabel","Array","isArray","keys","value","values","map","prop","[object Object]","constructTree","children","labelKey","traverseObj","obj","treeObj","root","strategy","BFS","POST_ORDER","arrayTreeLenses","noop","emptyConsole","log","warn","info","debug","error","trace","group","groupEnd","emptyTracer","isFunction","x","isControlState","isHistoryControlState","isEvent","isActionFactory","get_fn_name","fn","exec","toString","wrap","str","join","times","n","Number","call","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","is_history_control_state_of","state","substring","format_transition_label","_event","action","name","format_history_transition_state_name","get_all_transitions","guards","getDisplayName","replace","getStatesType","statesTree","acc","treeLabel","getStatesPath","pathStr","getStatesTransitionsMap","transitions","reduce","getStateEventTransitionsMaps","getEventTransitionsMaps","getHistoryStatesMap","reduceTransitions","flatTransition","guardIndex","transitionIndex","gen","underlyingControlState","getHistoryUnderlyingState","getTargetStatesMap","getAncestorMap","computeHistoryMaps","control_states","stateList","stateAncestors","parentPath","slice","parentControlState","ancestors","_","reduceFn","transitionStruct","guard","arrayizeOutput","output","_typeof","getHistoryType","history","initHistoryDataStructure","initHistory","updateHistory","_history","state_from_name","oldAncestor","newAncestor","findInitTransition","find","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","isActions","isEventStruct","trueOrError","Error","cause","destructureEvent","eventName","eventData","wrapUpdateStateFn","userProvidedUpdateStateFn","throwKinglyError","tracer","extendedState","fnName","e","location","stack","throwKinglyErrorFactory","console","KinglyError","m","_this","errors","fullMsg","noDuplicatedStates","shouldThrow","fsmDef","settings","duplicatedStates","statesHashMap","states","isFulfilled","blame","noReservedStates","statesType","indexOf","reservedStates","atLeastOneState","isInitialControlStateDeclared","initTransition","initialControlState","declaredStates","eventsAreStrings","events","every","validInitialConfig","validInitialTransition","initTransitions","isInconditionalTransition","areCconditionalTransitions","initEventOnlyInCompoundStates","statesTransitionsMap","atomicInitTransitions","statesPath","filter","atomicState","validInitialTransitionForCompoundState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","Boolean","hasEntryTransitions","allHaveValidInitTransitions","targetState","entryTransitions","validEventLessTransitions","failingOriginControlStates","allStateTransitionsOnOneSingleRow","stateEventTransitionsMaps","statesTransitionsInfo","wrongEventConfig","noConflictingTransitionsWithAncestorState","eventTransitionsMaps","ancestorMap","eventTransitionsInfo","ev","wrongStateConfig","ancestorState","isHistoryStatesTargetStates","wrongHistoryStates","isHistoryStatesCompoundStates","originState","isHistoryStatesExisting","historyStatesMap","invalidTransitions","entries","historyState","flatTransitions","howMany","isValidGuard","isValidFsmDef","isValidTransitions","initialExtendedState","isValidStates","isValidEvents","haveTransitionsValidTypes","wrongTransitions","areEventsDeclared","eventList","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","areStatesDeclared","targetStatesMap","originStateList","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","isValidSettings","isInitialStateOriginState","targetStates","isValidSelfTransition","wrongSelfTransitions","fsmContracts","injected","description","contracts","makeContractHandler","contractsDef","contractsDescription","args","failingContracts","computedArgs","contractsEval","fullArgs","blameMessageHeader","fsmContractChecker","runContracts","checkContracts","type","machineState","cs","es","hs","alwaysTrue","buildNestedStateStructure","root_name","hashStates","isGroupState","State","nok","prototype","current_state_name","build_state_reducer","curr_constructor","state_name","state_config","parent_name","curr_constructor_new","displayName","normalizeTransitions","createStateMachine","res","createStateMachineAPIs","withProtectedState","createPureStateMachine","withPureInterface","controlStates","updateState","devTool","wrappedUpdateState","hashStatesStruct","isInitState","isAutoState","arr_predicate","from_proto","actionName","condition_checking_fn","extendedState_","event_data","current_state","predicateName","shouldTransitionBeTaken","actionResult","hash_states","leaveState","updatedExtendedState","targetStateName","historyType","historyTarget","deep","shallow","enterNextState","stop","condition_checked","start","fsmAPIs","input","sendEvent","fsmState","_cs","event_struct","isInternalEvent","hasFailed","oldCurrentState","eventHandler","received","rawOutputs","newControlState","auto_event","nextOutputs","processEvent","makeWebComponentFromFsm","fsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","params","HTMLElement","initialEvent","this","terminalEvent","complete","oldValue","newValue","customElements","define","generateStatePlantUmlHeader","optDisplayName","toPlantUml","translationMap","pathMap","translation","stateToPlantUML","getChildrenNumber","mappedTree","childrenTranslation","format_history_states","format_entry_transitions","translate_transitions","historyStatesObj","accTranslation","format_history_transitions","format_standard_transitions","toDagreVisualizerFormat","translatedStates","translatedTransitions"],"mappings":"qkHAEO,IAAMA,IAAM,IACNC,2BACAC,kCACAC,mBAAqB,IACrBC,eAAiB,WAEjBC,WAAa,MACbC,WAAa,OACbC,WAAa,OACbC,qBAAuB,QAEvBC,gBAAkB,GAElBC,UAAY,GACZC,gBAAkB,iBACtB,CACLC,QAAUF,UACVG,QAAUJ,kBAIDK,QAAU,UACVC,KAAO,OAEPC,qLAWAC,eAAiB,iBAEjBC,YAAc,cACdC,UAAY,YACZC,SAAW,WACXC,2BAA6B,6BAC7BC,UAAY,YACZC,mBAAqB,qBACrBC,qBAAuB,uBACvBC,UAAY,YACZC,eAAiB,iBC/C9B,MAAMC,UAAY,CAAC,GAENC,UAAY,YAOzB,SAASC,MAAMC,GACb,YAAaC,IAAND,OAAkBC,EAAYC,KAAKC,MAAMD,KAAKE,UAAUJ,IAGjE,SAASK,MAAMC,EAAMC,GACnB,OAAOC,OAAOC,OAAO,GAAIH,EAAMC,GAgBjC,SAASG,2BAA2BC,EAAgBC,EAASC,GAC3DA,EAAgBC,QAAQ,CAACC,EAAcC,KACrC,MAAMC,EAAuBN,EAAeO,IAAIN,GAI1CO,EAAsBR,EAAeO,IAAIH,GACzCK,EAAmBD,GAAuBA,EAAoBE,KAEpEV,EAAeW,IACbP,EACAV,MAAMc,EAAqB,CACzBI,SAAS,EACTC,WAAW,EACXH,KAAMD,GAAoBH,EAAqBI,KAAKI,OAAOT,QAYnE,SAASU,4BAA4Bf,EAAgBgB,GACnDhB,EAAeW,IACbK,EACAtB,MAAMM,EAAeO,IAAIS,GAAO,CAAEH,WAAW,KAK1C,SAASI,UAAUC,EAAgBF,GACxC,MAAMG,MAAEA,EAAKC,OAAEA,EAAMC,SAAEA,GAAaH,GAC5BI,MAAOC,EAAuBC,IAAEA,EAAGC,iBAAEA,EAAgBC,QAAEA,GAAYP,GACrEQ,YAAEA,GAAgBP,GAClBQ,MAAEA,EAAOC,KAAMC,GAA0BT,EACzCrB,EAAiB,IAAI+B,IAGrBF,EAAyC,mBAA1BC,EAAwC,IAAKA,KAA2B1C,MAAM0C,GAGnG,IAAIE,EAF8C,mBAA5BT,EAA0C,IAAKA,KAA6BnC,MAAMmC,GAGpGU,EAAWJ,EAIf,IAHAL,EAAI,CAACR,GAAOgB,GACZhC,EAAeW,IAAIK,EAAM,CAAEJ,SAAS,EAAMC,WAAW,EAAOH,KAAMxB,aAEzDwC,EAAQM,IAAgB,CAC/B,MAAM/B,EAAUwB,EAAiBO,GAC3B9B,EAAkByB,EAAY3B,EAAgBC,GAEpDuB,EAAItB,EAAiB8B,GACrBjC,2BAA2BC,EAAgBC,EAASC,GACpD+B,EAAWL,EAAMK,EAAUjC,EAAgBC,GAC3Cc,4BAA4Bf,EAAgBC,GAM9C,OAFAD,EAAekC,QAERD,EAGT,SAAgBE,yBAAyBf,EAAQC,EAAUL,GACzD,MAAMW,YAAEA,GAAgBP,EAYxB,OAAOH,UAXgB,CACrBE,MAAO,CACLG,MAAO,GACPG,iBAAkBN,GAASA,EAAMiB,QACjCV,QAASP,GAA0B,IAAjBA,EAAMkB,OACxBb,IAAK,CAACc,EAAUnB,IAAUA,EAAMoB,KAAKC,MAAMrB,EAAOmB,IAEpDlB,OAAQ,CAAEO,YAAa,CAAC3B,EAAgBC,IAAY0B,EAAY1B,IAChEoB,SAAAA,GAG+BL,GAGnC,SAAgByB,qBAAqBrB,EAAQC,EAAUL,GACrD,MAAMW,YAAEA,GAAgBP,EAaxB,OAAOH,UAZgB,CACrBE,MAAO,CACLG,MAAO,GACPG,iBAAkBN,GAASA,EAAMiB,QACjCV,QAASP,GAA0B,IAAjBA,EAAMkB,OAExBb,IAAK,CAACc,EAAUnB,IAAUA,EAAMuB,WAAWJ,IAE7ClB,OAAQ,CAAEO,YAAa,CAAC3B,EAAgBC,IAAY0B,EAAY1B,IAChEoB,SAAAA,GAG+BL,GAGnC,SAAgB2B,sBAAsBvB,EAAQC,EAAUL,GACtD,MAAMW,YAAEA,GAAgBP,GAElBS,KAAEA,EAAID,MAAEA,GAAUP,EAClBuB,EAAY,CAAC5B,EAAMhB,IAAmBA,EAAeO,IAAIS,GAAMH,WAFtD,EAACG,EAAMhB,IAAgE,IAA7C2B,EAAYX,EAAMhB,GAAgBqC,OAEOQ,CAAO7B,EAAMhB,GAgC/F,OAAOiB,UAtBgB,CACrBE,MAAO,CACLG,MAAO,GACPG,iBAAkBN,GAASA,EAAMiB,QACjCV,QAASP,GAA0B,IAAjBA,EAAMkB,OACxBb,IAAK,CAACc,EAAUnB,IAAUA,EAAMuB,WAAWJ,IAE7ClB,OAhBsB,CAItBO,YAAa,CAAC3B,EAAgBgB,IAC5B4B,EAAU5B,EAAMhB,GACZ,GACA2B,EAAYX,EAAMhB,GAAgBc,OAAO,CAACE,KAUhDK,SAAU,CACRQ,KAAMA,EACND,MAAO,CAACkB,EAAQ9C,EAAgBgB,IAKvB4B,EAAU5B,EAAMhB,GACrB4B,EAAMkB,EAAQ9C,EAAgBgB,GAC5B8B,IAKuB9B,GAiKnC,SAAS+B,YAAYC,GACnB,OAAsD,IAA/CC,iBAAiBtB,YAAYqB,GAAOX,OAG7C,MAAaY,iBAAmB,CAC9BF,YAAAA,YACAG,SAAUlC,IACR,GAAoB,iBAATA,GAAsBmC,MAAMC,QAAQpC,IAAsC,IAA7BnB,OAAOwD,KAAKrC,GAAMqB,OAIxE,KAAM,0CAHN,OAAOrB,GAMXW,YAAaX,IACX,GAAoB,iBAATA,GAAsBmC,MAAMC,QAAQpC,IAAsC,IAA7BnB,OAAOwD,KAAKrC,GAAMqB,OAUxE,KAAM,iCAVgF,CACtF,IAAIiB,EAAQzD,OAAO0D,OAAOvC,GAAM,GAChC,OAAIsC,GAA0B,iBAAVA,IAAuBH,MAAMC,QAAQE,GAChDzD,OAAOwD,KAAKC,GAAOE,IAAIC,KAAWC,CAACD,GAAOH,EAAMG,MAGhD,KAObE,cAAe,CAACX,EAAOY,KACrB,MAAMC,EAAWb,GAASnD,OAAOwD,KAAKL,IAAUnD,OAAOwD,KAAKL,GAAO,GAEnE,OAA2B,IAApBY,EAASvB,OACZW,EACA,CACFU,CAACG,GAAWhE,OAAOC,OAAO0C,MAAM,KAAMoB,MAuBrC,SAASE,YAAYzC,EAAU0C,GACpC,MAAMC,EAAU,CAACC,KAAOF,IAClBG,SAACA,EAAQrC,KAAEA,EAAID,MAAEA,GAASP,EAmBhC,OAlBmB,CACjB8C,IAAMhC,yBACNhD,UAAYsD,qBACZ2B,WAAYzB,uBACZuB,IAAazB,sBAYqBQ,iBAXV,CACxBpB,KAAAA,EACAD,MAAQ,SAAyBK,EAAUjC,EAAgBgB,GACzD,MAAMN,KAACA,GAAQV,EAAeO,IAAIS,GAElC,OAAOzB,KAAKE,UAAUiB,KAASnB,KAAKE,UAAUP,WAC5C+C,EACEL,EAAMK,EAAUjC,EAAgBgB,KAIiCgD,GAU3E,MAAaK,gBAAkB,CAC7BnB,SAAUlC,GACDmC,MAAMC,QAAQpC,GAAQA,EAAK,GAAKA,EAEzCW,YAAaX,GACJmC,MAAMC,QAAQpC,GAASA,EAAK,GAAK,GAE1C2C,cAAe,CAACX,EAAOY,IACdA,GAAYT,MAAMC,QAAQQ,IAAaA,EAASvB,OAAS,EAAI,CAACW,EAAOY,GAAYZ,GC1ZrF,IAAMsB,KAAO,aAEPC,aAAe,CAACC,IAAKF,KAAMG,KAAMH,KAAMI,KAAMJ,KAAMK,MAAOL,KAAMM,MAAON,KAAMO,MAAOP,KAAMQ,MAAMR,KAAMS,SAAUT,MAChHU,YAAcV,KAMpB,SAASW,WAAWC,SACL,mBAANA,EAGT,SAASC,eAAeD,UACtBA,GAAkB,iBAANA,GAAkBE,sBAAsBF,GAGtD,SAASG,QAAQH,eACF,IAANA,GAAkC,iBAANA,EAGrC,SAASI,gBAAgBJ,UACvBA,GAAkB,mBAANA,EAoBd,SAASK,YAAYC,SAExB,sGACGC,KAAKD,EAAGE,YACC,GAGT,SAASC,KAAKC,SACZ,CAAC,IAAKA,EAAK,KAAKC,KAAK,IAGvB,SAASC,QAAMN,EAAIO,UACjB5C,MAAMX,MAAM,KAAM,CAACH,OAAQ0D,IAAIvC,IAAIwC,OAAOC,KAAMD,QAAQxC,IAAIgC,GAO9D,SAASnC,KAAKU,UACZlE,OAAOwD,KAAKU,GASd,SAASmC,sBAAsBC,UAC7BA,EAAWC,GAAGC,WAAW1I,gBAG3B,SAAS2I,oBAAoBH,UAC3BA,EAAWI,QAAU1I,WAGvB,SAAS2I,sBAAsBC,UAC7B,SAAUN,UACRA,EAAWO,OAASD,GAIxB,SAASE,+BAA+BF,UACtC,SAAUN,UACRS,4BAA4BH,EAAcN,EAAWC,KAIzD,SAASQ,4BAA4BH,EAAcI,UACjDA,EAAMC,UAAUnJ,eAAe0E,UAAYoE,EAGpD,SAAgBM,wBAAwBC,EAAQpE,EAAWqE,OACnDV,EAAQS,GAAU,UACjBpE,GAAaqE,YACbV,eAAU3D,EAAUsE,oBAAWD,EAAOC,MACzCtE,YACK2D,eAAU3D,EAAUsE,WACvBD,YACKV,gBAAWU,EAAOC,gBAClBX,GAGN,SAASY,4CAAsCT,IAAAA,KAAMN,IAAAA,mBAChDM,cAAQN,EAAGU,UAAUnJ,eAAe0E,oBAAW3E,oBAGpD,SAAS0J,oBAAoBjB,OAC3BO,EAAuBP,EAAvBO,KAAMH,EAAiBJ,EAAjBI,MAAOc,EAAUlB,EAAVkB,cAEbA,EACHA,EAAO7D,IAAI,gBAAEZ,IAAAA,UAAWwD,IAAAA,GAAIa,IAAAA,aAAa,CAACP,KAAAA,EAAMH,MAAAA,EAAO3D,UAAAA,EAAWwD,GAAAA,EAAIa,OAAAA,KACtE,CAACd,GAQA,SAASmB,eAAe1B,UACtBA,EAAI2B,QAAQ,KAAM,KA2GpB,SAASC,cAAcC,OACrBvE,EAAyBD,iBAAzBC,SAAUH,EAAeE,iBAAfF,mBAgBVe,YAdU,CACfI,SAAU/E,UACV0C,KAAM,GACND,MAAO,SAAC8F,EAAK1H,EAAgBgB,OACrB2G,EAAYzE,EAASlC,GACrByF,EAAe5G,OAAOwD,KAAKsE,GAAW,UAGrC5E,EAAY4E,IACdD,EAAIjB,IAAgB,EAAOiB,IAC3BA,EAAIjB,IAAgB,EAAMiB,KAIND,GAGxB,SAASG,cAAcH,OACrBvE,EAAYD,iBAAZC,gBAcAY,YAZU,CACfI,SAAU/E,UACV0C,KAAM,GACND,MAAO,SAAC8F,EAAK1H,EAAgBgB,OACrB6G,EAAU7H,EAAeO,IAAIS,GAAMN,KAAKmF,KAAK,KAC7C8B,EAAYzE,EAASlC,UAGnB0G,EAFa7H,OAAOwD,KAAKsE,GAAW,IAEhBE,EAASH,IAIZD,GAGxB,SAASK,wBAAwBC,UAE/BA,EAAYC,OAAO,SAACN,EAAKvB,OACrBO,EAAeP,EAAfO,KAAMH,EAASJ,EAATI,aAETnB,sBAAsBsB,GAAcgB,GAExCA,EAAIhB,GAAQgB,EAAIhB,IAAS,GACzBgB,EAAIhB,GAAMH,GAASJ,EACZuB,IACN,KACA,GAGA,SAASO,6BAA6BF,UAEpCA,EAAYC,OAAO,SAACN,EAAKvB,OACrBO,EAAeP,EAAfO,KAAMH,EAASJ,EAATI,aAETnB,sBAAsBsB,GAAcgB,GAExCA,EAAIhB,GAAQgB,EAAIhB,IAAS,GACzBgB,EAAIhB,GAAMH,GAASmB,EAAIhB,GAAMH,GAASmB,EAAIhB,GAAMH,GAAOzF,OAAOqF,GAAc,CAACA,GACtEuB,IACN,KACA,GAGA,SAASQ,wBAAwBH,UAE/BA,EAAYC,OAAO,SAACN,EAAKvB,OACrBO,EAAeP,EAAfO,KAAMH,EAASJ,EAATI,aAETnB,sBAAsBsB,GAAcgB,GAExCA,EAAInB,GAASmB,EAAInB,IAAU,GAC3BmB,EAAInB,GAAOG,GAAQgB,EAAInB,GAAOG,GAAQgB,EAAInB,GAAOG,GAAM5F,OAAOqF,GAAc,CAACA,GACtEuB,IACN,KACA,GAGA,SAASS,oBAAoBJ,UAC3BK,kBAAkB,SAAC5E,EAAK6E,EAAgBC,EAAYC,OAChD7B,EAA2C2B,EAA3C3B,KAAaN,GAA8BiC,EAArC9B,MAAqC8B,EAA9BjC,IAA8BiC,EAA1BpB,OAA0BoB,EAAlBzF,UAAkByF,EAAPG,OACvCpD,sBAAsBsB,GAAO,KACzB+B,EAAyBC,0BAA0BhC,GACzDlD,EAAI7C,IAAI8H,GAAyBjF,EAAIjD,IAAIkI,IAA2B,IAAI3H,OAAO,CAACuH,UAE7E,GAAIjD,sBAAsBgB,GAAK,KAC5BqC,EAAyBC,0BAA0BtC,GACzD5C,EAAI7C,IAAI8H,GAAyBjF,EAAIjD,IAAIkI,IAA2B,IAAI3H,OAAO,CAACuH,YAG3E7E,GACN,IAAIzB,IAAOgG,IACX,GAGA,SAASY,mBAAmBZ,UAC1BK,kBAAkB,SAAC5E,EAAK6E,EAAgBC,EAAYC,OAChDnC,EAAMiC,EAANjC,UACP5C,EAAI7C,IAAIyF,GAAK5C,EAAIjD,IAAI6F,IAAO,IAAItF,OAAO,CAACuH,KACjC7E,GACN,IAAIzB,IAAOgG,IACX,GAGA,SAASa,eAAenB,OACtBvE,EAAyBD,iBAAzBC,SAAUvB,EAAesB,iBAAftB,mBAoBVmC,YAlBU,CACfI,SAAU/E,UACV0C,KAAM,GACND,MAAO,SAAC8F,EAAK1H,EAAgBgB,OACrB2G,EAAYzE,EAASlC,GACrByF,EAAe5G,OAAOwD,KAAKsE,GAAW,UAC3BhG,EAAYX,GACUwC,IAAI,SAAAxC,UAAQnB,OAAOwD,KAAKH,EAASlC,IAAO,KAEzDb,QAAQ,SAAA0G,GAC5Ba,EAAIb,GAASa,EAAIb,IAAU,GAC3Ba,EAAIb,GAASa,EAAIb,GAAO/F,OAAO2F,KAG1BiB,IAIkBD,GAGxB,SAASoB,mBAAmBC,MACU,IAAvCjJ,OAAOwD,KAAKyF,GAAgBzG,8EAIzBa,EAAyBD,iBAAzBC,WAsC6BY,YArCnB,CACfI,SAAU/E,UACV0C,KAAM,CAACkH,UAAW,GAAIC,eAAgB,IACtCpH,MAAO,SAAC8F,EAAK1H,EAAgBgB,OACrB2G,EAAYzE,EAASlC,GACrByF,EAAe5G,OAAOwD,KAAKsE,GAAW,GAC5CD,EAAIqB,UAAYrB,EAAIqB,UAAUjI,OAAO2F,OAI9B/F,EAAQV,EAAeO,IAAIS,GAA3BN,KACPV,EAAeW,IAAIpB,KAAKE,UAAUiB,GAAO+F,OACnCwC,EAAavI,EAAKwI,MAAM,GAAI,MACR,IAAtBD,EAAW5G,OAEbrC,EAAeW,IAAIpB,KAAKE,UAAUwJ,GAAarL,gBAE5C,KACGuL,EAAqBnJ,EAAeO,IAAIhB,KAAKE,UAAUwJ,IAC7DvB,EAAIsB,eAAevC,GAAgB,CAAC0C,OAE7BC,EAAa1I,EAAKsH,OAAO,SAACN,EAAK2B,OAC9BJ,EAAavB,EAAIhH,KAAKwI,MAAM,GAAI,MACtCxB,EAAIhH,KAAOuI,EACPA,EAAW5G,OAAS,EAAG,KACnB8G,EAAqBnJ,EAAeO,IAAIhB,KAAKE,UAAUwJ,IAC7DvB,EAAI0B,UAAY1B,EAAI0B,UAAUtI,OAAOqI,UAGhCzB,GACN,CAAC0B,UAAW,GAAI1I,KAAAA,IATZ0I,UAUP1B,EAAIsB,eAAevC,GAAgB2C,SAG9B1B,IAG+CoB,SAEnD,CAACC,YAFDA,UAEYC,iBAFDA,gBAKpB,SAsBgBZ,kBAAkBkB,EAAUzH,EAAMkG,UACjCA,EAAYC,OAAO,SAACN,EAAK6B,EAAkBhB,OACnD7B,EAAwC6C,EAAxC7C,KAAMH,EAAkCgD,EAAlChD,MAAOH,EAA2BmD,EAA3BnD,GAAIoC,EAAuBe,EAAvBf,IAAKvB,EAAkBsC,EAAlBtC,OAAQI,EAAUkC,EAAVlC,cAE9BA,IACHA,EAASmB,EAAM,CAAC,CAACpC,GAAAA,EAAIa,OAAAA,EAAQuB,IAAAA,EAAK5F,eAAWtD,IAAc,CAAC,CAAC8G,GAAAA,EAAIa,OAAAA,EAAQrE,eAAWtD,KAE/E+H,EAAOW,OAAO,SAACN,EAAK8B,EAAOlB,OACzBlC,EAA8BoD,EAA9BpD,GAAIa,EAA0BuC,EAA1BvC,OAAQuB,EAAkBgB,EAAlBhB,IAAK5F,EAAa4G,EAAb5G,iBAEpB0G,EAAS5B,EADNc,EACW,CAAC9B,KAAAA,EAAMH,MAAAA,EAAOH,GAAAA,EAAIa,OAAAA,EAAQrE,UAAAA,EAAW4F,IAAAA,GACrC,CAAC9B,KAAAA,EAAMH,MAAAA,EAAOH,GAAAA,EAAIa,OAAAA,EAAQrE,UAAAA,GADiB0F,EAAYC,IAExEb,IACF7F,GAgCE,SAAS4H,eAAeC,UACtBA,IAAWzL,UACdA,UACAkF,MAAMC,QAAQsG,GACZA,EACA,CAACA,GAGF,SAAStE,sBAAsBgB,SACf,WAAduD,QAAOvD,KAAoB9H,QAAQ8H,GAAM/H,WAAW+H,GAetD,SAASwD,eAAeC,UACtBA,EAAQvL,MAAQA,KAAOD,QAGzB,SAASqK,0BAA0BmB,UACjCA,EAAQD,eAAeC,IAazB,SAASC,yBAAyBf,SAGjCgB,EAAc,kBAAMhB,EAAUf,OAAO,SAACN,EAAKb,UAAWa,EAAIb,GAAS,GAAIa,GAAM,iCAC1EpJ,KAAOyL,uBAAgB1L,QAAU0L,OAsB5C,SAAgBC,cAAcC,EAAUjB,EAAgBkB,SAGhDL,wBACHvL,KAAOuB,OAAOC,OAAO,GAAImK,EAAS3L,0BAClCD,QAAUwB,OAAOC,OAAO,GAAImK,EAAS5L,qBAIpC6L,IAAoBtM,WACfiM,IAIab,EAAekB,IAAoB,IAC3ClC,OAAO,SAACmC,EAAaC,UAE7BP,EAAQvL,MAAM8L,GAAeF,EAC7BL,EAAQxL,SAAS+L,GAAeD,EAEzBC,GACNF,GAEEL,GA4BJ,SAASQ,mBAAmBtC,UAC1BA,EAAYuC,KAAK,SAAAnE,UACfA,EAAWO,OAAS9I,YAAcuI,EAAWI,QAAU1I,aA+C3D,SAAS0M,OAAOC,EAAUC,OACzBC,EAAeF,EAAStD,MAAQ,GAChCyD,EAAqBH,EAAShI,MAAM,KAAMiI,UACrB,IAAvBE,OAA6B,mBAG1BA,GACHC,yBACAC,QAAS,CAACF,EAAmBE,kCAA4BH,IAAgB7E,KAAK,MAC9EnB,KAAMiG,EAAmBjG,OAgFxB,SAASoG,UAAU/G,UACjBA,GAAO,YAAaA,GAAO,YAAaA,GAC1CZ,MAAMC,QAAQW,EAAI5F,SAUlB,SAAS4M,cAAchH,OACxBiH,SACCjH,GAAsB,WAAf4F,QAAO5F,GAIVlE,OAAOwD,KAAKU,GAAK1B,OAAS,GACjC2I,EAAc,IAAIC,MAAM1M,2BACZmG,KAAO,CAAC6B,MAAOxC,EAAKmH,uEAE7BF,GAAc,GAPjBA,EAAc,IAAIC,MAAM1M,2BACZmG,KAAO,CAAC6B,MAAOxC,EAAKmH,wBAQ3BF,EAOF,SAASG,iBAAiBpH,OACzBqH,EAAYvL,OAAOwD,KAAKU,GAAK,SAG5B,CAACqH,UAAAA,EAAWC,UAFDtH,EAAIqH,IASjB,SAASE,kBAAkBC,SAA4BC,IAAAA,mBAAkBC,cACvE,SAACC,EAAetN,OACfuN,EAASJ,EAA0BrE,MAAQ,cAGxCqE,EAA0BG,EAAetN,GAElD,MAAOwN,GACLJ,EAAiB,CACfZ,8CAAwCe,GACxCE,mDACAnH,KAAM,CAACgH,cAAAA,EAAetN,QAAAA,GACtByM,QAASe,EAAEf,QACXiB,MAAOF,EAAEE,UAMV,SAASC,wBAAyBC,EAAQP,UACxC,SAAA1H,SACD,IAAIkI,YAAYlI,EAAKiI,EAASP,QAIzBQ,YAAb,uBACcC,EAAGF,EAASP,iGAChBS,GAAKA,EAAErB,SAAW,MACnB3D,qBACA4E,MAAQI,GAAKA,EAAEJ,OAASK,EAAKL,QAC7BM,OAASF,QAC4BA,GAAK,GAAvCtB,IAAAA,KAAMiB,IAAAA,SAAUnH,IAAAA,KAAMmG,IAAAA,QAGxBwB,EAAU,cAFCR,eAAajB,iBAAWC,GACzBnG,8BAAqC,IACvBmB,KAAK,aAEnCmG,GAAWA,EAAQpH,MAAMyH,GACzB3H,GAAQsH,GAAWA,EAAQtH,KAAKA,yCAZHuG,UAAjC,GChxBaqB,mBAAqB,CAChCpF,KAAM,qBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,OACVvJ,EAAaD,iBAAbC,SAuBAwJ,EAAqB5I,YAtBZ,CACfI,SAAU/E,UACV0C,KAAM,CAAE6K,iBAAkB,GAAIC,cAAe,IAC7C/K,MAAO,SAAC8F,EAAK1H,EAAgBgB,OACnB0L,EAAoChF,EAApCgF,iBAAkBC,EAAkBjF,EAAlBiF,cACpBhF,EAAYzE,EAASlC,GACrByF,EAAe5G,OAAOwD,KAAKsE,GAAW,UACxClB,KAAgBkG,EACX,CACLD,iBAAkBA,EAAiB5L,OAAO2F,GAC1CkG,cAAAA,GAIK,CACLD,iBAAAA,EACAC,eAAgBA,EAAclG,GAAgB,GAAIkG,MAMPH,EAAOI,QAAlDF,uBAGD,CACLG,YAF8C,IAA5BH,EAAiBrK,OAGnCyK,MAAO,CACLjC,4EACAnG,KAAM,CAAEgI,iBAAAA,OAOHK,iBAAmB,CAC9B7F,KAAM,mBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYO,IAAAA,iBACvB,CACLH,aAA8D,IAAjDhN,OAAOwD,KAAK2J,GAAYC,QAAQrP,YAC7CkP,MAAO,CACLjC,yHACAnG,KAAM,CAAEwI,eAAgB,CAACtP,YAAaoP,WAAAA,OAOjCG,gBAAkB,CAC7BjG,KAAM,kBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYO,IAAAA,iBACvB,CACLH,YAAahN,OAAOwD,KAAK2J,GAAY3K,OAAS,EAC9CyK,MAAO,CACLjC,gFACAnG,KAAM,CAAEsI,WAAAA,OAOHI,8BAAgC,CAC3ClG,KAAM,gCACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,OAAYY,mBAAgBL,IAAAA,WACtCM,EAAqCd,EAArCc,oBACFvE,GADuCyD,EAAhBzE,YACXlI,OAAOwD,KAAK2J,WAC1BM,EACK,CACLT,YAAa9D,EAAUkE,QAAQK,IAAwB,EACvDR,MAAO,CACLjC,6EACAnG,KAAM,CAAE4I,oBAAAA,EAAqBC,eAAgBxE,KAK1C,CACL8D,aAAa,EACbC,WAAO,KAQFU,iBAAmB,CAC9BtG,KAAM,mBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SACX,CACLI,YAAaL,EAAOiB,OAAOC,MAAM,SAAAxI,SAAkB,iBAANA,IAC7C4H,MAAO,CACLjC,8CACAnG,KAAM,CAAE+I,OAAQjB,EAAOiB,YAMlBE,mBAAqB,CAChCzG,KAAM,qBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYY,IAAAA,eACtBC,EAAwBd,EAAxBc,2BAEJD,GAAkBC,EACb,CACLT,aAAa,EACbC,MAAO,CACLjC,+JACAnG,KAAM,CAAE4I,oBAAAA,EAAqBD,eAAAA,KAIzBA,GAAmBC,EASjB,CACRT,aAAa,EACbC,WAAO,GAVF,CACLD,aAAa,EACbC,MAAO,CACLjC,0KACAnG,KAAM,CAAE4I,oBAAAA,EAAqBD,eAAAA,OAkB1BO,uBAAyB,CACpC1G,KAAM,yBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYY,IAAAA,eACtBC,EAAqCd,EAArCc,oBACFO,EADuCrB,EAAhBzE,YACOC,OAAO,SAACN,EAAKvB,UAC/CA,EAAWO,OAAS9I,YAAc8J,EAAInF,KAAK4D,GACpCuB,GACN,UAcI,CACLmF,YAVCS,IAAwBD,IACvBC,GAAuBD,GAA6C,IAA3BQ,EAAgBxL,QAAgBgL,EAAe9G,QAAU1I,aAEhGiQ,0BAA0BT,IACvBU,2BAA2BV,IAOlCP,MAAO,CACLjC,gEACAnG,KAAM,CAAE2I,eAAAA,EAAgBQ,gBAAAA,EAAiBP,oBAAAA,OAQpCU,8BAAgC,CAC3C9G,KAAM,gCACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYwB,IAAAA,qBAAsBjB,IAAAA,WAG9CkB,KAH0DC,WAE3CtO,OAAOwD,KAAK2J,GAAYoB,OAAO,SAAA3H,UAAiBuG,EAAWvG,KACrCjD,IACzC,SAAA6K,6BACGA,EAAcJ,EAAqBI,IAAgBJ,EAAqBI,GAAaxQ,eAExFuQ,OAAO,SAAArK,UAAOlE,OAAO0D,OAAOQ,GAAK,YAI5B,CACL8I,YAHwE,IAAjCqB,EAAsB7L,OAI7DyK,MAAO,CACLjC,+FACAnG,KAAM,CAAEmJ,gBAAiBK,OAapBI,uCAAyC,CACpDpH,KAAM,yCACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYwB,IAAAA,qBAAsBjB,IAAAA,WAAYmB,IAAAA,WAE1DI,EAAiB1O,OAAOwD,KAAK2J,GAAYoB,OAAO,SAAA3H,UAAgBuG,EAAWvG,KAC3E+H,EAAgCD,EAAe/K,IACnD,SAAAiL,UAAiBR,EAAqBQ,IAAkBR,EAAqBQ,GAAe5Q,cAExF6Q,EAAyBF,EAA8Bd,MAAMiB,aAE9DD,QACI,CACL7B,aAAa,EACbC,MAAO,CACLjC,iFACAnG,KAAM,CACJkK,oBAAqBL,EAAe/K,IAClC,SAAAqD,6BAAaA,KAAWoH,EAAqBpH,KAAUoH,EAAqBpH,GAAOhJ,uBAMvFgR,EAA8BH,GAClCF,EAA8Bd,MAAM,SAAAL,OAC1BhG,EAAegG,EAAfhG,OAAQjB,EAAOiH,EAAPjH,UACXiB,EAKkBA,EAAO7D,IAAI,SAAAgG,UAASA,EAAMpD,KAC3BsH,MAAM,SAAAoB,SAAsC,iBAAhBA,IAJ3B,iBAAP1I,WAOfyI,EAWsCA,GACzCL,EAA8Bd,MAAM,SAAAL,OAC1B3G,EAAqB2G,EAArB3G,KAAMW,EAAegG,EAAfhG,OAAQjB,EAAOiH,EAAPjH,UAKjBiB,EAIkBA,EAAO7D,IAAI,SAAAgG,UAASA,EAAMpD,KAC3BsH,MAAM,SAAAtH,UACjBM,IAASN,GAAM+H,EAAW/H,IAAO+H,EAAW/H,GAAIC,WAAW8H,EAAWzH,MALxEA,IAASN,GAAM+H,EAAW/H,IAAO+H,EAAW/H,GAAIC,WAAW8H,EAAWzH,MAmB5E,CACLmG,aAAa,EACbC,WAAO,GAXA,CACLD,aAAa,EACbC,MAAO,CACLjC,iNACAnG,KAAM,CAAEkI,OAAQJ,EAAOI,OAAQuB,WAAAA,EAAYY,iBAAkBP,KAhC1D,CACL3B,aAAa,EACbC,MAAO,CACLjC,iNACAnG,KAAM,CAAEqK,iBAAkBP,OA2CvBQ,0BAA4B,CACvC9H,KAAM,4BACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYwB,IAAAA,qBAAsBjB,IAAAA,WAG9CiC,KAH0Dd,WAE9CtO,OAAOwD,KAAK2J,GACexJ,IAAI,SAAAqD,6BAE5CA,EAAQoH,EAAqBpH,IAC9B,eAAG,KAAYoH,EAAqBpH,IACgB,IAApDhH,OAAOwD,KAAK4K,EAAqBpH,IAAQxE,UAE1C+L,OAAO,SAAArK,eAAiC,IAA1BlE,OAAO0D,OAAOQ,GAAK,IAAiBlE,OAAO0D,OAAOQ,GAAK,YAIjE,CACL8I,YAHwD,IAAtCoC,EAA2B5M,OAI7CyK,MAAO,CACLjC,oHACAnG,KAAM,CAAEuK,2BAAAA,OAQHC,kCAAoC,CAC/ChI,KAAM,oCACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAY0C,IAAAA,0BAExBC,EADkBvP,OAAOwD,KAAK8L,GACUnH,OAAO,SAACN,EAAKb,OAEnDwI,EADSxP,OAAOwD,KAAK8L,EAA0BtI,IACrBuH,OAAO,SAAA7H,UAAS4I,EAA0BtI,GAAON,GAAOlE,OAAS,WAC7FgN,EAAiBhN,OAAS,IAC5BqF,EAAIb,GAASwI,GAGR3H,GACN,UAII,CACLmF,YAHgE,IAA9ChN,OAAOwD,KAAK+L,GAAuB/M,OAIrDyK,MAAO,CACLjC,6IACAnG,KAAM,CAAE0K,sBAAAA,OASHE,0CAA4C,CACvDpI,KAAM,4CACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,OAAY0C,8BAA2BI,IAAAA,qBAAsBC,IAAAA,YAEzEC,EADY5P,OAAOwD,KAAKkM,GAAsBnB,OAAO,SAAAsB,UAAMA,IAAO7R,iBAAqB,IAAP6R,IAC/C1H,OAAO,SAACN,EAAKnB,OAC5CqG,EAAS/M,OAAOwD,KAAKkM,EAAqBhJ,IAE1CoJ,EAAmB/C,EACtBwB,OAAO,SAAAvH,UAASA,IAAUjJ,aAC1B4F,IAAI,SAAAqD,UAAS2I,EAAY3I,uBACvBA,EAAQ2I,EAAY3I,GAAOyD,KAC1B,SAAAsF,UAAiBhD,EAAOK,QAAQ2C,IAAkB,OAIrDxB,OAAO,SAAArK,UACCA,GAAOlE,OAAO0D,OAAOQ,GAAKqK,OAAOO,SAAStM,OAAS,WAG1DsN,EAAiBtN,OAAS,IAC5BqF,EAAInB,GAASoJ,GAGRjI,GACN,UAII,CACLmF,YAH+D,IAA7ChN,OAAOwD,KAAKoM,GAAsBpN,OAIpDyK,MAAO,CACLjC,oHACAnG,KAAM,CAAE+K,qBAAAA,OAOHI,4BAA8B,CACzC3I,KAAM,8BACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,sCACZqD,EAAqBtD,EAAOzE,YAAYC,OAAO,SAACN,EAAKvB,UAClDf,sBAAsBe,EAAWO,MACpCgB,EAAI5G,OAAOqF,GACXuB,GACH,UAII,CACLmF,YAH6D,IAA3ChN,OAAOwD,KAAKyM,GAAoBzN,OAIlDyK,MAAO,CACLjC,oKACAnG,KAAM,CAAEoL,mBAAAA,OAOHC,8BAAgC,CAC3C7I,KAAM,gCACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAY0C,IAAAA,0BAA2BnC,IAAAA,WAEnD8C,EADkBjQ,OAAOwD,KAAK8L,GACO3L,IAAI,SAAAwM,UACzCA,IAAgBpS,WAAmB,GAExBiC,OAAOwD,KAAK8L,EAA0Ba,IAEvChI,OAAO,SAACN,EAAKnB,OAKnBJ,EAAagJ,EAA0Ba,GAAazJ,GAAO,GACzDc,EAAelB,EAAfkB,OAAQjB,EAAOD,EAAPC,UACXiB,EAOIA,EAAOW,OAAO,SAACN,EAAK8B,OACjBpD,EAAOoD,EAAPpD,UAEDhB,sBAAsBgB,KAAQ4G,EAAWtE,0BAA0BtC,IACtEsB,EAAI5G,OAAOqF,GACXuB,GACHA,GAXItC,sBAAsBgB,KAAQ4G,EAAWtE,0BAA0BtC,IACtEsB,EAAI5G,OAAOqF,GACXuB,GAWL,MAEFM,OAAO,SAACN,EAAKxC,UAAMwC,EAAI5G,OAAOoE,IAAI,UAI9B,CACL2H,YAH6D,IAA3ChN,OAAOwD,KAAKyM,GAAoBzN,OAIlDyK,MAAO,CACLjC,kIACAnG,KAAM,CAAEoL,mBAAAA,EAAoBlD,OAAQJ,EAAOI,YAOtCqD,wBAA0B,CACrC/I,KAAM,0BACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAYyD,IAAAA,iBAAkBlD,IAAAA,WAC1CmD,EAAqBhN,MAAMuD,KAAKwJ,EAAiBE,WACpD5M,IAAI,sCAAE6M,OAAcC,eACVD,KAAgBrD,IAAe,CAAEqD,aAAAA,EAAcC,gBAAAA,KAEzDlC,OAAOO,SAEJ4B,EAAU1Q,OAAOwD,KAAK8M,GAAoB9N,aAGzC,CACLwK,YAH8B,IAAZ0D,EAIlBzD,MAAO,CACLjC,wBAAkB0F,yIAClB7L,KAAM,CAAEyL,mBAAAA,EAAoBvD,OAAQJ,EAAOI,YAM5C,SAASkB,0BAA0B3H,OAChCO,EAAoCP,EAApCO,KAAMH,EAA8BJ,EAA9BI,MAAOc,EAAuBlB,EAAvBkB,OAAQjB,EAAeD,EAAfC,GAAIa,EAAWd,EAAXc,qBAEnBI,mBAAc,IAAYjB,GAAMjB,eAAeuB,IAASrB,QAAQkB,IAAUpB,eAAeiB,IAAOd,gBAAgB2B,GAGzH,SAASuJ,aAAahH,OACnBpD,EAA0BoD,EAA1BpD,GAAIxD,EAAsB4G,EAAtB5G,UAAWqE,EAAWuC,EAAXvC,cAEhBb,GAAMjB,eAAeiB,IAAOnB,WAAWrC,IAAc0C,gBAAgB2B,GAGvE,SAAS8G,2BAA2B5H,OACjCO,EAA4BP,EAA5BO,KAAMH,EAAsBJ,EAAtBI,MAAOc,EAAelB,EAAfkB,OAAQjB,EAAOD,EAAPC,UAEtBiB,GAAUlE,MAAMC,QAAQiE,IAAWA,EAAOhF,OAAS,IACpD+D,GAAMjB,eAAeuB,IAASrB,QAAQkB,IAAUc,EAAOqG,MAAM8C,cAGrE,IAAaC,cAAgB,CAC3BvJ,KAAM,gBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,OACV1E,EAAsDyE,EAAtDzE,YAAa6E,EAAyCJ,EAAzCI,OAAQa,EAAiCjB,EAAjCiB,OACvBiD,GADwDlE,EAAzBmE,qBACV5I,GAAe5E,MAAMC,QAAQ2E,IAClD6I,EAAgBhE,GAA6B,WAAnBjD,QAAOiD,GACjCiE,EAAgBpD,GAAUtK,MAAMC,QAAQqK,UACzCiD,EASKE,EASAC,EAYD,CACLhE,aAAa,EACbC,WAAO,GAbF,CACLD,aAAa,EACbC,MAAO,CACLjC,yEACAnG,KAAM,CAAE+I,OAAAA,KAbL,CACLZ,aAAa,EACbC,MAAO,CACLjC,0EACAnG,KAAM,CAAEkI,OAAAA,KAbL,CACLC,aAAa,EACbC,MAAO,CACLjC,8EACAnG,KAAM,CAAEqD,YAAAA,OAqCL+I,0BAA4B,CACvC5J,KAAM,4BACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,OACV1E,EAAgByE,EAAhBzE,YACFgJ,EAAmBhJ,EACtBvE,IAAI,SAAC2C,EAAYoC,UACRuF,0BAA0B3H,KAAgB4H,2BAA2B5H,IAAe,CAC1FA,WAAAA,EACA9F,MAAOkI,KAGV6F,OAAOO,SAEJ4B,EAAU1Q,OAAOwD,KAAK0N,GAAkB1O,aAGvC,CACLwK,YAH8B,IAAZ0D,EAIlBzD,MAAO,CACLjC,wBAAkB0F,oEAClB7L,KAAM,CAAEqM,iBAAAA,EAAkBhJ,YAAAA,OAMrBiJ,kBAAoB,CAC/B9J,KAAM,oBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAY8C,IAAAA,qBACxB0B,EAAYpR,OAAOwD,KAAKkM,GACxB2B,EAAoB1E,EAAOiB,OAC3B0D,EAA4CD,EAC/C1N,IAAI,SAAA4N,UAAuD,IAAtCH,EAAUhE,QAAQmE,IAAyBA,IAChEhD,OAAOO,SACJ0C,EAA4CJ,EAC/CzN,IAAI,SAAA8N,UAAmE,IAAhDJ,EAAkBjE,QAAQqE,IAA2BA,IAC5ElD,OAAOO,SAGPP,OAAO,SAAAsB,UAAMA,IAAO7R,YAAqB,cAAP6R,UAK9B,CACL7C,YAJuE,IAArDsE,EAA0C9O,QACJ,IAArDgP,EAA0ChP,OAI7CyK,MAAO,CACLjC,mHACAnG,KAAM,CAAEyM,0CAAAA,EAA2CE,0CAAAA,OAM9CE,kBAAoB,CAC/BrK,KAAM,oBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAY0C,IAAAA,0BAA2BqC,IAAAA,gBAAiBxE,IAAAA,WACpEyE,EAAkB5R,OAAOwD,KAAK8L,GAC9BuC,EAAkBvO,MAAMuD,KAAK8K,EAAgBnO,QAAQ+K,OAAO,SAAAlJ,SAAkB,WAAbyE,QAAOzE,KACxE6D,EAAYlJ,OAAOwD,KAAK,CAACoO,EAAiBC,GAAiB1J,OAAO,SAACN,EAAKqB,UAC5EA,EAAU5I,QAAQ,SAAA0G,UAASa,EAAIb,IAAS,IACjCa,GACN,KACGiK,EAAoB9R,OAAOwD,KAAK2J,GAChC4E,EAA4CD,EAC/CnO,IAAI,SAAAqO,UAAuD,IAAtC9I,EAAUkE,QAAQ4E,IAAyBA,IAChEzD,OAAOO,SACJmD,EAA4C/I,EAC/CvF,IAAI,SAAAuO,UACHA,IAAsBnU,aAAgE,IAAlD+T,EAAkB1E,QAAQ8E,IAA6BA,IAC5F3D,OAAOO,eAKH,CACL9B,YAJuE,IAArD+E,EAA0CvP,QACJ,IAArDyP,EAA0CzP,OAI7CyK,MAAO,CACLjC,mHACAnG,KAAM,CAAEkN,0CAAAA,EAA2CE,0CAAAA,OAO9CE,gBAAkB,CAC7B9K,KAAM,kBACNqF,aAAa,EACb3J,UAAW,SAAC4J,SACH,CACLK,aAAa,EACbC,WAAO,KAMAmF,0BAA4B,CACvC/K,KAAM,4BACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAY+E,IAAAA,uBAE1BrO,MAAMuD,KAAK8K,EAAgBnO,QAAQ4J,QAAQrP,aAAe,EACrD,CACLiP,aAAa,EACbC,MAAO,CACLjC,wFACAnG,KAAM,CAAEwN,aAAc/O,MAAMuD,KAAK8K,EAAgBnO,QAAS0E,YAAayE,EAAOzE,eAK3E,CACL8E,aAAa,EACbC,WAAO,KAUFqF,sBAAwB,CACnCjL,KAAM,wBACNqF,aAAa,EACb3J,UAAW,SAAC4J,EAAQC,SAAY+E,IAAAA,gBAAiBxE,IAAAA,WAEzCoF,EADejP,MAAMuD,KAAK8K,EAAgBnO,QAE7CG,IAAI,SAAAsL,UACqB0C,EAAgBjR,IAAIuO,GAEzCtL,IAAI,SAAA6E,OACK3B,EAAgB2B,EAAhB3B,KAAMH,EAAU8B,EAAV9B,SACVuI,KAAe9B,IAAeA,EAAW8B,IAAgBpI,GAAQA,IAASoI,IAAgBvI,QACrF,CAAEM,MAAOiI,EAAazG,eAAAA,KAGhC+F,OAAOO,WAEXP,OAAO,SAAAlJ,UAAKA,EAAE7C,OAAS,UAEnB,CACLwK,YAA6C,IAAhCuF,EAAqB/P,OAClCyK,MAAO,CACLjC,oIACAnG,KAAM,CAAE0N,qBAAAA,OAMHC,aAAe,CAC1BC,SAAU,SAAC9F,EAAQC,SACV,CACLO,WAAYxF,cAAcgF,EAAOI,QACjCS,eAAgBhD,mBAAmBmC,EAAOzE,aAC1CkG,qBAAsBnG,wBAAwB0E,EAAOzE,aACrDoH,0BAA2BlH,6BAA6BuE,EAAOzE,aAC/DwH,qBAAsBrH,wBAAwBsE,EAAOzE,aACrDyH,YAAa5G,eAAe4D,EAAOI,QACnCuB,WAAYvG,cAAc4E,EAAOI,QACjCsD,iBAAkB/H,oBAAoBqE,EAAOzE,aAC7CyJ,gBAAiB7I,mBAAmB6D,EAAOzE,eAG/CwK,YAAa,gBACbC,UAAW,CAAC/B,cAAeuB,gBAAiB5E,8BAA+B6E,0BAA2BzE,iBAAkBsD,0BAA2BxE,mBAAoBS,iBAAkBI,gBAAiB6D,kBAAmBO,kBAAmB5D,mBAAoBC,uBAAwBI,8BAA+BM,uCAAwCU,0BAA2BmD,sBAAuBjD,kCAAmCI,0CAA2CW,wBAAyBJ,4BAA6BE,gCAY3hB,SAAS0C,oBAAoBC,EAAcjG,OACnCT,EAAUS,GAAYA,EAAS9H,OAAS8H,EAAS9H,MAAMqH,SAAWzH,aAClEM,EAAQ4H,GAAYA,EAAS9H,OAAS8H,EAAS9H,MAAME,OAASP,KAC9DqO,EAAuBD,EAAaH,mBAEnC,sCAA2BK,2BAAAA,sBAC1BC,EAAmB,GACnBC,EAAeJ,EAAaJ,SAAS9P,MAAM,KAAMoQ,GAsBjDG,EAAgB,CAAElG,YArBJ6F,EAAaF,UAAUxK,OAAO,SAACN,EAAK8C,OACxCE,EAAyCF,EAA/CtD,KAAoBtE,EAA2B4H,EAA3B5H,UAAW2J,EAAgB/B,EAAhB+B,YACjCyG,EAAWJ,EAAK9R,OAAOgS,KACElQ,EAAUJ,MAAM,KAAMwQ,GAA7CnG,IAAAA,YAAaC,IAAAA,MACfmG,YAAwBN,oBAA8BjI,SAClCoC,GAAS,GAA3BjC,IAAAA,QAASnG,IAAAA,QAEbmI,EAAa,OAAOnF,KAEtBmL,EAAiBtQ,KAAK,CAAE2E,KAAMwD,EAAcG,QAAAA,EAASnG,KAAAA,IACrDsH,EAAQpH,MAAMqO,GACdjH,EAAQpH,MAAM,CAAC8F,EAAcG,GAAShF,KAAK,OAC3CmG,EAAQrH,MAAM,yBAA0BD,GAEpC6H,EAAa,MAAM,IAAItB,MAAM,CAACgI,oCAAsDpN,KAAK,cAEpF,IAGV,GAEkCgN,iBAAAA,UACrChO,qBAASrG,eAAiBuU,IAEnBA,GAKX,IAAaG,mBAAqB,SAAC1G,EAAQC,EACR4F,UAAiBI,oBAAoBJ,EAAc5F,EAAlCgG,CAA4CjG,EAAQC,IAExG,SAAgB0G,eAAmCC,SAApB5G,IAAAA,OAAQC,IAAAA,SAA8BjB,IAAAA,iBAAkBC,IAAAA,UACjF2H,EAAgB,KACVP,EAAqBK,mBAAmB1G,EAAQC,EAAU2G,GAA1DP,qBAEFA,EAAiBxQ,OAAS,GAAGmJ,EAAiB,CAChDZ,6CACAiB,8BACAnH,KAAM,CAAE8H,OAAAA,EAAQC,SAAAA,EAAUoG,iBAAAA,GAC1BhI,oEAGJ,MAAOe,UAELH,EAAO,CACL4H,KAAMzU,2BACNiG,MAAO,CACLH,KAAMkH,EAAEQ,OACRvB,QAASe,EAAEf,QACXyI,aAAc,CAAEC,QAAI,EAAQC,QAAI,EAAQC,QAAI,MAGzC7H,aC5xBJ8H,oBACA,EAmBT,SAASC,0BAA0B/G,OAC3BgH,EAAY,QACdC,EAAa,GACbC,EAAe,YAiCVC,YA9BTnH,EAAS,CAAEoH,IAAKpH,GAiChBmH,EAAME,UAAY,CAChBC,mBAAoBtW,YAGtBiW,EAAWjW,YAAc,IAAImW,EAC7BF,EAAW9V,sBAAwB,IAAIgW,WAlC9BI,EAAoBvH,EAAQwH,GACnC/Q,KAAKuJ,GAAQzM,QAAQ,SAAUkU,OACvBC,EAAe1H,EAAOyH,MAM5BR,EAAWQ,GAAc,IAAID,EAC7BP,EAAWQ,GAAYnN,KAAOmN,EACTR,EAAWQ,GAAYE,YAAchP,YACxD6O,GAEFP,EAAWQ,GAAYT,UAAYA,EAEP,WAAxBjK,QAAO2K,GAA2B,CACpCR,EAAaO,IAAc,MACrBG,EAAuB,aAE7BA,EAAqBC,YAAcJ,EACnCG,EAAqBP,UAAYJ,EAAWQ,GAC5CF,EAAoBG,EAAcE,MAexCL,CAAoBvH,EAAQmH,GAErB,CACLF,WAAYA,EACZC,aAAcA,GAIX,SAASY,qBAAqBlI,OAC3Bc,EAAqCd,EAArCc,oBAAqBvF,EAAgByE,EAAhBzE,YACvBsF,EAAiBhD,mBAAmBtC,UAEtCuF,EACKvF,EACJjH,OAAO,CAAC,CAAE4F,KAAM9I,WAAY2I,MAAO1I,WAAYuI,GAAIkH,EAAqBrG,OAAQ/I,mBAE5EmP,EACAtF,OADJ,EAWA,SAAS4M,mBAAmBnI,EAAQC,OACnCmI,EAAMC,uBAAuBrI,EAAQC,UACvCmI,aAAe3J,MAAc2J,EACrBA,EAAIE,mBASX,SAASC,uBAAuBvI,EAAQC,OACvCmI,EAAMC,uBAAuBrI,EAAQC,UACvCmI,aAAe3J,MAAc2J,EACrBA,EAAII,kBAWX,SAASH,uBAAuBrI,EAAQC,OAEnCwI,EAKNzI,EALFI,OAGA+D,GAEEnE,EAJFiB,OAIEjB,EAFFmE,sBACapF,EACXiB,EADF0I,cAEsCzI,GAAY,GAA5C9H,IAAAA,MAAOwQ,IAAAA,QACT/B,KADkBqB,YACD9P,GAASA,EAAMyO,qBAAkB,GACpDpH,EAAUrH,GAASA,EAAMqH,SAAWzH,aACpCkH,EAAS0J,GAAWA,EAAQ1J,QAAUzG,YACpCwG,EAAmBO,wBAAwBC,EAASP,MAItD2H,EAAgB,KACZxH,EAAIuH,aAAa,CAAE3G,OAAAA,EAAQC,SAAAA,GAAY2G,EAAgB,CAAE5H,iBAAAA,EAAkBC,OAAAA,OAC7EG,aAAaX,MAAO,OAAOW,MAI3BwJ,EAAqB9J,kBAAkBC,EAA2B,CAAEC,iBAAAA,EAAkBC,OAAAA,IAGtF1D,EAAc2M,qBAAqBlI,GAanC6I,EAAmB1B,0BAA0BsB,GAE/CK,EAAc,GAGdC,EAAc,GAEZzB,EAAeuB,EAAiBvB,aAClCD,EAAawB,EAAiBxB,WAGlC9L,EAAY5H,QAAQ,SAAUgG,OACtBO,EAAmDP,EAAnDO,KAAMN,EAA6CD,EAA7CC,GAAIa,EAAyCd,EAAzCc,OAAQV,EAAiCJ,EAAjCI,MAAeiP,EAAkBrP,EAA1BkB,OAE1BmO,IACHA,EAAgB,CAAC,CAAE5S,eAAW,EAAQwD,GAAIA,EAAIa,OAAQA,KAIpDV,IAAU1I,aACZyX,EAAY5O,IAAQ,OAGlB+O,EAAa5B,EAAWnN,GAGvBH,IACHA,EAAQzI,WACRyX,EAAY7O,IAAQ,GAGlBoN,EAAapN,IAAS4O,EAAY5O,KACpC6O,EAAY7O,IAAQ,GAItB+O,EAAWlP,GAASiP,EAAcxN,OAChC,SAACN,EAAK8B,EAAOnJ,OACL4G,EAASuC,EAAMvC,QAAU/I,gBACzBwX,EAAazO,EAAOC,MAAQD,EAAOwN,aAAe,GAClDkB,EAAyB,SAAUnM,EAAOiD,OAKxCkJ,EAAwB,SAAUC,EAAgBC,EAAYC,GAClEpP,EAAOoP,GAAiBpP,MAClB9D,EAAY4G,EAAM5G,WAAa8Q,WAC/BqC,EAAgBnT,EAAUsE,MAAQtE,EAAU6R,aAAe,cAC3DrO,EAAKoD,EAAMpD,GACX4P,EAA2B,SAACtK,EAAemK,EAAYpJ,cAElD7J,EAAU8I,EAAemK,EAAYpJ,GAE9C,MAAOb,GACLJ,EAAiB,CACfZ,4CAAsCmL,GACtClK,gGACAnH,KAAM,CAAEgH,cAAAA,EAAenF,MAAAA,EAAOsP,WAAAA,EAAYpJ,SAAAA,EAAUjD,MAAAA,EAAO9C,KAAAA,EAAMN,GAAAA,EAAI/F,MAAAA,GACrEwK,QAAS,iDAA0CtE,gCAA2BH,GAAMwF,EAAEf,SAAShF,KAAK,MACpGiG,MAAOF,EAAEE,SAVkB,CAa9B8J,EAAgBC,EAAYpJ,MAEQ,kBAA5BuJ,GACTxK,EAAiB,CACfZ,4CAAsCmL,GACtClK,kGACAnH,KAAM,CAAE6B,MAAAA,EAAOiD,MAAAA,EAAO9C,KAAAA,EAAMN,GAAAA,EAAI/F,MAAAA,EAAO2V,wBAAAA,GACvCnL,8BAAwBxK,wBAAmB0V,kCAI3CC,EAAyB,CAE3BhK,EAAQtH,KAAK,YAAagC,GACtB8C,EAAM5G,WACR6I,EAAO,CACL4H,KAAMrU,UACN6F,MAAO,CACLgG,4BAAsBkL,mBACtBrR,KAAM,CAAE2G,UAAWwK,EAAYnP,KAAAA,EAAMO,OAAQyO,EAAYtP,GAAAA,GACzDkN,aAAc,CAAEC,GAAIuC,EAAetC,GAAIoC,EAAgBnC,GAAI5J,MAG/DmC,EAAQtH,2BAAoB9B,EAAUsE,wCAGtCuE,EAAO,CACL4H,KAAMrU,UACN6F,MAAO,CACLgG,+CACAnG,KAAM,CAAE2G,UAAWwK,EAAYnP,KAAAA,EAAMO,OAAQyO,EAAYtP,GAAAA,GACzDkN,aAAc,CAAEC,GAAIuC,EAAetC,GAAI9H,EAAe+H,GAAI5J,MAG9DmC,EAAQtH,oCAGVsH,EAAQtH,KAAK,gCAAkCgR,OACzCO,EAAgB,SAACvK,EAAeL,EAAWoB,cAEtCxF,EAAOyE,EAAeL,EAAWoB,GAE1C,MAAOb,GACLJ,EAAiB,CACfZ,wCAAkC8K,GAClC7J,sEACAnH,KAAM,CAAEgH,cAAAA,EAAenF,MAAAA,EAAOsP,WAAAA,EAAYpJ,SAAAA,EAAUjD,MAAAA,EAAO9C,KAAAA,EAAMN,GAAAA,EAAI/F,MAAAA,EAAO4G,OAAAA,GAC5E4D,QAASe,EAAEf,QACXiB,MAAOF,EAAEE,SAVO,CAanB8J,EAAgBC,EAAYpJ,GAE1B3B,UAAUmL,IACbzK,EAAiB,CACfZ,wCAAkC8K,GAClC7J,sEACAnH,KAAM,CAAEgH,cAAAA,EAAenF,MAAAA,EAAOsP,WAAAA,EAAYpJ,SAAAA,EAAUjD,MAAAA,EAAO9C,KAAAA,EAAMN,GAAAA,EAAI/F,MAAAA,EAAO4G,OAAAA,EAAQgP,aAAAA,GACpFpL,uFAIIzM,EAAqB6X,EAArB7X,QAASD,EAAY8X,EAAZ9X,kBA+VTuI,EAAMgF,EAAewK,GACvCrM,EAAUG,cAAcH,EAASb,EAAgBkN,EAAYxP,GAAMQ,MAEnE8E,EAAQtH,KAAK,aAAciB,KAAKe,IA/VtByP,CAAWzP,EAAMkP,EAAgB/B,GAGjCnI,EAAgB0J,EAAmBQ,EAAgBxX,aA+VvCgI,EAAIgQ,EAAsBF,OAC5CG,KAGAjR,sBAAsBgB,GAAK,KACvBkQ,EAAclQ,EAAG9H,MAAQA,KAAO8H,EAAG/H,SAAWA,aAAU,EACxDkY,EAAgBnQ,EAAGkQ,OAGpBhB,EAAYiB,GAAgB,KACzB1L,yJACNlG,GAASqH,GAAWA,EAAQpH,MAAMiG,GAClCW,EAAiB,CAAEX,QAAAA,IAKrBwL,EAAkBxM,EAAQyM,GAAaC,IAAkBA,OAGlDnQ,EACPiQ,EAAkBH,EAAY9P,GAAIc,KAIlCsE,EAAiB,CAAEX,QAAS,oFAE9B0I,EAAK8C,EAEL5K,EAAO,CACL4H,KAAMrU,UACN6F,MAAO,CACLgG,QAASzF,sBAAsBgB,wCACGA,EAAGA,EAAGoQ,KAAOlY,KAAO8H,EAAGqQ,QAAUpY,aAAU,6BACvD+H,GACtBkN,aAAc,CAAEC,GAAAA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAG/ClF,GAASqH,EAAQtH,KAAK,0BAA2B2R,IAlYfK,CAAetQ,EAAIhI,EAASyV,UACpD7H,EAAQtH,KAAK,wBAAyB6O,GACtCvH,EAAQtH,KAAK,wBAAyBgH,GAG/B,CAAEiL,MAAM,EAAMxY,QAAAA,UAIrBsN,EAAO,CACL4H,KAAMrU,UACN6F,MAAO,CACLgG,QAASrB,EAAM5G,8BAAyBmT,2DACxCrR,KAAM,CAAE2G,UAAWwK,EAAYpJ,SAAAA,EAAUjD,MAAAA,EAAO9C,KAAAA,EAAMN,GAAAA,EAAI/F,MAAAA,EAAO4G,OAAQyO,GACzEpC,aAAc,CAAEC,GAAIuC,EAAetC,GAAI9H,EAAe+H,GAAI5J,MAGvD,CAAE8M,MAAM,EAAOxY,QAAS,cAInCwX,EAAsBlB,YAAc/N,EAlHb,GAmHhBiP,EApHsB,CAqH5BnM,EAAOiD,UAEH,SAAiCmJ,EAAgBC,EAAYC,OAC5Dc,EAAoBlP,EAAIkO,EAAgBC,EAAYC,UACnDc,EAAkBD,KACrBC,EACAjB,EAAsBC,EAAgBC,EAAYC,KAG1D,iBACS,CAAEa,MAAM,EAAOxY,QAAS,gBASC0K,mBAAmBoM,GAAjDlM,IAAAA,UAAWC,IAAAA,eACfa,EAAUC,yBAAyBf,GACnC2C,EAAgBiF,EAChB4C,EAAK3V,eAIPiZ,IAEF,MAAOjL,UAELH,EAAO,CACL4H,KAAMzU,2BACNiG,MAAO,CACLgG,QAASe,EAAEf,QACXnG,KAAM,CAAE8H,OAAAA,EAAQC,SAAAA,EAAU7H,MAAOgH,GACjC0H,aAAc,CAAEC,GAAI3V,WAAY4V,GAAI9H,EAAe+H,GAAI5J,MAG3DmC,GAAWA,EAAQpH,oDAAqDgH,GAEjEA,MAGHkL,EAAU,CAYdhC,mBAAoB,SAAaiC,aAEI5L,iBAAiB4L,GAA1C3L,IAAAA,UAAWC,IAAAA,UAEnBI,EAAO,CACL4H,KAAM3U,UACNmG,MAAO,CACLH,KAAM,CAAE0G,UAAAA,EAAWC,UAAAA,GACnBiI,aAAc,CAAEC,GAAIA,EAAIC,GAAI9H,EAAe+H,GAAI5J,UAI7C1L,EAAU6Y,EAAUD,GAAO,UAEjCpS,GAASqH,EAAQtH,KAAK,WAAYvG,GAClCsN,EAAO,CACL4H,KAAM5U,YACNoG,MAAO,CACL1G,QAAAA,EACAmV,aAAc,CAAEC,GAAAA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAIxC1L,EAET,MAAOyN,MACDA,aAAaK,mBAEfR,EAAO,CACL4H,KAAMxU,UACNgG,MAAO,CACLD,MAAOgH,EACPf,uEACAyI,aAAc,CAAEC,GAAAA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAIxC+B,QAGPH,EAAO,CACL4H,KAAMxU,UACNgG,MAAO,CACLD,MAAOgH,EACPf,+EACAyI,aAAc,CAAEC,GAAAA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAG/CmC,EAAQpH,mCAAoCgH,GAEtCA,IAcZoJ,kBAAmB,SAAiB+B,EAAOE,WACxB,IAAbA,QAKC,GAAiB,OAAbA,EAEPvL,EAAgBiF,EAChB9G,EAAUC,yBAAyBf,GACnC8K,EAAWjW,YAAYsW,mBAAqBtW,WAC5CiZ,QAEG,KAESK,EAAgBD,EAApB1D,GAASE,EAAWwD,EAAXxD,GAAID,EAAOyD,EAAPzD,GACrB9H,EAAgB8H,EAChB3J,EAAU4J,EACVF,EAAK2D,QAcA,CAAE/Y,QAVO2Y,EAAQhC,mBAAmBiC,GAUzBE,SAAU,CAAE1D,GAAAA,EAAIE,GAAI5J,EAAS2J,GAAI9H,aAIhDoL,WA+BEE,EAAUG,EAAcC,OAlBzBC,EAAAA,EAAY9M,OAmBHQ,cAAe,CAACoM,IAlB3B/D,GAAkBiE,GACpB7L,EAAiB6L,SAmBclM,iBAAiBgM,GAA1C/L,IAAAA,UAAWC,IAAAA,aAEnBW,EAAQlH,MAAM,cAAgBsG,GAAa,IAC3CY,EAAQxH,IAAI2S,IAYPC,GAAmBhM,IAAcvN,YAAc0V,IAAO3V,kBACzD6N,EAAO,CACL4H,KAAM1U,SACNkG,MAAO,CACLH,KAAM,CAAE0G,UAAAA,EAAWC,UAAAA,GACnBR,oFACAyI,aAAc,CAAEC,GAAIA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAGnDmC,EAAQvH,kFACRuH,EAAQjH,WAED,SAGH5G,WAYc0V,EAAYtN,EAAO8E,EAAWK,OAC5C4L,EAAkB/D,EAClBgE,EAAe1D,EAAWyD,GAAiB/Q,OAG7CgR,SAqEFvL,EAAQvH,+DAAwD8B,yBAAoBgN,SACpF9H,EAAO,CACL4H,KAAM1U,SACNkG,MAAO,CACLH,KAAM,CAAE8S,4BAAajR,EAAQ8E,IAC7BR,kEAA4DtE,yBAAoBgN,QAChFD,aAAc,CAAEC,GAAIA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAI5C,KA9EPmC,EAAQxH,IAAI,wBACZwH,EAAQtH,KAAK,cAAe6B,EAAO8E,SAMGkM,EAAa7L,EAAeL,EAAWiM,GAArEX,IAAAA,KAAec,IAATtZ,QACRuZ,EAAkBnE,EACxB5O,IAAUgS,GAAQ3K,EAAQvH,KAAK,iHAEzBtG,EAAUsL,eAAegO,OAU3BlC,EAAYmC,GA2CX,OAAOvZ,KA1CNuZ,IAAoBJ,EAAiB,KACjCK,EAAarC,EAAYoC,GAC3B7Z,WACAC,WAEJ2N,EAAO,CACL4H,KAAMvU,mBACN+F,MAAO,CACLH,KAAM,CAAE0G,UAAWuM,EAAYtM,UAAWA,GAC1C9E,yBAAUoR,EAAatM,GACvBiI,aAAc,CAAEC,GAAAA,EAAIC,GAAI9H,EAAe+H,GAAI5J,UAIzC+N,EAAcZ,qBAAaW,EAAatM,IAAa,UAE3DI,EAAO,CACL4H,KAAMtU,qBACN8F,MAAO,CACL1G,QAASyZ,EACTtE,aAAc,CAAEC,GAAAA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAIxC,GAAG/I,OAAO3C,GAAS2C,OAAO8W,GAOjC5L,EAAQpH,8CAAuC2B,yBAAoBgN,uGACnE9H,EAAO,CACL4H,KAAMxU,UACNgG,MAAO,CACLH,KAAM,CAAE8S,4BAAajR,EAAQ8E,IAC7BR,gDAA0CtE,yBAAoBgN,sGAC9DD,aAAc,CAAEC,GAAIA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MA7EzCgO,CACdxC,EAAiBxB,WACjBzI,EACAC,EACAK,UAGFM,EAAQjH,WAED5G,WA2IA0Y,WACPpL,EAAO,CACL4H,KAAMpU,eACN4F,MAAO,CACLH,KAAM,CAAE0G,UAAWvN,WAAYwN,UAAWsF,GAC1CpK,yBAAU1I,WAAa8S,GACvB2C,aAAc,CAAEC,GAAAA,EAAIC,GAAI9H,EAAe+H,GAAI5J,MAIxCmN,qBAAanZ,WAAa8S,IAAwB,IAoBtD,SAASmH,+BAA0B5Q,IAAAA,KAAMqQ,IAAAA,aAAcQ,IAAAA,IAAKC,IAAAA,gBAAiBC,IAAAA,eAAgBC,IAAAA,QAC5FC,4DAEEjR,EAAKkR,MAAM,KAAK/V,QAAU,EAAG,oJAE3BgW,6FACDC,aAAef,IACfW,QAAUrY,OAAOC,OAAO,GAAIoY,OAC3BK,EAAYpM,EAAK+L,QAAQK,WAAa,cAGvCD,aAAaE,UAAU,CAC1BC,KAAM,SAAAC,OACEC,EAAUZ,EAAIW,MAEhBC,aAAmB1N,MAGrBe,SAAWA,QAAQxH,IAAImU,OAEpB,CAAA,GAAIA,IAAYJ,EAAW,OAE9BI,EAAQxY,QAAQ,SAAA8G,MACVA,IAAWsR,OACPK,EAAoB3R,EAApB2R,QAASC,EAAW5R,EAAX4R,OACjBb,EAAgBY,GAASzM,EAAKmM,aAAaG,KAAMI,EAAQZ,EAAgBI,gDAxB1DS,6EAsClBZ,QAAQa,cAAgBC,KAAKV,aAAaG,KAAKO,KAAKd,QAAQa,kEAI5Db,QAAQe,eAAiBD,KAAKV,aAAaG,KAAKO,KAAKd,QAAQe,oBAC7DX,aAAaY,4DAGKhS,EAAMiS,EAAUC,uDAZhC,mBAiBJC,eAAeC,OAAOpS,EAAMiR,GAyC9B,SAAS9H,aAAaiG,EAAa7P,6BAErC6P,EAAc7P,GCh0BnB,SAAS8S,4BAA4B1S,EAAO2S,UACnCA,mBACOA,kBAAsB3S,qCACtBS,eAAeT,mBAAcA,oBAQtC,SAAS4S,WAAWjN,EAAQC,OACzBG,EAAwBJ,EAAxBI,OAAQ7E,EAAgByE,EAAhBzE,YACRpG,EAAyCsB,iBAAzCtB,YAA4BuB,EAAaD,iBAAbC,SAC9BzD,EAAY,SAAAiB,UAAQA,EAAKmF,KAAKtI,MAmB9Bmc,EAAiB/W,sBAAsBM,iBAjB5B,CACfpB,KAAM,kBAAME,KACZH,MAAO,SAAC+X,EAAS3Z,EAAgBgB,OACvBN,EAASV,EAAeO,IAAIS,GAA5BN,KACFiH,EAAYzE,EAASlC,GAMrB4Y,EAAcC,gBALCha,OAAOwD,KAAKsE,GAAW,GAChB7B,QAC1B,SAAAzF,UAASsZ,EAAQpZ,IAAId,EAAUiB,EAAKI,OAAOT,MARvB,SAACW,EAAMhB,UAAmB2B,EAAYX,EAAMhB,GAAgBqC,OAShFyX,CAAkB9Y,EAAMhB,IAE6C+H,UACvE4R,EAAQhZ,IAAIlB,EAAUiB,GAAOkZ,GAEtBD,uBAIiE/b,WAAagP,IAEnFmN,EAAaL,EAAenZ,IAAI,YACtCmZ,EAAexX,QAER6X,EAWT,SAASF,gBAAgBpT,EAAcuT,EAAqBjS,SACnD,WACFwR,4BAA4B9S,EAAc,UAC7CuT,EAAoBnU,KAAK,MACzBoU,sBAAsBxT,EAAcsB,GACpCmS,yBAAyBzT,EAAcsB,OAEvCoS,sBAAsB1T,EAAcsB,IAEnCqG,OAAO,SAAAlJ,SAAW,OAANA,GAAoB,KAANA,IAC1BW,KAAK,MAGV,SAASoU,sBAAsBxT,EAAcsB,OAGrCqS,EAAmBrS,EAAYC,OAAO,SAACqS,EAAgBlU,UACpCiB,oBAAoBjB,GAGxCiI,OAAOlI,uBACPkI,OAAOzH,+BAA+BF,IACtCuB,OAAO,SAACN,EAAKvB,UACZuB,EAAIP,qCAAqChB,SAAe,EACjDuB,GACN2S,IACJ,WACmBxa,OAAOwD,KAAK+W,GAEb5W,IAAI,SAAA6M,mBACbkJ,4BAA4BlJ,EAAc3S,uBACnDmI,KAAK,MAGV,SAASsU,sBAAsB1T,EAAcsB,SAIpC,CAH8BuS,2BAA2B7T,EAAcsB,GACxCwS,4BAA4B9T,EAAcsB,IAM7EqG,OAAOO,SACP9I,KAAK,MAGV,SAAS0U,4BAA4B9T,EAAcsB,UAE7CtB,IAAiB7I,WAAmB,GAC5BmK,EAAYvE,IAAI,SAAA2C,UACHiB,oBAAoBjB,GAGxCiI,OAAO5H,sBAAsBC,IAC7B2H,OAAO,SAAAjI,UAAeG,oBAAoBH,KAC1CiI,OAAO,SAAAjI,UAAeD,sBAAsBC,KAC5C3C,IAAI,gBAAGkD,IAAAA,KAAMH,IAAAA,MAAO3D,IAAAA,UAAWwD,IAAAA,GAAIa,IAAAA,aAC3B,CACLP,EACAlJ,kBACA4I,EACA3I,8BACAsJ,wBAAwBR,EAAO3D,EAAWqE,IAC1CpB,KAAK,OACNA,KAAK,QAGTuI,OAAOO,SACP9I,KAAK,MAGV,SAASqU,yBAAyBzT,EAAcsB,UAC1BA,EAAYC,OAAO,SAACqS,EAAgBlU,UAC/BiB,oBAAoBjB,GAGxCiI,OAAO9H,qBACP8H,OAAO5H,sBAAsBC,IAC7BuB,OAAO,SAACN,EAAKvB,GAC4BA,EAAhCO,SAAMN,EAA0BD,EAA1BC,GAAIxD,EAAsBuD,EAAtBvD,UAAWqE,EAAWd,EAAXc,cAC7BS,EAAInF,mBACK/E,8BAAqB4I,cAAM3I,0CAAiCsJ,wBAAwB,GAAInE,EAAWqE,KAErGS,GACN2S,IACJ,IAEgBxU,KAAK,MAG1B,SAASyU,2BAA2B7T,EAAcsB,UACzCA,EAAYvE,IAAI,SAAA2C,UACEiB,oBAAoBjB,GAGxCiI,OAAO5H,sBAAsBC,IAC7B2H,OAAOlI,uBACP1C,IAAI,gBAAGkD,IAAAA,KAAMH,IAAAA,MAAO3D,IAAAA,UAAWwD,IAAAA,GAAIa,IAAAA,aAC3B,CACLP,EACAlJ,kBACA2J,qCAAqC,CAAET,KAAAA,EAAMN,GAAAA,IAC7C3I,8BACAsJ,wBAAwBR,EAAO3D,EAAWqE,IAC1CpB,KAAK,OACNA,KAAK,QAETuI,OAAOO,SACP9I,KAAK,MAGH,SAAS2U,wBAAwBhO,OAI9BI,EAAwBJ,EAAxBI,OAAQ7E,EAAgByE,EAAhBzE,YACR7E,EAA0BD,iBAA1BC,SAAUvB,EAAgBsB,iBAAhBtB,YACVgC,EAAkBU,gBAAlBV,cAEFlE,EAAY,SAAAiB,UAAQA,EAAKmF,KAAKtI,MAkB9Bkd,EADoB9X,sBAAsBM,iBAhB/B,CACfpB,KAAM,kBAAME,KACZH,MAAO,SAAC+X,EAAS3Z,EAAgBgB,OACvBN,EAASV,EAAeO,IAAIS,GAA5BN,KACFiH,EAAYzE,EAASlC,GACrByF,EAAe5G,OAAOwD,KAAKsE,GAAW,GACtC/D,EAAWkC,QACf,SAAAzF,UAASsZ,EAAQpZ,IAAId,EAAUiB,EAAKI,OAAOT,MATvB,SAACW,EAAMhB,UAAmB2B,EAAYX,EAAMhB,GAAgBqC,OAUhFyX,CAAkB9Y,EAAMhB,WAE1B2Z,EAAQhZ,IAAIlB,EAAUiB,GAAOiD,EAAc8C,EAAc7C,IAElD+V,uBAIoE/b,WAAagP,IACjDrM,IAAI,KAEzCma,EAAwB3S,EAAYvE,IAAI,SAAA2C,OACpCO,EAAoCP,EAApCO,KAAMN,EAA8BD,EAA9BC,GAAIG,EAA0BJ,EAA1BI,MAAOc,EAAmBlB,EAAnBkB,OAAQJ,EAAWd,EAAXc,cAC7BI,EAKK,CAAEX,KAAAA,EAAMH,MAAAA,EAAOc,OAJGA,EAAO7D,IAAI,SAAAgG,OAC1B5G,EAA0B4G,EAA1B5G,UAAWwD,EAAeoD,EAAfpD,GAAIa,EAAWuC,EAAXvC,aAChB,CAAErE,UAAWA,EAAUsE,KAAMd,GAAAA,EAAIa,OAAQA,EAAOC,SAMlD,CAAER,KAAAA,EAAMN,GAAAA,EAAIG,MAAAA,EAAOU,OAAQA,EAAOC,MAAQ,4BAI9C3H,KAAKE,UAAU,CAAEmN,OAAQ6N,EAAkB1S,YAAa2S"}