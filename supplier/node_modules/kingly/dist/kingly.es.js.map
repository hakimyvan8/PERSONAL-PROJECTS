{"version":3,"file":"kingly.es.js","sources":["../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js","../src/index.js"],"sourcesContent":["export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, MACHINE_CREATION_ERROR_MSG,\r\n  NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop, group:noop, groupEnd: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\n/**\r\n * @description takes an output and turns it into an array\r\n * @param {*} output\r\n * @returns {*[]|null} if the output is null: null, if output is an array: output, else: [output]\r\n */\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {HistoryState} _history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {HistoryState}\r\n * @modifies history\r\n */\r\nexport function updateHistory(_history, stateAncestors, state_from_name) {\r\n  // 27.08.2020: Now that I expose history state I have to make sure that it is not mutated!!\r\n  // We have a fixed format here, so we use native `assign` at deepest level\r\n  const history = {\r\n    [DEEP]: Object.assign({}, _history[DEEP]),\r\n    [SHALLOW]: Object.assign({}, _history[SHALLOW]),\r\n  };\r\n\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function(...*): True | Error} contract Contract that either fulfills or returns an error\r\n * @param {Array<*>} arrayParams Parameters to be passed to the contract\r\n * @returns {undefined|{when, location, info, message}|Object} either true (fulfilled contract)\r\n * or an object with optional properties for diagnostic and tracing purposes\r\n * about the cause of the error if the contract is not fulfilled\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport function wrapUpdateStateFn(userProvidedUpdateStateFn, {throwKinglyError, tracer}){\r\n  return (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n}\r\n\r\nexport function throwKinglyErrorFactory (console,tracer)  {\r\n  return obj => {\r\n  throw new KinglyError(obj, console, tracer)\r\n  }\r\n};\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n  emptyConsole,\r\n  findInitTransition,\r\n  getAncestorMap,\r\n  getEventTransitionsMaps,\r\n  getHistoryStatesMap,\r\n  getHistoryUnderlyingState,\r\n  getStatesPath,\r\n  getStatesTransitionsMap,\r\n  getStateEventTransitionsMaps,\r\n  getStatesType,\r\n  getTargetStatesMap,\r\n  isActionFactory,\r\n  isControlState,\r\n  isEvent,\r\n  isFunction,\r\n  isHistoryControlState,\r\n  noop\r\n} from \"./helpers\"\r\n// @ts-ignore\r\nimport { objectTreeLenses, PRE_ORDER, traverseObj } from \"fp-rosetree\"\r\nimport { CONTRACTS_EVAL, INIT_EVENT, INIT_STATE, MACHINE_CREATION_ERROR_MSG } from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n  name: 'noDuplicatedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { getLabel } = objectTreeLenses;\r\n    const traverse = {\r\n      strategy: PRE_ORDER,\r\n      seed: { duplicatedStates: [], statesHashMap: {} },\r\n      visit: (acc, traversalState, tree) => {\r\n        const { duplicatedStates, statesHashMap } = acc;\r\n        const treeLabel = getLabel(tree);\r\n        const controlState = Object.keys(treeLabel)[0];\r\n        if (controlState in statesHashMap) {\r\n          return {\r\n            duplicatedStates: duplicatedStates.concat(controlState),\r\n            statesHashMap\r\n          }\r\n        }\r\n        else {\r\n          return {\r\n            duplicatedStates,\r\n            statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const { duplicatedStates } = traverseObj(traverse, fsmDef.states);\r\n\r\n    const isFulfilled = duplicatedStates.length === 0;\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n        info: { duplicatedStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n  name: 'noReservedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n      blame: {\r\n        message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n        info: { reservedStates: [INIT_STATE], statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n  name: 'atLeastOneState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).length > 0,\r\n      blame: {\r\n        message: `Machine configuration must define at least one control state! Cf. log`,\r\n        info: { statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n  name: 'isInitialControlStateDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition, statesType }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const stateList = Object.keys(statesType);\r\n    if (initialControlState) {\r\n      return {\r\n        isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n        blame: {\r\n          message: `Configured initial control state must be a declared state. Cf. log`,\r\n          info: { initialControlState, declaredStates: stateList }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n\r\n  },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n  name: 'eventsAreStrings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    return {\r\n      isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n      blame: {\r\n        message: `Events must be an array of strings!`,\r\n        info: { events: fsmDef.events }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n  name: 'validInitialConfig',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState } = fsmDef;\r\n\r\n    if (initTransition && initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else if (!initTransition && !initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n  },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n  name: 'validInitialTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const initTransitions = transitions.reduce((acc, transition) => {\r\n      transition.from === INIT_STATE && acc.push(transition);\r\n      return acc\r\n    }, []);\r\n    // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n    // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n    // enforce the part of the contract which require to have no actions for initial transitions...\r\n    const isFulfilled =\r\n      (initialControlState && !initTransition) ||\r\n      (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n        && (\r\n          isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n          || areCconditionalTransitions(initTransition)\r\n          // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n        )\r\n      );\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Invalid configuration for initial transition! Cf. log`,\r\n        info: { initTransition, initTransitions, initialControlState }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n  name: 'initEventOnlyInCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n    const atomicInitTransitions = atomicStates.map(\r\n      atomicState => ({\r\n        [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n      })\r\n    ).filter(obj => Object.values(obj)[0]);\r\n\r\n    const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n    return {\r\n      isFulfilled: hasInitEventOnlyInCompoundStates,\r\n      blame: {\r\n        message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n        info: { initTransitions: atomicInitTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n  name: 'validInitialTransitionForCompoundState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n    const compoundStatesInitTransitions = compoundStates.map(\r\n      compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n    const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n    if (!allHaveInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state without an entry transition! Cf. log`,\r\n          info: {\r\n            hasEntryTransitions: compoundStates.map(\r\n              state => ({ [state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT]) }))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { guards, to } = initTransition;\r\n        if (!guards) {\r\n          //  T7a\r\n          return typeof to === 'string'\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(targetState => typeof targetState === 'string')\r\n        }\r\n      });\r\n    if (!allHaveValidInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n          info: { entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n    ;\r\n\r\n    const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { from, guards, to } = initTransition;\r\n\r\n        // Don't forget to also eliminate the case when from = to\r\n        // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n        // other from declared states\r\n        if (!guards) {\r\n          return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(to => {\r\n            return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n          })\r\n        }\r\n      });\r\n    if (!allHaveTargetStatesWithinHierarchy) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n          info: { states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n  name: 'validEventLessTransitions',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const stateList = Object.keys(statesType);\r\n    const failingOriginControlStates = stateList.map(state => {\r\n      return {\r\n        [state]: statesTransitionsMap[state] &&\r\n        `${void 0}` in statesTransitionsMap[state] &&\r\n        Object.keys(statesTransitionsMap[state]).length !== 1\r\n      }\r\n    }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n    const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n        info: { failingOriginControlStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n  name: 'allStateTransitionsOnOneSingleRow',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n      const events = Object.keys(stateEventTransitionsMaps[state]);\r\n      const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n      if (wrongEventConfig.length > 0) {\r\n        acc[state] = wrongEventConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n        info: { statesTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n  name: 'noConflictingTransitionsWithAncestorState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n    const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n      const states = Object.keys(eventTransitionsMaps[event]);\r\n      // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n      const wrongStateConfig = states\r\n        .filter(state => state !== INIT_STATE)\r\n        .map(state => ancestorMap[state] && {\r\n          [state]: ancestorMap[state].find(\r\n            ancestorState => states.indexOf(ancestorState) > -1\r\n          )\r\n        })\r\n        // removing cases : undefined and {[state]: undefined}\r\n        .filter(obj => {\r\n          return obj && Object.values(obj).filter(Boolean).length > 0\r\n        });\r\n\r\n      if (wrongStateConfig.length > 0) {\r\n        acc[event] = wrongStateConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n        info: { eventTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n  name: 'isHistoryStatesTargetStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, {}) => {\r\n    const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n      return isHistoryControlState(transition.from)\r\n        ? acc.concat(transition)\r\n        : acc\r\n    }, []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n        info: { wrongHistoryStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n  name: 'isHistoryStatesCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const wrongHistoryStates = originStateList.map(originState => {\r\n      if (originState === INIT_STATE) return []\r\n\r\n      const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n      return events.reduce((acc, event) => {\r\n        // I should only ever have one transition, that is checked in another contract\r\n        // !! if there are several transitions, we may have a false positive, but that is ok\r\n        // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n        // this will be recomputed correctly\r\n        const transition = stateEventTransitionsMaps[originState][event][0];\r\n        const { guards, to } = transition;\r\n        if (!guards) {\r\n          // Reminder: statesType[controlState] === true iff controlState is compound state\r\n          return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n            ? acc.concat(transition)\r\n            : acc\r\n        }\r\n        else {\r\n          return guards.reduce((acc, guard) => {\r\n            const { to } = guard;\r\n\r\n            return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n              ? acc.concat(transition)\r\n              : acc\r\n          }, acc)\r\n        }\r\n      }, [])\r\n    })\r\n      .reduce((acc, x) => acc.concat(x), []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n        info: { wrongHistoryStates, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n  name: 'isHistoryStatesExisting',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { historyStatesMap, statesType }) => {\r\n    const invalidTransitions = Array.from(historyStatesMap.entries())\r\n      .map(([historyState, flatTransitions]) => {\r\n        return !(historyState in statesType) && { historyState, flatTransitions }\r\n      })\r\n      .filter(Boolean);\r\n\r\n    const howMany = Object.keys(invalidTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n        info: { invalidTransitions, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n  const { from, event, guards, to, action } = transition;\r\n\r\n  return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n  const { to, predicate, action } = guard;\r\n\r\n  return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n  const { from, event, guards, to } = transition;\r\n\r\n  return guards && Array.isArray(guards) && guards.length > 0\r\n    && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n  name: 'isValidFsmDef',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions, states, events, initialExtendedState } = fsmDef;\r\n    const isValidTransitions = transitions && Array.isArray(transitions);\r\n    const isValidStates = states && typeof(states) === 'object';\r\n    const isValidEvents = events && Array.isArray(events);\r\n    if (!isValidTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The transitions property for a machine definition must be an array!`,\r\n          info: { transitions }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidStates) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The states property for a machine definition must be an object!`,\r\n          info: { states }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidEvents) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The events property for a machine definition must be an array!`,\r\n          info: { events }\r\n        }\r\n      }\r\n    }\r\n    // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n    // this is done in other contracts\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n  name: 'haveTransitionsValidTypes',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions } = fsmDef;\r\n    const wrongTransitions = transitions\r\n      .map((transition, transitionIndex) => {\r\n        return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n          transition,\r\n          index: transitionIndex\r\n        }\r\n      })\r\n      .filter(Boolean)\r\n\r\n    const howMany = Object.keys(wrongTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n        info: { wrongTransitions, transitions }\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n  name: 'areEventsDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { eventTransitionsMaps }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps);\r\n    const declaredEventList = fsmDef.events;\r\n    const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n      .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n      .filter(Boolean);\r\n    const eventsNotDeclaredButTriggeringTransitions = eventList\r\n      .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n      .filter(Boolean)\r\n      // Filtering out init events which must not be declared, being reserved events\r\n      // Filtering out undefined events linked to eventless transitions\r\n      .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n    const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n      && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n        info: { eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n  name: 'areStatesDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, targetStatesMap, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n    const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n      stateList.forEach(state => acc[state] = true)\r\n      return acc\r\n    }, {}));\r\n    const declaredStateList = Object.keys(statesType);\r\n    const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n      .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n      .filter(Boolean);\r\n    const statesNotDeclaredButTriggeringTransitions = stateList\r\n      .map(stateInTransition =>\r\n        stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n      .filter(Boolean);\r\n\r\n    const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n      && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n        info: { statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n  name: 'isValidSettings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef) => {\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n  name: 'isInitialStateOriginState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap }) => {\r\n\r\n    if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one transition with the initial state as target state! CF. log`,\r\n          info: { targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n  name: 'isValidSelfTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap, statesType }) => {\r\n    const targetStates = Array.from(targetStatesMap.keys());\r\n    const wrongSelfTransitions = targetStates\r\n      .map(targetState => {\r\n        const flatTransitions = targetStatesMap.get(targetState);\r\n        return flatTransitions\r\n          .map(flatTransition => {\r\n            const { from, event } = flatTransition;\r\n            if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n              return { state: targetState, flatTransition }\r\n            }\r\n          })\r\n          .filter(Boolean)\r\n      })\r\n      .filter(x => x.length > 0);\r\n\r\n    return {\r\n      isFulfilled: wrongSelfTransitions.length === 0,\r\n      blame: {\r\n        message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n        info: { wrongSelfTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const fsmContracts = {\r\n  injected: (fsmDef, settings) => {\r\n    return {\r\n      statesType: getStatesType(fsmDef.states),\r\n      initTransition: findInitTransition(fsmDef.transitions),\r\n      statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n      stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n      eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n      ancestorMap: getAncestorMap(fsmDef.states),\r\n      statesPath: getStatesPath(fsmDef.states),\r\n      historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n      targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n    }\r\n  },\r\n  description: 'FSM structure',\r\n  contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n  const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n  const trace = settings && settings.debug && settings.debug.trace || noop;\r\n  const contractsDescription = contractsDef.description;\r\n\r\n  return function checkContracts(...args) {\r\n    const failingContracts = [];\r\n    const computedArgs = contractsDef.injected.apply(null, args);\r\n    const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n      const { name: contractName, predicate, shouldThrow } = contract;\r\n      const fullArgs = args.concat(computedArgs);\r\n      const { isFulfilled, blame } = predicate.apply(null, fullArgs);\r\n      const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n      const { message, info } = blame || {};\r\n\r\n      if (isFulfilled) return acc\r\n      else {\r\n        failingContracts.push({ name: contractName, message, info });\r\n        console.error(blameMessageHeader);\r\n        console.error([contractName, message].join(': '));\r\n        console.debug('Supporting error data:', info);\r\n\r\n        if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n        else {\r\n          return false\r\n        }\r\n      }\r\n    }, true)\r\n\r\n    const contractsEval = { isFulfilled, failingContracts };\r\n    trace({ [CONTRACTS_EVAL]: contractsEval })\r\n\r\n    return contractsEval\r\n  }\r\n}\r\n\r\n// @ts-ignore error here is due to variable number of arguments, not worth spending time there\r\nexport const fsmContractChecker = (fsmDef, settings,\r\n                                   fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\nexport function runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer }) {\r\n  if (checkContracts) {\r\n    const { failingContracts } = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: { fsmDef, settings, failingContracts },\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: { cs: void 0, es: void 0, hs: void 0 }\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","//@ts-check\r\nimport {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap,\r\n  throwKinglyErrorFactory, wrapUpdateStateFn\r\n} from \"./helpers\";\r\nimport { runContracts } from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * @description Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state`: Hash matching keys (state names) to whether that state is a nested state\r\n * `hash_states`: Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hashStates: {}, isGroupState: Object<String,Boolean>}}\r\n */\r\nfunction buildNestedStateStructure(states) {\r\n  const root_name = \"State\";\r\n  let hashStates = {};\r\n  let isGroupState = {};\r\n\r\n  // Add the starting state\r\n  states = { nok: states };\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hashStates[state_name] = new curr_constructor();\r\n      hashStates[state_name].name = state_name;\r\n      const parent_name = (hashStates[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hashStates[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        isGroupState[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hashStates[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hashStates[INIT_STATE] = new State();\r\n  hashStates[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hashStates: hashStates,\r\n    isGroupState: isGroupState\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const { initialControlState, transitions } = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{ from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY }])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} [settings]\r\n * @returns {Error | Stateful_FSM}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withProtectedState\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @returns {Error | Pure_FSM}\r\n */\r\nexport function createPureStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withPureInterface\r\n}\r\n\r\n/**\r\n * @description Creates an instance of state machine from a set of states, transitions,\r\n * and accepted events. The initial extended state for the machine is included\r\n * in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {{withProtectedState: Stateful_FSM, withPureInterface: Pure_FSM}|Error}\r\n */\r\nexport function createStateMachineAPIs(fsmDef, settings) {\r\n  const {\r\n    states: controlStates,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const { debug, devTool, displayName } = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = throwKinglyErrorFactory(console, tracer);\r\n\r\n  // Check contracts if the API user wants to,\r\n  // but don't throw errors, return them and possibly log them\r\n  if (checkContracts) {\r\n    const e = runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer });\r\n    if (e instanceof Error) return e\r\n  }\r\n\r\n  // Wrap user-provided update state function to capture errors\r\n  const wrappedUpdateState = wrapUpdateStateFn(userProvidedUpdateStateFn, { throwKinglyError, tracer });\r\n  // We also massage the shape of the user-provided transitions,\r\n  // unifying the two ways of providing an initial state for the machine\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create auxiliary data structures to quickly answer common queries:\r\n  // - is `stateName` a state that has an initial transition configured\r\n  //   (top-level, or compound state) : `isInitState[stateName]`\r\n  // - is `stateName` a transient state, i.e. with an configured\r\n  //   initial or eventless transitions: `isAutoState[stateName]`\r\n  // - is `stateName` a compound state: `isGroupState[stateName]`\r\n  // - what computation to run in `stateName`:\r\n  //   `hashStates[stateName][event]` has the event handler for `event`\r\n  //    NOTE: we use JS prototypal inheritance to make this work even when\r\n  //    A < ... < B. and the event handler in configured on parent A, and not on B\r\n  //    When the machine is in state B, it must answer to the event as A would\r\n  const hashStatesStruct = buildNestedStateStructure(controlStates);\r\n  // @type {Object<state_name,boolean>}\r\n  let isInitState = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let isAutoState = {};\r\n  // @type {Object<state_name,boolean>}\r\n  const isGroupState = hashStatesStruct.isGroupState;\r\n  let hashStates = hashStatesStruct.hashStates;\r\n\r\n  // Fill in the auxiliary data structures\r\n  transitions.forEach(function (transition) {\r\n    let { from, to, action, event, guards: arr_predicate } = transition;\r\n    // CASE: ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{ predicate: void 0, to: to, action: action }];\r\n\r\n    // CASE: transition has a init event\r\n    // NOTE: there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      isInitState[from] = true;\r\n    }\r\n\r\n    let from_proto = hashStates[from];\r\n\r\n    // CASE: automatic transitions: no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      isAutoState[from] = true;\r\n    }\r\n    // CASE: automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (isGroupState[from] && isInitState[from]) {\r\n      isAutoState[from] = true;\r\n    }\r\n\r\n    // NTH: this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce(\r\n      (acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index },\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: { event, guard, from, to, index, shouldTransitionBeTaken },\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState_, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: { extendedState, event, event_data, settings, guard, from, to, index, action },\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index, action, actionResult },\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const { updates, outputs } = actionResult;\r\n\r\n              // Leave the current state\r\n              leaveState(from, extendedState_, hashStates);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const newControlState = enterNextState(to, updates, hashStates);\r\n              console.info(\"ENTERING NEXT STATE: \", cs);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return { stop: true, outputs };\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: { eventData: event_data, settings, guard, from, to, index, action: actionName },\r\n                  machineState: { cs: current_state, es: extendedState, hs: history }\r\n                }\r\n              });\r\n              return { stop: false, outputs: null };\r\n            }\r\n          };\r\n\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return { stop: false, outputs: null };\r\n      }\r\n    );\r\n  });\r\n\r\n  // Setting up the initial state of the machine in closure\r\n  // That is the control state, history state, and extended state\r\n  // NOTE: the user-provided update function by contract cannot update in place\r\n  // There is thus no need to clone the initial extended state.\r\n  const { stateList, stateAncestors } = computeHistoryMaps(controlStates);\r\n  let history = initHistoryDataStructure(stateList);\r\n  let extendedState = initialExtendedState;\r\n  let cs = INIT_STATE;\r\n\r\n  // Run the machine's initial transition\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: { fsmDef, settings, error: e },\r\n        machineState: { cs: INIT_STATE, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    console && console.error(`An error occurred when starting the machine`, e)\r\n\r\n    return e\r\n  }\r\n\r\n  const fsmAPIs = {\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine. The function receives the input to be\r\n     *   processed by the machine, and outputs the results of the machine computation. In the general case, the machine\r\n     *   computes an array of values. The array can be empty, and when not, it may contain null values. The machine may\r\n     *   also return null (in csae of an input that the machine is not configured to react to) instead of returning an\r\n     *   array.\r\n     * @param {*} input\r\n     * @returns {FSM_Outputs|Error}\r\n     * @throws if an error is produced that is not an error recognized by Kingly. This generally means an unexpected\r\n     *   exception has occurred.\r\n     */\r\n    withProtectedState: function fsm(input) {\r\n      try {\r\n        const { eventName, eventData } = destructureEvent(input);\r\n\r\n        tracer({\r\n          type: INPUT_MSG,\r\n          trace: {\r\n            info: { eventName, eventData },\r\n            machineState: { cs: cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        const outputs = sendEvent(input, false);\r\n\r\n        debug && console.info(\"OUTPUTS:\", outputs);\r\n        tracer({\r\n          type: OUTPUTS_MSG,\r\n          trace: {\r\n            outputs,\r\n            machineState: { cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        return outputs\r\n      }\r\n      catch (e) {\r\n        if (e instanceof KinglyError) {\r\n          // We don't break the program, but we can't continue as if nothing happened: we return the error\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return e\r\n        }\r\n        else {\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An unknown error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n          console.error(`yyield > unexpected error!`, e);\r\n          // We should only catch the errors we are responsible for!\r\n          throw e\r\n        }\r\n      }\r\n    },\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine but requires to be passed both the\r\n     *   machine internal state and an input from which to compute the machine outputs. According to the parameter\r\n     *   passed as internal state, the machine may: 1. (undefined) compute outputs from the last state of the machine,\r\n     *   1. (null) compute outputs, restarting from its initial state, 3. (truthy) compute outputs from the given state\r\n     *   of the machine\r\n     * @param {*} input\r\n     * @param {FSM_Internal_State} fsmState\r\n     * @returns {{outputs: FSM_Outputs|Error, fsmState: FSM_Internal_State}}\r\n     */\r\n    withPureInterface: function compute(input, fsmState) {\r\n      if (fsmState === void 0) {\r\n        // Don't update the state of the state machine\r\n        // This means the machine will continue processing inputs\r\n        // using its current state\r\n      }\r\n      else if (fsmState === null) {\r\n        // Reinitialize the machine\r\n        extendedState = initialExtendedState;\r\n        history = initHistoryDataStructure(stateList);\r\n        hashStates[INIT_STATE].current_state_name = INIT_STATE;\r\n        start();\r\n      }\r\n      else {\r\n        // Reset the state (available in closure) of the state machine\r\n        const { cs: _cs, hs, es } = fsmState;\r\n        extendedState = es;\r\n        history = hs;\r\n        cs = _cs;\r\n      }\r\n\r\n      // run the machine\r\n      const outputs = fsmAPIs.withProtectedState(input);\r\n      // NOTE: history does not need to be cloned here! We do not update the\r\n      // history in place => No risk of accidentally modifying the history\r\n      // of another machine\r\n      // TODO: We should however definitely clone `extendedState` How to modify the API?\r\n      // Require a clone function in settings? with a default of JSON.stringify?\r\n      // or we shift the responsibility on the API user to do the cloning?\r\n      // Good: faster in the default case, simpler library too, no cloning when not needed\r\n      // Bad: library user can forget, so footgun...\r\n      // ADR: API that forces to signal a clone function, which can be DEFAULT_CLONE\r\n      return { outputs, fsmState: { cs, hs: history, es: extendedState } }\r\n    }\r\n  };\r\n\r\n  return fsmAPIs\r\n\r\n  // Auxiliary functions\r\n  //\r\n\r\n  /**\r\n   *\r\n   * @param {function(...*): True | Error} contract\r\n   * @param {Array<*>} arrayParams\r\n   * @returns {undefined}\r\n   * @throws KinglyError in case of one or more failing contracts\r\n   */\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  /**\r\n   * @description process an input (aka event) according to the machine specifications.\r\n   * @param {LabelledEvent} event_struct input to be processed by the machine\r\n   * @param {Boolean} isInternalEvent should be true iff the event is sent by Kingly, not by the\r\n   * API user. API user should always leave this undefined.\r\n   * This works around an edge case discovered through testing.\r\n   * With the fix implemented here, API users that send an INIT_EVENT will have it ignored.\r\n   * INIT_EVENT is reserved and API users should not use it. This fix is for robustness purposes.\r\n   * @returns {FSM_Outputs|null}\r\n   */\r\n  function sendEvent(event_struct, isInternalEvent) {\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const { eventName, eventData } = destructureEvent(event_struct);\r\n\r\n    console.group(\"send event \" + eventName || \"\");\r\n    console.log(event_struct);\r\n\r\n    // Edge case to deal with: INIT_EVENT sent and the current state is the initial state\r\n    // This is a side-effect of our implementation that leverages JS prototypes.\r\n    // The INIT_STATE is a super-state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation.\r\n    // This led to a bug where an API user would maliciously send the reserved INIT_EVENT,\r\n    // thus resetting the machine in its initial state, with an unpredictable extended state!\r\n    // That, in turn, results from a **design mistake** that I will not correct here, which consisted\r\n    // in letting API users configure an initial control state, OR initial INIT_EVENT transitions.\r\n    // ADR: the impact is small, the fix is ok. API users have more flexibility at the\r\n    // cost of implementation complexity. But next time, pick simplicity over flexibility.\r\n    if (!isInternalEvent && eventName === INIT_EVENT && cs !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { eventName, eventData },\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n      console.groupEnd();\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = processEvent(\r\n      hashStatesStruct.hashStates,\r\n      eventName,\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    console.groupEnd();\r\n\r\n    return outputs\r\n  }\r\n\r\n  function processEvent(hashStates, event, eventData, extendedState) {\r\n    const oldCurrentState = cs;\r\n    const eventHandler = hashStates[oldCurrentState][event];\r\n\r\n    // CASE : There is a transition associated to that event\r\n    if (eventHandler) {\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, eventData);\r\n\r\n      // The transition is evaluated:\r\n      // - no guards are satisfied => outputs = null\r\n      // - guards satisfied => outputs an array, possibly containing a null value\r\n      /** OUT: this event handler modifies the in-closure machine state (extendedState, cs, history state) */\r\n      const { stop, outputs: rawOutputs } = eventHandler(extendedState, eventData, oldCurrentState);\r\n      const newControlState = cs;\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the new control state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1:init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case, eventData will be passed on every INIT_EVENT\r\n      // 2. eventless transitions\r\n      // NOTE : the inside guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen: all AUTO transitions should advance!\r\n      if (isAutoState[newControlState]) {\r\n        if (newControlState !== oldCurrentState) {\r\n          const auto_event = isInitState[newControlState]\r\n            ? INIT_EVENT\r\n            : AUTO_EVENT;\r\n\r\n          tracer({\r\n            type: INTERNAL_INPUT_MSG,\r\n            trace: {\r\n              info: { eventName: auto_event, eventData: eventData },\r\n              event: { [auto_event]: eventData },\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          const nextOutputs = sendEvent({ [auto_event]: eventData }, true);\r\n\r\n          tracer({\r\n            type: INTERNAL_OUTPUTS_MSG,\r\n            trace: {\r\n              outputs: nextOutputs,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return [].concat(outputs).concat(nextOutputs);\r\n        }\r\n        else {\r\n          // We found an eventless transition that returns to the same control state!\r\n          // This is forbidden as this may generate infinite loops on that stationary control state\r\n          // We throw in that case, as this is a breach of contract, one which we should\r\n          // detect at configuration time.\r\n          console.error(`Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`);\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              info: { received: { [event]: eventData } },\r\n              message: `Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`,\r\n              machineState: { cs: cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n        }\r\n      }\r\n      else return outputs;\r\n    }\r\n    // CASE : There is no transition associated to that event from that state\r\n    else {\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${cs}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { received: { [event]: eventData } },\r\n          message: `There is no transition associated to the event |${event}| in state |${cs}|!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leaveState(from, extendedState, hash_states) {\r\n    history = updateHistory(history, stateAncestors, hash_states[from].name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enterNextState(to, updatedExtendedState, hash_states) {\r\n    let targetStateName;\r\n\r\n    // CASE: history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const historyType = to[DEEP] ? DEEP : to[SHALLOW] ? SHALLOW : void 0;\r\n      const historyTarget = to[historyType];\r\n\r\n      // Contract: history state MUST be associated to compound state (else there is no history to be had)\r\n      if (!isInitState[historyTarget]) {\r\n        const message = `Configured a history state unrelated to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`;\r\n        debug && console && console.error(message);\r\n        throwKinglyError({ message })\r\n      }\r\n\r\n      // Edge case: If there is no history for the compound state, then we evaluate the\r\n      // initial transition for that compound state, i.e. we set that state as target state\r\n      targetStateName = history[historyType][historyTarget] || historyTarget;\r\n    }\r\n    // CASE: not a history state\r\n    else if (to) {\r\n      targetStateName = hash_states[to].name;\r\n    }\r\n    // Dead branch: should never happen\r\n    else {\r\n      throwKinglyError({ message: \"enter_state : unknown case! Not a state name, and not a history state to enter!\" });\r\n    }\r\n    cs = targetStateName;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", targetStateName);\r\n    return targetStateName;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: { eventName: INIT_EVENT, eventData: initialExtendedState },\r\n        event: { [INIT_EVENT]: initialExtendedState },\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n\r\n    return sendEvent({ [INIT_EVENT]: initialExtendedState }, true);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @typedef {Object} WebComponentFactoryParams\r\n * @property {String} name Name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @property {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @property {Stateful_FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @property {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @property {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an\r\n *   effect moniker to a function performing the corresponding effect.\r\n * @property {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\n/**\r\n * @param {WebComponentFactoryParams} webComponentFactoryParams\r\n */\r\nexport function makeWebComponentFromFsm({ name, eventHandler, fsm, commandHandlers, effectHandlers, options }) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions instanceof Error) {\r\n            // NOTE: we do not throw here, the web component will fail but\r\n            // the rest of the page may go on. We log and swallow the errors\r\n            console && console.log(actions)\r\n          }\r\n          else if (actions === NO_ACTION) return;\r\n          else {\r\n            actions.forEach(action => {\r\n              if (action === NO_ACTION) return;\r\n              const { command, params } = action;\r\n              commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n            })\r\n          }\r\n          ;\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      // There are no attributes\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // There are no attributes\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n","// TODO : export only the two/three functions part of the API! might require updating tests imports\r\n// - move the converter to yed2kingly or a new single script with options (convert to knogly, to uml, etc.)\r\n// export * from './types'\r\nexport {createStateMachine, createPureStateMachine, makeWebComponentFromFsm, historyState} from './synchronous_fsm'\r\nexport * from './converter'\r\nexport {ACTION_IDENTITY, INIT_EVENT, INIT_STATE, SHALLOW, DEEP, NO_STATE_UPDATE, NO_OUTPUT} from './properties'\r\nexport {computeHistoryMaps, initHistoryDataStructure} from './helpers'\r\nexport {fsmContracts} from './contracts'\r\n\r\n"],"names":["SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","noop","emptyConsole","log","warn","info","debug","error","trace","group","groupEnd","emptyTracer","isFunction","x","isControlState","isHistoryControlState","isEvent","isActionFactory","get_fn_name","fn","tokens","exec","toString","wrap","str","join","times","n","Array","apply","length","map","Number","call","keys","obj","Object","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","is_history_control_state_of","state","substring","format_transition_label","_event","predicate","action","name","format_history_transition_state_name","get_all_transitions","guards","getDisplayName","replace","getStatesType","statesTree","getLabel","objectTreeLenses","isLeafLabel","traverse","strategy","PRE_ORDER","seed","visit","acc","traversalState","tree","treeLabel","traverseObj","getStatesPath","pathStr","get","path","getStatesTransitionsMap","transitions","reduce","getStateEventTransitionsMaps","concat","getEventTransitionsMaps","getHistoryStatesMap","reduceTransitions","flatTransition","guardIndex","transitionIndex","gen","underlyingControlState","getHistoryUnderlyingState","set","Map","getTargetStatesMap","getAncestorMap","getChildren","children","childrenControlStates","forEach","computeHistoryMaps","control_states","stateList","stateAncestors","JSON","stringify","parentPath","slice","parentControlState","_","ancestors","reduceFn","result","transitionStruct","undefined","guard","arrayizeOutput","output","isArray","getHistoryType","history","initHistoryDataStructure","initHistory","updateHistory","_history","state_from_name","assign","oldAncestor","newAncestor","findInitTransition","find","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","isActions","isEventStruct","trueOrError","Error","cause","destructureEvent","eventName","eventData","wrapUpdateStateFn","userProvidedUpdateStateFn","throwKinglyError","tracer","extendedState","fnName","e","location","stack","throwKinglyErrorFactory","console","KinglyError","m","errors","fm","infoMsg","fullMsg","noDuplicatedStates","shouldThrow","fsmDef","settings","duplicatedStates","statesHashMap","states","isFulfilled","blame","noReservedStates","statesType","indexOf","reservedStates","atLeastOneState","isInitialControlStateDeclared","initTransition","initialControlState","declaredStates","eventsAreStrings","events","every","validInitialConfig","validInitialTransition","initTransitions","push","isInconditionalTransition","areCconditionalTransitions","initEventOnlyInCompoundStates","statesTransitionsMap","statesPath","atomicStates","filter","atomicInitTransitions","atomicState","values","hasInitEventOnlyInCompoundStates","validInitialTransitionForCompoundState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","Boolean","hasEntryTransitions","allHaveValidInitTransitions","targetStates","targetState","entryTransitions","allHaveTargetStatesWithinHierarchy","validEventLessTransitions","failingOriginControlStates","allStateTransitionsOnOneSingleRow","stateEventTransitionsMaps","originStateList","statesTransitionsInfo","wrongEventConfig","noConflictingTransitionsWithAncestorState","eventTransitionsMaps","ancestorMap","eventList","ev","eventTransitionsInfo","wrongStateConfig","ancestorState","isHistoryStatesTargetStates","wrongHistoryStates","isHistoryStatesCompoundStates","originState","isHistoryStatesExisting","historyStatesMap","invalidTransitions","entries","historyState","flatTransitions","howMany","isValidGuard","isValidFsmDef","initialExtendedState","isValidTransitions","isValidStates","isValidEvents","haveTransitionsValidTypes","wrongTransitions","index","areEventsDeclared","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","areStatesDeclared","targetStatesMap","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","isValidSettings","isInitialStateOriginState","isValidSelfTransition","wrongSelfTransitions","fsmContracts","injected","description","contracts","makeContractHandler","contractsDef","contractsDescription","checkContracts","args","failingContracts","computedArgs","fullArgs","blameMessageHeader","contractsEval","fsmContractChecker","runContracts","type","machineState","cs","es","hs","alwaysTrue","buildNestedStateStructure","root_name","hashStates","isGroupState","nok","build_state_reducer","curr_constructor","state_name","state_config","parent_name","curr_constructor_new","displayName","prototype","State","current_state_name","normalizeTransitions","createStateMachine","res","createStateMachineAPIs","withProtectedState","createPureStateMachine","withPureInterface","controlStates","updateState","devTool","wrappedUpdateState","hashStatesStruct","isInitState","isAutoState","arr_predicate","from_proto","actionName","condition_checking_fn","condition_suffix","extendedState_","event_data","current_state","predicateName","shouldTransitionBeTaken","actionResult","leaveState","newControlState","enterNextState","stop","arr_predicate_reduce_fn","condition_checked","dummy","start","fsmAPIs","fsm","input","sendEvent","compute","fsmState","_cs","assertContract","hasFailed","event_struct","isInternalEvent","processEvent","oldCurrentState","eventHandler","rawOutputs","auto_event","nextOutputs","received","hash_states","updatedExtendedState","targetStateName","historyType","historyTarget","deep","shallow","makeWebComponentFromFsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","params","initialEvent","terminalEvent","complete","oldValue","newValue","HTMLElement","customElements","define","generateStatePlantUmlHeader","optDisplayName","toPlantUml","constructTree","getChildrenNumber","pathMap","childrenTranslation","translation","stateToPlantUML","translationMap","postOrderTraverseTree","mappedTree","clear","format_history_states","format_entry_transitions","translate_transitions","historyStatesObj","accTranslation","allTransitions","historyStates","historyTransitionTranslation","format_history_transitions","standardTransitionTranslation","format_standard_transitions","toDagreVisualizerFormat","arrayTreeLenses","_translatedStates","translatedStates","translatedTransitions","translatedGuards"],"mappings":"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"}