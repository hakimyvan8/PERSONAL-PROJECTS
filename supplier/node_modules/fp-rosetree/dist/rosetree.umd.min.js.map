{"version":3,"file":"rosetree.umd.min.js","sources":["../index.js"],"sourcesContent":["const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nexport const objectTreeLenses = {\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return path === PATH_ROOT\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isLeafLabel(label) { return objectTreeLenses.getChildren({ [label.key]: label.value }).length === 0}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n"],"names":["PATH_ROOT","POST_ORDER","PRE_ORDER","BFS","SEP","clone","a","undefined","JSON","parse","stringify","merge","objA","objB","Object","assign","times","fn","n","Array","apply","length","map","Number","call","path","join","updatePathInTraversalState","traversalState","subTree","subTreeChildren","forEach","subTreeChild","index","traversalStateParent","get","traversalStateChild","currentChildPath","set","isAdded","isVisited","concat","updateVisitInTraversalState","tree","visitTree","traversalSpecs","store","lenses","traverse","empty","emptyOrEmptyConstructor","add","takeAndRemoveOne","isEmpty","getChildren","visit","seed","seedOrSeedConstructor","Map","currentStore","visitAcc","clear","breadthFirstTraverseTree","shift","subTrees","push","preorderTraverseTree","unshift","postOrderTraverseTree","predicate","isLeaf","result","mapOverTree","mapFn","constructTree","getLabel","pathMap","mappedLabel","mappedChildren","getChildrenNumber","mappedTree","getHashedTreeLenses","sep","makeChildCursor","parentCursor","childIndex","cursor","hash","label","children","value","reduce","acc","child","[object Object]","objectTreeLenses","isArray","keys","values","prop","labelKey","arrayTreeLenses","strategy","strategies","action","treeTraveerse","accumulator","x","obj","key","mapKeyfn","leafValue","mapValuefn","rootKeyMap","constructor","isEmptyObject","root","treeObj","originLenses","targetLenses"],"mappings":"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"}