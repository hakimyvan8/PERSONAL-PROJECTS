{"version":3,"file":"kingly.umd.min.js","sources":["../src/properties.js","../node_modules/fp-rosetree/index.js","../src/helpers.js","../src/contracts.js","../src/synchronous_fsm.js","../src/converter.js"],"sourcesContent":["export const CONTRACT_MODEL_UPDATE_FN_RETURN_VALUE =\r\n  `Model update function must return valid update operations!`;\r\nexport const SEP = '.';\r\nexport const TRANSITION_SYMBOL = `-->`;\r\nexport const TRANSITION_LABEL_START_SYMBOL = `:`;\r\nexport const HISTORY_STATE_NAME = \"H\";\r\nexport const HISTORY_PREFIX = 'history.'\r\n// CONSTANTS\r\nexport const INIT_STATE = 'nok';\r\nexport const INIT_EVENT = 'init';\r\nexport const AUTO_EVENT = 'auto';\r\nexport const STATE_PROTOTYPE_NAME = 'State'; // !!must be the function name for the constructor State,\r\n// i.e. State\r\nexport const NO_STATE_UPDATE = [];\r\n// NOTE : this really cannot be anything else than a falsy value, beware\r\nexport const NO_OUTPUT = [];\r\nexport const ACTION_IDENTITY = function ACTION_IDENTITY(){\r\n  return {\r\n    outputs : NO_OUTPUT,\r\n    updates : NO_STATE_UPDATE\r\n  }\r\n}\r\nexport const history_symbol = {};\r\nexport const SHALLOW = 'shallow';\r\nexport const DEEP = 'deep';\r\n\r\nexport const WRONG_EVENT_FORMAT_ERROR = `The machine received an event which does not have the proper format. Expecting an object whose unique key is the event name, and value is the event data.`\r\nexport const FUNCTION_THREW_ERROR = (fnName, type) => `Exception thrown when executing ${type} ${fnName||\"\"}`\r\nexport const INVALID_ACTION_FACTORY_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not an action.`\r\nexport const INVALID_PREDICATE_EXECUTED = (actionName, type) => `${FUNCTION_THREW_ERROR(actionName, type)}\\nThe ${type} returned a value which is not a boolean.`\r\nexport const ACTION_FACTORY_DESC = `action factory`\r\nexport const ENTRY_ACTION_FACTORY_DESC = `(decorating) entry action`\r\nexport const UPDATE_STATE_FN_DESC = `update state function`\r\nexport const PREDICATE_DESC = `predicate`\r\n\r\nexport const COMMAND_RENDER = 'render'\r\n\r\nexport const CONTRACTS_EVAL = \"CONTRACTS_EVAL\";\r\n\r\nexport const OUTPUTS_MSG = \"OUTPUTS_MSG\";\r\nexport const INPUT_MSG = \"INPUT_MSG\";\r\nexport const WARN_MSG = 'WARN_MSG';\r\nexport const MACHINE_CREATION_ERROR_MSG = 'MACHINE_CREATION_ERROR_MSG';\r\nexport const ERROR_MSG = 'ERROR_MSG';\r\nexport const INTERNAL_INPUT_MSG = 'INTERNAL_INPUT_MSG';\r\nexport const INTERNAL_OUTPUTS_MSG = 'INTERNAL_OUTPUTS_MSG';\r\nexport const DEBUG_MSG = 'DEBUG_MSG';\r\nexport const INIT_INPUT_MSG = 'INIT_INPUT_MSG';\r\n","const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n","// Ramda fns\r\nimport {\r\n  ACTION_FACTORY_DESC, DEEP, ENTRY_ACTION_FACTORY_DESC, FUNCTION_THREW_ERROR, HISTORY_PREFIX, HISTORY_STATE_NAME,\r\n  INIT_EVENT, INIT_STATE, INVALID_ACTION_FACTORY_EXECUTED, INVALID_PREDICATE_EXECUTED, MACHINE_CREATION_ERROR_MSG,\r\n  NO_OUTPUT,\r\n  PREDICATE_DESC,\r\n  SHALLOW, WRONG_EVENT_FORMAT_ERROR\r\n} from \"./properties\"\r\nimport {objectTreeLenses, PRE_ORDER, traverseObj} from \"fp-rosetree\"\r\n\r\nexport const noop = () => {\r\n};\r\nexport const emptyConsole = {log: noop, warn: noop, info: noop, debug: noop, error: noop, trace: noop, group:noop, groupEnd: noop};\r\nexport const emptyTracer = noop;\r\n\r\nexport function isBoolean(x) {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\nexport function isFunction(x) {\r\n  return typeof x === 'function'\r\n}\r\n\r\nexport function isControlState(x) {\r\n  return x && typeof x === 'string' || isHistoryControlState(x)\r\n}\r\n\r\nexport function isEvent(x) {\r\n  return typeof x === 'undefined' || typeof x === 'string'\r\n}\r\n\r\nexport function isActionFactory(x) {\r\n  return x && typeof x === 'function'\r\n}\r\n\r\nexport function make_states(stateList) {\r\n  return stateList.reduce((acc, state) => {\r\n    acc[state] = \"\";\r\n    return acc\r\n  }, {})\r\n}\r\n\r\nexport function make_events(eventList) {\r\n  return eventList\r\n}\r\n\r\n/**\r\n * Returns the name of the function as taken from its source definition.\r\n * For instance, function do_something(){} -> \"do_something\"\r\n * @param fn {Function}\r\n * @returns {String}\r\n */\r\nexport function get_fn_name(fn) {\r\n  const tokens =\r\n    /^[\\s\\r\\n]*function[\\s\\r\\n]*([^\\(\\s\\r\\n]*?)[\\s\\r\\n]*\\([^\\)\\s\\r\\n]*\\)[\\s\\r\\n]*\\{((?:[^}]*\\}?)+)\\}\\s*$/\r\n      .exec(fn.toString());\r\n  return tokens[1];\r\n}\r\n\r\nexport function wrap(str) {\r\n  return ['-', str, '-'].join(\"\");\r\n}\r\n\r\nexport function times(fn, n) {\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\nexport function always(x) {\r\n  return x\r\n}\r\n\r\nexport function keys(obj) {\r\n  return Object.keys(obj)\r\n}\r\n\r\nexport function merge(a, b) {\r\n  return Object.assign({}, a, b)\r\n}\r\n\r\n// Contracts\r\n\r\nexport function is_history_transition(transition) {\r\n  return transition.to.startsWith(HISTORY_PREFIX)\r\n}\r\n\r\nexport function is_entry_transition(transition) {\r\n  return transition.event === INIT_EVENT\r\n}\r\n\r\nexport function is_from_control_state(controlState) {\r\n  return function (transition) {\r\n    return transition.from === controlState\r\n  }\r\n}\r\n\r\nexport function is_to_history_control_state_of(controlState) {\r\n  return function (transition) {\r\n    return is_history_control_state_of(controlState, transition.to)\r\n  }\r\n}\r\n\r\nexport function is_history_control_state_of(controlState, state) {\r\n  return state.substring(HISTORY_PREFIX.length) === controlState\r\n}\r\n\r\nexport function format_transition_label(_event, predicate, action) {\r\n  const event = _event || '';\r\n  return predicate && action\r\n    ? `${event} [${predicate.name}] / ${action.name}`\r\n    : predicate\r\n      ? `${event} [${predicate.name}]}`\r\n      : action\r\n        ? `${event} / ${action.name}`\r\n        : `${event}`\r\n}\r\n\r\nexport function format_history_transition_state_name({from, to}) {\r\n  return `${from}.${to.substring(HISTORY_PREFIX.length)}.${HISTORY_STATE_NAME}`\r\n}\r\n\r\nexport function get_all_transitions(transition) {\r\n  const {from, event, guards} = transition;\r\n\r\n  return guards\r\n    ? guards.map(({predicate, to, action}) => ({from, event, predicate, to, action}))\r\n    : [transition];\r\n}\r\n\r\n/**\r\n * 'this_name' => 'this name'\r\n * @param {String} str\r\n * @returns {String}\r\n */\r\nexport function getDisplayName(str) {\r\n  return str.replace(/_/g, ' ')\r\n}\r\n\r\n/**\r\n * This function MERGES extended state updates. That means that given two state updates, the resulting state update\r\n * will be the concatenation of the two, in the order in which they are passed\r\n * @param {function[]}  arrayUpdateActions\r\n * @returns {function(*=, *=, *=): {updates: *}}\r\n */\r\nexport function mergeModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    return {\r\n      updates: arrayUpdateActions.reduce((acc, updateAction) => {\r\n        const update = updateAction(extendedState, eventData, settings).updates;\r\n        if (update) {\r\n          return acc.concat(update)\r\n        }\r\n        else {\r\n          return acc\r\n        }\r\n      }, []),\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * This function CHAINS extended state updates, in the order in which they are passed. It is thus similar to a pipe.\r\n * The second update function receives the state updated by the first update function.\r\n * @param {function[]}  arrayUpdateActions\r\n */\r\nexport function chainModelUpdates(arrayUpdateActions) {\r\n  return function (extendedState, eventData, settings) {\r\n    const {updateState} = settings;\r\n    return {\r\n      updates: arrayUpdateActions\r\n        .reduce((acc, updateAction) => {\r\n          const {extendedState, updates} = acc;\r\n          const update = updateAction(extendedState, eventData, settings).updates;\r\n          const updatedState = updateState(extendedState, updates)\r\n\r\n          return {extendedState: updatedState, updates: update}\r\n        }, {extendedState, updates: []})\r\n        .updates || [],\r\n      outputs: NO_OUTPUT\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {function (Array<Array<MachineOutput>>) : Array<MachineOutput>} mergeOutputFn\r\n * @param {Array<ActionFactory>} arrayActionFactory\r\n * @returns {function(*=, *=, *=): {updates: *[], outputs: *|null}}\r\n */\r\nexport function mergeActionFactories(mergeOutputFn, arrayActionFactory) {\r\n  return function (extendedState, eventData, settings) {\r\n    const arrayActions = arrayActionFactory.map(factory => factory(extendedState, eventData, settings));\r\n    const arrayStateUpdates = arrayActions.map(x => x.updates || []);\r\n    const arrayOutputs = arrayActions.map(x => x.outputs || {});\r\n\r\n    return {\r\n      updates: [].concat(...arrayStateUpdates),\r\n      // for instance, mergeFn = R.mergeAll or some variations around R.mergeDeepLeft\r\n      outputs: mergeOutputFn(arrayOutputs)\r\n    }\r\n  }\r\n}\r\n\r\n/** @type ActionFactory*/\r\nexport function identity(extendedState, eventData, settings) {\r\n  return {\r\n    updates: [],\r\n    outputs: NO_OUTPUT\r\n  }\r\n}\r\n\r\nexport function lastOf(arr) {\r\n  return arr[arr.length - 1];\r\n}\r\n\r\nfunction formatActionName(action, from, event, to, predicate) {\r\n  const predicateName = predicate ? predicate.name : \"\";\r\n  const formattedPredicate = predicateName ? `[${predicateName}]` : \"\";\r\n  const actionName = action ? action.name : \"identity\";\r\n  const formattedAction = actionName ? actionName : \"unnamed action\";\r\n  return `${formattedAction}:${from}-${event}->${to} ${formattedPredicate}`;\r\n}\r\n\r\nexport function getFsmStateList(states) {\r\n  const {getLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (accStateList, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      accStateList[controlState] = \"\";\r\n\r\n      return accStateList;\r\n    }\r\n  };\r\n  const stateHashMap = traverseObj(traverse, states);\r\n\r\n  return stateHashMap\r\n}\r\n\r\nexport function getStatesType(statesTree) {\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      // true iff control state is a compound state\r\n      return isLeafLabel(treeLabel)\r\n        ? (acc[controlState] = false, acc)\r\n        : (acc[controlState] = true, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesPath(statesTree) {\r\n  const {getLabel} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const pathStr = traversalState.get(tree).path.join('.');\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n\r\n      return (acc[controlState] = pathStr, acc)\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function getStatesTransitionsMap(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = transition;\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getStateEventTransitionsMaps(transitions) {\r\n  // Map a control state to the transitions which it as origin\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[from] = acc[from] || {};\r\n      acc[from][event] = acc[from][event] ? acc[from][event].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getEventTransitionsMaps(transitions) {\r\n  // Map an event to the origin control states of the transitions it triggers\r\n  return transitions.reduce((acc, transition) => {\r\n      const {from, event} = transition;\r\n      // NOTE: that should never be, but we need to be defensive here to keep semantics\r\n      if (isHistoryControlState(from)) return acc\r\n\r\n      acc[event] = acc[event] || {};\r\n      acc[event][from] = acc[event][from] ? acc[event][from].concat(transition) : [transition];\r\n      return acc\r\n    }, {})\r\n    || {}\r\n}\r\n\r\nexport function getHistoryStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {from, event, to, action, predicate, gen} = flatTransition;\r\n      if (isHistoryControlState(from)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(from);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n      else if (isHistoryControlState(to)) {\r\n        const underlyingControlState = getHistoryUnderlyingState(to);\r\n        map.set(underlyingControlState, (map.get(underlyingControlState) || []).concat([flatTransition]));\r\n      }\r\n\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getTargetStatesMap(transitions) {\r\n  return reduceTransitions((map, flatTransition, guardIndex, transitionIndex) => {\r\n      const {to} = flatTransition;\r\n      map.set(to, (map.get(to) || []).concat([flatTransition]));\r\n      return map\r\n    }, new Map(), transitions)\r\n    || {};\r\n}\r\n\r\nexport function getAncestorMap(statesTree) {\r\n  const {getLabel, getChildren} = objectTreeLenses;\r\n\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = getChildren(tree)\r\n      const childrenControlStates = children.map(tree => Object.keys(getLabel(tree))[0]);\r\n\r\n      childrenControlStates.forEach(state => {\r\n        acc[state] = acc[state] || [];\r\n        acc[state] = acc[state].concat(controlState);\r\n      });\r\n\r\n      return acc\r\n    }\r\n  };\r\n\r\n  return traverseObj(traverse, statesTree);\r\n}\r\n\r\nexport function computeHistoryMaps(control_states) {\r\n  if (Object.keys(control_states).length === 0) {\r\n    throw `computeHistoryMaps : passed empty control states parameter?`\r\n  }\r\n\r\n  const {getLabel, isLeafLabel} = objectTreeLenses;\r\n  const traverse = {\r\n    strategy: PRE_ORDER,\r\n    seed: {stateList: [], stateAncestors: {}},\r\n    visit: (acc, traversalState, tree) => {\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      acc.stateList = acc.stateList.concat(controlState);\r\n\r\n      // NOTE : we don't have to worry about path having only one element\r\n      // that case correspond to the root of the tree which is excluded from visiting\r\n      const {path} = traversalState.get(tree);\r\n      traversalState.set(JSON.stringify(path), controlState);\r\n      const parentPath = path.slice(0, -1);\r\n      if (parentPath.length === 1) {\r\n        // That's the root\r\n        traversalState.set(JSON.stringify(parentPath), INIT_STATE);\r\n      }\r\n      else {\r\n        const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n        acc.stateAncestors[controlState] = [parentControlState];\r\n\r\n        const {ancestors} = path.reduce((acc, _) => {\r\n          const parentPath = acc.path.slice(0, -1);\r\n          acc.path = parentPath;\r\n          if (parentPath.length > 1) {\r\n            const parentControlState = traversalState.get(JSON.stringify(parentPath));\r\n            acc.ancestors = acc.ancestors.concat(parentControlState);\r\n          }\r\n\r\n          return acc\r\n        }, {ancestors: [], path});\r\n        acc.stateAncestors[controlState] = ancestors;\r\n      }\r\n\r\n      return acc\r\n    }\r\n  };\r\n  const {stateList, stateAncestors} = traverseObj(traverse, control_states);\r\n\r\n  return {stateList, stateAncestors}\r\n}\r\n\r\nexport function mapOverTransitionsActions(mapFn, transitions) {\r\n  return reduceTransitions(function (acc, transition, guardIndex, transitionIndex) {\r\n    const {from, event, to, action, predicate} = transition;\r\n    const mappedAction = mapFn(action, transition, guardIndex, transitionIndex);\r\n    mappedAction.displayName = mappedAction.displayName || (action && (action.name || action.displayName || formatActionName(action, from, event, to, predicate)));\r\n\r\n    if (typeof(predicate) === 'undefined') {\r\n      acc.push({from, event, to, action: mappedAction})\r\n    }\r\n    else {\r\n      if (guardIndex === 0) {\r\n        acc.push({from, event, guards: [{to, predicate, action: mappedAction}]})\r\n      }\r\n      else {\r\n        acc[acc.length - 1].guards.push({to, predicate, action: mappedAction})\r\n      }\r\n    }\r\n\r\n    return acc\r\n  }, [], transitions)\r\n}\r\n\r\nexport function reduceTransitions(reduceFn, seed, transitions) {\r\n  const result = transitions.reduce((acc, transitionStruct, transitionIndex) => {\r\n    let {from, event, to, gen, action, guards} = transitionStruct;\r\n    // Edge case when no guards are defined\r\n    if (!guards) {\r\n      guards = gen ? [{to, action, gen, predicate: undefined}] : [{to, action, predicate: undefined}]\r\n    }\r\n    return guards.reduce((acc, guard, guardIndex) => {\r\n      const {to, action, gen, predicate} = guard;\r\n      return gen\r\n        ? reduceFn(acc, {from, event, to, action, predicate, gen}, guardIndex, transitionIndex)\r\n        : reduceFn(acc, {from, event, to, action, predicate}, guardIndex, transitionIndex)\r\n    }, acc);\r\n  }, seed);\r\n\r\n  return result\r\n}\r\n\r\nexport function everyTransition(pred, transition) {\r\n  return reduceTransitions((acc, flatTransition) => {\r\n    return acc && pred(flatTransition)\r\n  }, true, [transition])\r\n}\r\n\r\nexport function computeTimesCircledOn(edgePath, edge) {\r\n  return edgePath.reduce((acc, edgeInEdgePath) => edgeInEdgePath === edge ? acc + 1 : acc, 0);\r\n}\r\n\r\nexport function isInitState(s) {\r\n  return s === INIT_STATE\r\n}\r\n\r\nexport function isInitEvent(e) {\r\n  return e === INIT_EVENT\r\n}\r\n\r\nexport function isEventless(e) {\r\n  return typeof e === 'undefined'\r\n}\r\n\r\n/**\r\n * @description takes an output and turns it into an array\r\n * @param {*} output\r\n * @returns {*[]|null} if the output is null: null, if output is an array: output, else: [output]\r\n */\r\nexport function arrayizeOutput(output) {\r\n  return output === NO_OUTPUT\r\n    ? NO_OUTPUT\r\n    : Array.isArray(output)\r\n      ? output\r\n      : [output]\r\n}\r\n\r\nexport function isHistoryControlState(to) {\r\n  return typeof to === 'object' && (DEEP in to || SHALLOW in to)\r\n}\r\n\r\nexport function getHistoryParentState(to) {\r\n  return to[SHALLOW] || to[DEEP]\r\n}\r\n\r\nexport function isShallowHistory(to) {\r\n  return to[SHALLOW]\r\n}\r\n\r\nexport function isDeepHistory(to) {\r\n  return to[DEEP]\r\n}\r\n\r\nexport function getHistoryType(history) {\r\n  return history[DEEP] ? DEEP : SHALLOW\r\n}\r\n\r\nexport function getHistoryUnderlyingState(history) {\r\n  return history[getHistoryType(history)]\r\n}\r\n\r\nexport function isHistoryStateEdge(edge) {\r\n  return typeof edge.history !== 'undefined'\r\n}\r\n\r\n/**\r\n * Creates a history object from a state list. The created history object represents the history states when no\r\n * control states have been entered or exited.\r\n * @param stateList\r\n * @returns {History}\r\n */\r\nexport function initHistoryDataStructure(stateList) {\r\n  // NOTE : we update history in place, so we need two different objects here, even\r\n  // when they start with the same value\r\n  const initHistory = () => stateList.reduce((acc, state) => (acc[state] = '', acc), {});\r\n  return {[DEEP]: initHistory(), [SHALLOW]: initHistory()};\r\n}\r\n\r\nexport function isCompoundState(analyzedStates, controlState) {\r\n  const {statesAdjacencyList} = analyzedStates;\r\n  return statesAdjacencyList[controlState] && statesAdjacencyList[controlState].length !== 0\r\n}\r\n\r\nexport function isAtomicState(analyzedStates, controlState) {\r\n  return !isCompoundState(analyzedStates, controlState)\r\n}\r\n\r\n/**\r\n * Updates the history state (both deep and shallow) after `state_from_name` has been exited. Impacted states are the\r\n * `stateAncestors` which are the ancestors for the exited state.\r\n * @param {HistoryState} _history Contains deep history and shallow history for all\r\n * control states, except the INIT_STATE (not that the concept has no value for atomic state). The function\r\n * `updateHistory` allows to update the history as transitions occur in the state machine.\r\n * @param {Object.<DEEP|SHALLOW, Object.<ControlState, Array<ControlState>>>} stateAncestors\r\n * @returns {HistoryState}\r\n * @modifies history\r\n */\r\nexport function updateHistory(_history, stateAncestors, state_from_name) {\r\n  // 27.08.2020: Now that I expose history state I have to make sure that it is not mutated!!\r\n  // We have a fixed format here, so we use native `assign` at deepest level\r\n  const history = {\r\n    [DEEP]: Object.assign({}, _history[DEEP]),\r\n    [SHALLOW]: Object.assign({}, _history[SHALLOW]),\r\n  };\r\n\r\n  // Edge case, we start with INIT_STATE but that is not kept in the history (no transition to it!!)\r\n  if (state_from_name === INIT_STATE) {\r\n    return history\r\n  }\r\n  else {\r\n      // ancestors for the state which is exited\r\n      const ancestors = stateAncestors[state_from_name] || [];\r\n      ancestors.reduce((oldAncestor, newAncestor) => {\r\n        // set the exited state in the history of all ancestors\r\n        history[DEEP][newAncestor] = state_from_name;\r\n        history[SHALLOW][newAncestor] = oldAncestor;\r\n\r\n        return newAncestor\r\n      }, state_from_name);\r\n\r\n    return history\r\n  }\r\n}\r\n\r\n/**\r\n * for all parentState, computes history(parentState), understood as the last control state descending from the\r\n * parent state. Last can be understood two ways : DEEP and SHALLOW. Deep history state refer to the last atomic\r\n * control state which is a children of the parent state and was exited. Shallow history states refer to the last\r\n * control state which is a direct child of the parent state and was exited.\r\n * @param {FSM_States} states\r\n * @param {Array<ControlState>} controlStateSequence Sequence of control states which has been entered and exited,\r\n * and from which the history must be injected\r\n * @param {DEEP | SHALLOW} historyType\r\n * @param {ControlState} historyParentState\r\n * @returns {Object.<DEEP|SHALLOW, Object.<ControlState, ControlState>>}\r\n */\r\nexport function computeHistoryState(states, controlStateSequence, historyType, historyParentState) {\r\n  // NOTE : we compute the whole story every time. This is inefficient, but for now sufficient\r\n  const {stateList, stateAncestors} = computeHistoryMaps(states);\r\n  let history = initHistoryDataStructure(stateList);\r\n  history = controlStateSequence.reduce(\r\n    (history, controlState) => updateHistory(history, stateAncestors, controlState),\r\n    history\r\n  );\r\n\r\n  return history[historyType][historyParentState]\r\n}\r\n\r\nexport function findInitTransition(transitions) {\r\n  return transitions.find(transition => {\r\n    return transition.from === INIT_STATE && transition.event === INIT_EVENT\r\n  })\r\n}\r\n\r\nexport function tryCatch(fn, errCb) {\r\n  return function tryCatch(...args) {\r\n    try {\r\n      return fn.apply(fn, args);\r\n    }\r\n    catch (e) {\r\n      return errCb(e, args);\r\n    }\r\n  };\r\n}\r\n\r\nexport function tryCatchMachineFn(fnType, fn, argsDesc = []) {\r\n  return tryCatch(fn, (e, args) => {\r\n    const err = new Error(e);\r\n    const fnName = getFunctionName(fn);\r\n    // NOTE : we concatenate causes but not `info`\r\n    const probableCause = FUNCTION_THREW_ERROR(fnName, fnType);\r\n    err.probableCause = e.probableCause ? [e.probableCause, probableCause].join('\\n') : probableCause;\r\n\r\n    const info = {\r\n      fnName,\r\n      params: argsDesc.reduce((acc, argDesc, index) => {\r\n        return acc[argDesc] = args[index], acc\r\n      }, {})\r\n    };\r\n    err.info = e.info ? [].concat([e.info]).concat([info]) : info;\r\n\r\n    return err\r\n  })\r\n}\r\n\r\nexport function getFunctionName(actionFactory) {\r\n  return actionFactory.name || actionFactory.displayName || 'anonymous'\r\n}\r\n\r\n/**\r\n *\r\n * @param {function(...*): True | Error} contract Contract that either fulfills or returns an error\r\n * @param {Array<*>} arrayParams Parameters to be passed to the contract\r\n * @returns {undefined|{when, location, info, message}|Object} either true (fulfilled contract)\r\n * or an object with optional properties for diagnostic and tracing purposes\r\n * about the cause of the error if the contract is not fulfilled\r\n */\r\nexport function assert(contract, arrayParams) {\r\n  const contractName = contract.name || \"\";\r\n  const isFulfilledOrError = contract.apply(null, arrayParams);\r\n  if (isFulfilledOrError === true) return void 0\r\n  else {\r\n    return {\r\n      ...isFulfilledOrError,\r\n      when: `Checking contract`,\r\n      message: [isFulfilledOrError.message, `failed contract ${contractName}`].join(\"\\n\"),\r\n      info: isFulfilledOrError.info,\r\n    }\r\n  }\r\n}\r\n\r\nexport function notifyThrows(console, error) {\r\n  console.error(error);\r\n  error.probableCause && console.error(`Probable cause: ${error.probableCause}`);\r\n  error.info && console.error(`ERROR: additional info`, error.info);\r\n}\r\n\r\n/**\r\n * false iff no errors or invalid actions\r\n * if not throws an exception\r\n * @param {{debug, console}} notify\r\n * @param {*} execInfo Information about the call - should include the function, and the parameters for the function\r\n * call\r\n * @param {Actions | Error} actionResultOrError\r\n * @param {function} throwFn handles when the action factory throws during its execution\r\n * @param {function} invalidResultFn handles when the action factory returns invalid actions\r\n * @returns {boolean}\r\n * @param postCondition\r\n */\r\nexport function handleFnExecError(notify, execInfo, actionResultOrError, postCondition, throwFn, invalidResultFn) {\r\n  const {debug, console} = notify;\r\n\r\n  if (debug && actionResultOrError instanceof Error) {\r\n    throwFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else if (debug && !postCondition(actionResultOrError)) {\r\n    invalidResultFn({debug, console}, actionResultOrError, execInfo)\r\n    return true\r\n  }\r\n  else return false\r\n}\r\n\r\nexport function notifyAndRethrow({debug, console}, actionResultOrError) {\r\n  notifyThrows(console, actionResultOrError)\r\n  throw actionResultOrError\r\n}\r\n\r\nexport function throwIfInvalidActionResult({debug, console}, actionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: actionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidGuardResult({debug, console}, resultOrError, exec) {\r\n  const predName = getFunctionName(exec.predicate);\r\n  const error = new Error(INVALID_PREDICATE_EXECUTED(predName, PREDICATE_DESC));\r\n  error.info = {\r\n    predicateName: predName,\r\n    params: exec,\r\n    returned: resultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function throwIfInvalidEntryActionResult({debug, console}, exitActionResultOrError, exec) {\r\n  const {action, extendedState, eventData, settings} = exec;\r\n  const actionName = getFunctionName(action);\r\n  const error = new Error(INVALID_ACTION_FACTORY_EXECUTED(actionName, ENTRY_ACTION_FACTORY_DESC));\r\n  error.info = {\r\n    fnName: getFunctionName(action),\r\n    params: {updatedExtendedState: extendedState, eventData, settings},\r\n    returned: exitActionResultOrError\r\n  };\r\n  notifyThrows(console, error)\r\n  throw error\r\n}\r\n\r\nexport function isActions(obj) {\r\n  return obj && `updates` in obj && `outputs` in obj\r\n    && Array.isArray(obj.outputs)\r\n  // && Array.isArray(obj.updates)\r\n  // !! does not have to be arrays. HAs to be anything that is accepted by updateState\r\n}\r\n\r\n/**\r\n * That is a Either contract, not a Boolean contract!\r\n * @param obj\r\n * @returns {boolean|Error}\r\n */\r\nexport function isEventStruct(obj) {\r\n  let trueOrError;\r\n  if (!obj || typeof obj !== 'object') {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `not an object!`}\r\n  }\r\n  else if (Object.keys(obj).length > 1) {\r\n    trueOrError = new Error(WRONG_EVENT_FORMAT_ERROR);\r\n    trueOrError.info = {event: obj, cause: `Event objects must have only one key which is the event name!`}\r\n  }\r\n  else trueOrError = true;\r\n\r\n  return trueOrError\r\n}\r\n\r\nexport function isError(obj) {\r\n  return obj instanceof Error\r\n}\r\n\r\nexport function destructureEvent(obj) {\r\n  const eventName = Object.keys(obj)[0];\r\n  const eventData = obj[eventName];\r\n\r\n  return {eventName, eventData}\r\n}\r\n\r\nexport function formatUndefinedInJSON(obj){\r\n  return JSON.stringify(obj, (key,value)=> {if (value === undefined) return \"undefined\"; else return value})\r\n}\r\n\r\nexport function wrapUpdateStateFn(userProvidedUpdateStateFn, {throwKinglyError, tracer}){\r\n  return (extendedState, updates) => {\r\n    const fnName = userProvidedUpdateStateFn.name || \"\";\r\n\r\n    try {\r\n      return userProvidedUpdateStateFn(extendedState, updates)\r\n    }\r\n    catch (e) {\r\n      throwKinglyError({\r\n        when: `Executing updateState function ${fnName}`,\r\n        location: `createStateMachine > wrappedUpdateState`,\r\n        info: {extendedState, updates},\r\n        message: e.message,\r\n        stack: e.stack,\r\n      })\r\n    }\r\n  };\r\n}\r\n\r\nexport function throwKinglyErrorFactory (console,tracer)  {\r\n  return obj => {\r\n  throw new KinglyError(obj, console, tracer)\r\n  }\r\n};\r\n\r\nexport class KinglyError extends Error {\r\n  constructor(m, console, tracer) {\r\n    super(m && m.message || \"\");\r\n    this.name = `KinglyError`;\r\n    this.stack = m && m.stack || this.stack;\r\n    this.errors = m;\r\n    const { when, location, info, message } = m || {};\r\n    const fm = `At ${location}: ${when} => ${message}`;\r\n    const infoMsg = info ? `See extra info in console` : \"\";\r\n    const fullMsg = [fm, infoMsg].join(\"\\n\");\r\n    // this.message = fullMsg;\r\n    console && console.error(fullMsg);\r\n    info && console && console.info(info);\r\n  }\r\n}\r\n","import {\r\n  emptyConsole,\r\n  findInitTransition,\r\n  getAncestorMap,\r\n  getEventTransitionsMaps,\r\n  getHistoryStatesMap,\r\n  getHistoryUnderlyingState,\r\n  getStatesPath,\r\n  getStatesTransitionsMap,\r\n  getStateEventTransitionsMaps,\r\n  getStatesType,\r\n  getTargetStatesMap,\r\n  isActionFactory,\r\n  isControlState,\r\n  isEvent,\r\n  isFunction,\r\n  isHistoryControlState,\r\n  noop\r\n} from \"./helpers\"\r\n// @ts-ignore\r\nimport { objectTreeLenses, PRE_ORDER, traverseObj } from \"fp-rosetree\"\r\nimport { CONTRACTS_EVAL, INIT_EVENT, INIT_STATE, MACHINE_CREATION_ERROR_MSG } from \"./properties\"\r\n\r\n// Contracts\r\n\r\n// S2. State names must be unique\r\nexport const noDuplicatedStates = {\r\n  name: 'noDuplicatedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { getLabel } = objectTreeLenses;\r\n    const traverse = {\r\n      strategy: PRE_ORDER,\r\n      seed: { duplicatedStates: [], statesHashMap: {} },\r\n      visit: (acc, traversalState, tree) => {\r\n        const { duplicatedStates, statesHashMap } = acc;\r\n        const treeLabel = getLabel(tree);\r\n        const controlState = Object.keys(treeLabel)[0];\r\n        if (controlState in statesHashMap) {\r\n          return {\r\n            duplicatedStates: duplicatedStates.concat(controlState),\r\n            statesHashMap\r\n          }\r\n        }\r\n        else {\r\n          return {\r\n            duplicatedStates,\r\n            statesHashMap: (statesHashMap[controlState] = \"\", statesHashMap)\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const { duplicatedStates } = traverseObj(traverse, fsmDef.states);\r\n\r\n    const isFulfilled = duplicatedStates.length === 0;\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `State names must be unique! Found duplicated state names. Cf. log`,\r\n        info: { duplicatedStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S1. State name cannot be a reserved state name (for now only INIT_STATE)\r\nexport const noReservedStates = {\r\n  name: 'noReservedStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).indexOf(INIT_STATE) === -1,\r\n      blame: {\r\n        message: `You cannot use a reserved control state name for any of the configured control states for the machine! Cf. log`,\r\n        info: { reservedStates: [INIT_STATE], statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S4. At least one control state (other than the initial state) muat be declared\r\nexport const atLeastOneState = {\r\n  name: 'atLeastOneState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesType }) => {\r\n    return {\r\n      isFulfilled: Object.keys(statesType).length > 0,\r\n      blame: {\r\n        message: `Machine configuration must define at least one control state! Cf. log`,\r\n        info: { statesType }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// S5. check initial control state is a defined state in states\r\nexport const isInitialControlStateDeclared = {\r\n  name: 'isInitialControlStateDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition, statesType }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const stateList = Object.keys(statesType);\r\n    if (initialControlState) {\r\n      return {\r\n        isFulfilled: stateList.indexOf(initialControlState) > -1,\r\n        blame: {\r\n          message: `Configured initial control state must be a declared state. Cf. log`,\r\n          info: { initialControlState, declaredStates: stateList }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n\r\n  },\r\n};\r\n\r\n// E0. `fsmDef.events` msut be an array of strings\r\nexport const eventsAreStrings = {\r\n  name: 'eventsAreStrings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    return {\r\n      isFulfilled: fsmDef.events.every(x => typeof x === 'string'),\r\n      blame: {\r\n        message: `Events must be an array of strings!`,\r\n        info: { events: fsmDef.events }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const validInitialConfig = {\r\n  name: 'validInitialConfig',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState } = fsmDef;\r\n\r\n    if (initTransition && initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : defining an initial control state and an initial transition at the same time may lead to ambiguity and is forbidden!`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else if (!initTransition && !initialControlState) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Invalid machine configuration : you must define EITHER an initial control state OR an initial transition! Else in which state is the machine supposed to start?`,\r\n          info: { initialControlState, initTransition }\r\n        }\r\n      }\r\n    }\r\n    else return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n  },\r\n};\r\n\r\n// T1. There must be configured at least one transition away from the initial state\r\n// T2. A transition away from the initial state can only be triggered by the initial event\r\n// T7b. The initial state must have a valid transition INIT_STATE -INIT-> defined which does not have a history\r\n// state as target\r\n// T23. We allow conditional initial transitions, but what about the action ? should it be always identity? We\r\n// can't run any actions. We can update internal state, but we can't trace it, so we loose tracing properties and\r\n// debugging!. So enforce ACTIONS to be identity\r\nexport const validInitialTransition = {\r\n  name: 'validInitialTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { initTransition }) => {\r\n    const { initialControlState, transitions } = fsmDef;\r\n    const initTransitions = transitions.reduce((acc, transition) => {\r\n      transition.from === INIT_STATE && acc.push(transition);\r\n      return acc\r\n    }, []);\r\n    // DOC : or not, we allow conditional init transitions!! allow to set the initial state depending on settings!\r\n    // NOTE: functional object reference, and decoration (trace, entry actions )do not work well together, so we don't\r\n    // enforce the part of the contract which require to have no actions for initial transitions...\r\n    const isFulfilled =\r\n      (initialControlState && !initTransition) ||\r\n      (!initialControlState && initTransition && initTransitions.length === 1 && initTransition.event === INIT_EVENT\r\n        && (\r\n          isInconditionalTransition(initTransition) // && initTransition.action === ACTION_IDENTITY\r\n          || areCconditionalTransitions(initTransition)\r\n          // && initTransition.guards.every(guard => guard.action === ACTION_IDENTITY)\r\n        )\r\n      );\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Invalid configuration for initial transition! Cf. log`,\r\n        info: { initTransition, initTransitions, initialControlState }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T15. Init transitions can only occur from compound states or the initial state, i.e. A -INIT-> B iff A is a compound\r\n// state or A is the initial state\r\nexport const initEventOnlyInCompoundStates = {\r\n  name: 'initEventOnlyInCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const atomicStates = Object.keys(statesType).filter(controlState => !statesType[controlState]);\r\n    const atomicInitTransitions = atomicStates.map(\r\n      atomicState => ({\r\n        [atomicState]: statesTransitionsMap[atomicState] && statesTransitionsMap[atomicState][INIT_EVENT]\r\n      })\r\n    ).filter(obj => Object.values(obj)[0]);\r\n\r\n    const hasInitEventOnlyInCompoundStates = atomicInitTransitions.length === 0\r\n\r\n    return {\r\n      isFulfilled: hasInitEventOnlyInCompoundStates,\r\n      blame: {\r\n        message: `Found at least one atomic state with an entry transition! That is forbidden! Cf. log`,\r\n        info: { initTransitions: atomicInitTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T5. Every compound state NOT the initial state A must have a valid transition A -INIT-> defined\r\n// T7a. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have a history state as target\r\n// NOTE: actually we could limit it to history state of the containing compound state to avoid infinity loop\r\n// T8. Every compound state NOT the initial state must have a valid INCONDITIONAL transition A -INIT-> defined which\r\n// does not have the history state as target and has a target control state that is one of its substates (no\r\n// out-of-hierarchy INIT transitions)\r\nexport const validInitialTransitionForCompoundState = {\r\n  name: 'validInitialTransitionForCompoundState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const compoundStates = Object.keys(statesType).filter(controlState => statesType[controlState]);\r\n    const compoundStatesInitTransitions = compoundStates.map(\r\n      compoundState => statesTransitionsMap[compoundState] && statesTransitionsMap[compoundState][INIT_EVENT]);\r\n\r\n    const allHaveInitTransitions = compoundStatesInitTransitions.every(Boolean);\r\n\r\n    if (!allHaveInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state without an entry transition! Cf. log`,\r\n          info: {\r\n            hasEntryTransitions: compoundStates.map(\r\n              state => ({ [state]: !!(statesTransitionsMap[state] && statesTransitionsMap[state][INIT_EVENT]) }))\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const allHaveValidInitTransitions = allHaveInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { guards, to } = initTransition;\r\n        if (!guards) {\r\n          //  T7a\r\n          return typeof to === 'string'\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(targetState => typeof targetState === 'string')\r\n        }\r\n      });\r\n    if (!allHaveValidInitTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have the associated target control states which are not a history pseudo-state. Cf. log`,\r\n          info: { entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n    ;\r\n\r\n    const allHaveTargetStatesWithinHierarchy = allHaveValidInitTransitions &&\r\n      compoundStatesInitTransitions.every(initTransition => {\r\n        const { from, guards, to } = initTransition;\r\n\r\n        // Don't forget to also eliminate the case when from = to\r\n        // Also note that wwe check that `to` is in statesPath as one is derived from states in transitions, and the\r\n        // other from declared states\r\n        if (!guards) {\r\n          return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n        }\r\n        else {\r\n          const targetStates = guards.map(guard => guard.to);\r\n          return targetStates.every(to => {\r\n            return from !== to && statesPath[to] && statesPath[to].startsWith(statesPath[from])\r\n          })\r\n        }\r\n      });\r\n    if (!allHaveTargetStatesWithinHierarchy) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one compound state with an invalid entry transition! Entry transitions for compound states must have a target state which is strictly below the compound state in the state hierarchy! `,\r\n          info: { states: fsmDef.states, statesPath, entryTransitions: compoundStatesInitTransitions }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T11. If there is an eventless transition A -eventless-> B, there cannot be a competing A -ev-> X\r\n// T24. Check that we have this implicitly : Compound states must not have eventless transitions\r\n// defined on them (would introduce ambiguity with the INIT transition).\r\nexport const validEventLessTransitions = {\r\n  name: 'validEventLessTransitions',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { statesTransitionsMap, statesType, statesPath }) => {\r\n    // The compound states below does not include the initial state by construction\r\n    const stateList = Object.keys(statesType);\r\n    const failingOriginControlStates = stateList.map(state => {\r\n      return {\r\n        [state]: statesTransitionsMap[state] &&\r\n        `${void 0}` in statesTransitionsMap[state] &&\r\n        Object.keys(statesTransitionsMap[state]).length !== 1\r\n      }\r\n    }).filter(obj => Object.values(obj)[0] !== void 0 && Object.values(obj)[0]);\r\n\r\n    const isFulfilled = failingOriginControlStates.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state without both an eventless transition and a competing transition! Cf. log`,\r\n        info: { failingOriginControlStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T12. All transitions A -ev-> * must have the same transition index, i.e. all associated guards must be together\r\n// in a single array and there cannot be two transition rows showcasing A -ev-> * transitions\r\nexport const allStateTransitionsOnOneSingleRow = {\r\n  name: 'allStateTransitionsOnOneSingleRow',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const statesTransitionsInfo = originStateList.reduce((acc, state) => {\r\n      const events = Object.keys(stateEventTransitionsMaps[state]);\r\n      const wrongEventConfig = events.filter(event => stateEventTransitionsMaps[state][event].length > 1);\r\n      if (wrongEventConfig.length > 0) {\r\n        acc[state] = wrongEventConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(statesTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found at least one control state and one event for which the associated transition are not condensated under a unique row! Cf. log`,\r\n        info: { statesTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T14. Conflicting transitions are not allowed, i.e. A -ev-> B and A < OUTER_A\r\n// with ev non reserved event (init event or eventless) is not compatible with OUTER_A-ev->C.\r\n// The event `ev` could trigger a transition towards either B or C\r\nexport const noConflictingTransitionsWithAncestorState = {\r\n  name: 'noConflictingTransitionsWithAncestorState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, eventTransitionsMaps, ancestorMap }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps).filter(ev => ev !== INIT_EVENT && ev !== void 0);\r\n    const eventTransitionsInfo = eventList.reduce((acc, event) => {\r\n      const states = Object.keys(eventTransitionsMaps[event]);\r\n      // The wrongly configured states are those which have an ancestor also in the transition map for the same event\r\n      const wrongStateConfig = states\r\n        .filter(state => state !== INIT_STATE)\r\n        .map(state => ancestorMap[state] && {\r\n          [state]: ancestorMap[state].find(\r\n            ancestorState => states.indexOf(ancestorState) > -1\r\n          )\r\n        })\r\n        // removing cases : undefined and {[state]: undefined}\r\n        .filter(obj => {\r\n          return obj && Object.values(obj).filter(Boolean).length > 0\r\n        });\r\n\r\n      if (wrongStateConfig.length > 0) {\r\n        acc[event] = wrongStateConfig;\r\n      }\r\n\r\n      return acc\r\n    }, {});\r\n\r\n    const isFulfilled = Object.keys(eventTransitionsInfo).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found two conflicting transitions! A -ev-> X, and B -ev-> Y leads to ambiguity if A < B or B < A. Cf. log`,\r\n        info: { eventTransitionsInfo }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.a History states must be target states\r\nexport const isHistoryStatesTargetStates = {\r\n  name: 'isHistoryStatesTargetStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, {}) => {\r\n    const wrongHistoryStates = fsmDef.transitions.reduce((acc, transition) => {\r\n      return isHistoryControlState(transition.from)\r\n        ? acc.concat(transition)\r\n        : acc\r\n    }, []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state configured as the origin control state for a transition. History pseudo states should only be target control states. Cf. log`,\r\n        info: { wrongHistoryStates }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T16.b History states must be compound states\r\nexport const isHistoryStatesCompoundStates = {\r\n  name: 'isHistoryStatesCompoundStates',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const wrongHistoryStates = originStateList.map(originState => {\r\n      if (originState === INIT_STATE) return []\r\n\r\n      const events = Object.keys(stateEventTransitionsMaps[originState]);\r\n\r\n      return events.reduce((acc, event) => {\r\n        // I should only ever have one transition, that is checked in another contract\r\n        // !! if there are several transitions, we may have a false positive, but that is ok\r\n        // When the other contract will fail and the issue will be solved, and app will be rerun,\r\n        // this will be recomputed correctly\r\n        const transition = stateEventTransitionsMaps[originState][event][0];\r\n        const { guards, to } = transition;\r\n        if (!guards) {\r\n          // Reminder: statesType[controlState] === true iff controlState is compound state\r\n          return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n            ? acc.concat(transition)\r\n            : acc\r\n        }\r\n        else {\r\n          return guards.reduce((acc, guard) => {\r\n            const { to } = guard;\r\n\r\n            return isHistoryControlState(to) && !statesType[getHistoryUnderlyingState(to)]\r\n              ? acc.concat(transition)\r\n              : acc\r\n          }, acc)\r\n        }\r\n      }, [])\r\n    })\r\n      .reduce((acc, x) => acc.concat(x), []);\r\n\r\n    const isFulfilled = Object.keys(wrongHistoryStates).length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found a history pseudo state connected to an atomic state! History pseudo states only refer to compound states. Cf. log`,\r\n        info: { wrongHistoryStates, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T17 An history state must refer to an existing state\r\nexport const isHistoryStatesExisting = {\r\n  name: 'isHistoryStatesExisting',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { historyStatesMap, statesType }) => {\r\n    const invalidTransitions = Array.from(historyStatesMap.entries())\r\n      .map(([historyState, flatTransitions]) => {\r\n        return !(historyState in statesType) && { historyState, flatTransitions }\r\n      })\r\n      .filter(Boolean);\r\n\r\n    const howMany = Object.keys(invalidTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} history pseudo state referring to a control state that is not declared! Check the states property of the state machine definition.`,\r\n        info: { invalidTransitions, states: fsmDef.states }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport function isInconditionalTransition(transition) {\r\n  const { from, event, guards, to, action } = transition;\r\n\r\n  return typeof guards === `${void 0}` && to && isControlState(from) && isEvent(event) && isControlState(to) && isActionFactory(action)\r\n}\r\n\r\nexport function isValidGuard(guard) {\r\n  const { to, predicate, action } = guard;\r\n\r\n  return to && isControlState(to) && isFunction(predicate) && isActionFactory(action)\r\n}\r\n\r\nexport function areCconditionalTransitions(transition) {\r\n  const { from, event, guards, to } = transition;\r\n\r\n  return guards && Array.isArray(guards) && guards.length > 0\r\n    && !to && isControlState(from) && isEvent(event) && guards.every(isValidGuard)\r\n}\r\n\r\nexport const isValidFsmDef = {\r\n  name: 'isValidFsmDef',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions, states, events, initialExtendedState } = fsmDef;\r\n    const isValidTransitions = transitions && Array.isArray(transitions);\r\n    const isValidStates = states && typeof(states) === 'object';\r\n    const isValidEvents = events && Array.isArray(events);\r\n    if (!isValidTransitions) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The transitions property for a machine definition must be an array!`,\r\n          info: { transitions }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidStates) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The states property for a machine definition must be an object!`,\r\n          info: { states }\r\n        }\r\n      }\r\n    }\r\n    else if (!isValidEvents) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `The events property for a machine definition must be an array!`,\r\n          info: { events }\r\n        }\r\n      }\r\n    }\r\n    // NOTE : we do not deal with initialExtendedState, initialControlState and settings\r\n    // this is done in other contracts\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\n// T18. Transitions have a valid format, and are either inconditional (no guards) or conditional\r\n// events are strings\r\n// guards are functions\r\n// action factories are functions\r\nexport const haveTransitionsValidTypes = {\r\n  name: 'haveTransitionsValidTypes',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings) => {\r\n    const { transitions } = fsmDef;\r\n    const wrongTransitions = transitions\r\n      .map((transition, transitionIndex) => {\r\n        return !isInconditionalTransition(transition) && !areCconditionalTransitions(transition) && {\r\n          transition,\r\n          index: transitionIndex\r\n        }\r\n      })\r\n      .filter(Boolean)\r\n\r\n    const howMany = Object.keys(wrongTransitions).length;\r\n    const isFulfilled = howMany === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `Found ${howMany} transitions with invalid format! Check logs for more details.`,\r\n        info: { wrongTransitions, transitions }\r\n      }\r\n    }\r\n  },\r\n}\r\n\r\nexport const areEventsDeclared = {\r\n  name: 'areEventsDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { eventTransitionsMaps }) => {\r\n    const eventList = Object.keys(eventTransitionsMaps);\r\n    const declaredEventList = fsmDef.events;\r\n    const eventsDeclaredButNotTriggeringTransitions = declaredEventList\r\n      .map(declaredEvent => eventList.indexOf(declaredEvent) === -1 && declaredEvent)\r\n      .filter(Boolean);\r\n    const eventsNotDeclaredButTriggeringTransitions = eventList\r\n      .map(triggeringEvent => declaredEventList.indexOf(triggeringEvent) === -1 && triggeringEvent)\r\n      .filter(Boolean)\r\n      // Filtering out init events which must not be declared, being reserved events\r\n      // Filtering out undefined events linked to eventless transitions\r\n      .filter(ev => ev !== INIT_EVENT && ev !== 'undefined')\r\n\r\n    const isFulfilled = eventsDeclaredButNotTriggeringTransitions.length === 0\r\n      && eventsNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared events must be used in transitions. All events used in transition must be declared! Cf. log`,\r\n        info: { eventsDeclaredButNotTriggeringTransitions, eventsNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const areStatesDeclared = {\r\n  name: 'areStatesDeclared',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { stateEventTransitionsMaps, targetStatesMap, statesType }) => {\r\n    const originStateList = Object.keys(stateEventTransitionsMaps);\r\n    const targetStateList = Array.from(targetStatesMap.keys()).filter(x => typeof x !== 'object');\r\n    const stateList = Object.keys([originStateList, targetStateList].reduce((acc, stateList) => {\r\n      stateList.forEach(state => acc[state] = true)\r\n      return acc\r\n    }, {}));\r\n    const declaredStateList = Object.keys(statesType);\r\n    const statesDeclaredButNotTriggeringTransitions = declaredStateList\r\n      .map(declaredState => stateList.indexOf(declaredState) === -1 && declaredState)\r\n      .filter(Boolean);\r\n    const statesNotDeclaredButTriggeringTransitions = stateList\r\n      .map(stateInTransition =>\r\n        stateInTransition !== INIT_STATE && declaredStateList.indexOf(stateInTransition) === -1 && stateInTransition)\r\n      .filter(Boolean);\r\n\r\n    const isFulfilled = statesDeclaredButNotTriggeringTransitions.length === 0\r\n      && statesNotDeclaredButTriggeringTransitions.length === 0;\r\n\r\n    return {\r\n      isFulfilled,\r\n      blame: {\r\n        message: `All declared states must be used in transitions. All states used in transition must be declared! Cf. log`,\r\n        info: { statesDeclaredButNotTriggeringTransitions, statesNotDeclaredButTriggeringTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T25. SS1 - as of v0.13 settings is no longer mandatory\r\nexport const isValidSettings = {\r\n  name: 'isValidSettings',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef) => {\r\n    return {\r\n      isFulfilled: true,\r\n      blame: void 0\r\n    }\r\n  },\r\n};\r\n\r\n// T22. There are no incoming transitions to the reserved initial state, check if implemented or not, prob. not\r\nexport const isInitialStateOriginState = {\r\n  name: 'isInitialStateOriginState',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap }) => {\r\n\r\n    if (Array.from(targetStatesMap.keys()).indexOf(INIT_STATE) > -1) {\r\n      return {\r\n        isFulfilled: false,\r\n        blame: {\r\n          message: `Found at least one transition with the initial state as target state! CF. log`,\r\n          info: { targetStates: Array.from(targetStatesMap.keys()), transitions: fsmDef.transitions }\r\n        }\r\n      }\r\n    }\r\n    else {\r\n      return {\r\n        isFulfilled: true,\r\n        blame: void 0\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\n// T23. eventless self-transitions are forbidden (while theoretically possible, the feature is of\r\n// little practical value, though being a possible source of ambiguity or infinite loops)\r\n// A -_> A impossible on compound states because there is A -INIT-> X\r\n// so only possibility is A -_> A with A atomic state\r\nexport const isValidSelfTransition = {\r\n  name: 'isValidSelfTransition',\r\n  shouldThrow: false,\r\n  predicate: (fsmDef, settings, { targetStatesMap, statesType }) => {\r\n    const targetStates = Array.from(targetStatesMap.keys());\r\n    const wrongSelfTransitions = targetStates\r\n      .map(targetState => {\r\n        const flatTransitions = targetStatesMap.get(targetState);\r\n        return flatTransitions\r\n          .map(flatTransition => {\r\n            const { from, event } = flatTransition;\r\n            if (targetState in statesType && !statesType[targetState] && from && from === targetState && !event) {\r\n              return { state: targetState, flatTransition }\r\n            }\r\n          })\r\n          .filter(Boolean)\r\n      })\r\n      .filter(x => x.length > 0);\r\n\r\n    return {\r\n      isFulfilled: wrongSelfTransitions.length === 0,\r\n      blame: {\r\n        message: `Found at least one eventless self-transition involving an atomic state! This is forbidden to avoid infinity loop! Cf. log`,\r\n        info: { wrongSelfTransitions }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const fsmContracts = {\r\n  injected: (fsmDef, settings) => {\r\n    return {\r\n      statesType: getStatesType(fsmDef.states),\r\n      initTransition: findInitTransition(fsmDef.transitions),\r\n      statesTransitionsMap: getStatesTransitionsMap(fsmDef.transitions),\r\n      stateEventTransitionsMaps: getStateEventTransitionsMaps(fsmDef.transitions),\r\n      eventTransitionsMaps: getEventTransitionsMaps(fsmDef.transitions),\r\n      ancestorMap: getAncestorMap(fsmDef.states),\r\n      statesPath: getStatesPath(fsmDef.states),\r\n      historyStatesMap: getHistoryStatesMap(fsmDef.transitions),\r\n      targetStatesMap: getTargetStatesMap(fsmDef.transitions)\r\n    }\r\n  },\r\n  description: 'FSM structure',\r\n  contracts: [isValidFsmDef, isValidSettings, isInitialControlStateDeclared, isInitialStateOriginState, eventsAreStrings, haveTransitionsValidTypes, noDuplicatedStates, noReservedStates, atLeastOneState, areEventsDeclared, areStatesDeclared, validInitialConfig, validInitialTransition, initEventOnlyInCompoundStates, validInitialTransitionForCompoundState, validEventLessTransitions, isValidSelfTransition, allStateTransitionsOnOneSingleRow, noConflictingTransitionsWithAncestorState, isHistoryStatesExisting, isHistoryStatesTargetStates, isHistoryStatesCompoundStates],\r\n};\r\n\r\n/**\r\n * Takes a series of contracts grouped considered as a unit, run them, and return the results. Some contracts may\r\n * throw. If no contract throws, the returned value include a list of the failing contracts if any. A failing\r\n * contract data structure include relevant information about the failing contract, in particular the contract name,\r\n * the associated error message and additional info expliciting the error message.\r\n * @param contractsDef\r\n * @param settings\r\n * @returns {function(...[*]=): {isFulfilled: boolean, failingContracts: Array}}\r\n */\r\nfunction makeContractHandler(contractsDef, settings) {\r\n  const console = settings && settings.debug && settings.debug.console || emptyConsole;\r\n  const trace = settings && settings.debug && settings.debug.trace || noop;\r\n  const contractsDescription = contractsDef.description;\r\n\r\n  return function checkContracts(...args) {\r\n    const failingContracts = [];\r\n    const computedArgs = contractsDef.injected.apply(null, args);\r\n    const isFulfilled = contractsDef.contracts.reduce((acc, contract) => {\r\n      const { name: contractName, predicate, shouldThrow } = contract;\r\n      const fullArgs = args.concat(computedArgs);\r\n      const { isFulfilled, blame } = predicate.apply(null, fullArgs);\r\n      const blameMessageHeader = `${contractsDescription} FAILS ${contractName}!`;\r\n      const { message, info } = blame || {};\r\n\r\n      if (isFulfilled) return acc\r\n      else {\r\n        failingContracts.push({ name: contractName, message, info });\r\n        console.error(blameMessageHeader);\r\n        console.error([contractName, message].join(': '));\r\n        console.debug('Supporting error data:', info);\r\n\r\n        if (shouldThrow) throw new Error([blameMessageHeader, `check console for information!`].join('\\n'))\r\n        else {\r\n          return false\r\n        }\r\n      }\r\n    }, true)\r\n\r\n    const contractsEval = { isFulfilled, failingContracts };\r\n    trace({ [CONTRACTS_EVAL]: contractsEval })\r\n\r\n    return contractsEval\r\n  }\r\n}\r\n\r\n// @ts-ignore error here is due to variable number of arguments, not worth spending time there\r\nexport const fsmContractChecker = (fsmDef, settings,\r\n                                   fsmContracts) => makeContractHandler(fsmContracts, settings)(fsmDef, settings);\r\n\r\nexport function runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer }) {\r\n  if (checkContracts) {\r\n    const { failingContracts } = fsmContractChecker(fsmDef, settings, checkContracts);\r\n    try {\r\n      if (failingContracts.length > 0) throwKinglyError({\r\n        when: `Attempting to create a Kingly machine`,\r\n        location: `createStateMachine`,\r\n        info: { fsmDef, settings, failingContracts },\r\n        message: `I found that one or more Kingly contracts are violated!`\r\n      })\r\n    }\r\n    catch (e) {\r\n      // Do not break the program, errors should be passed to console and dev tool\r\n      tracer({\r\n        type: MACHINE_CREATION_ERROR_MSG,\r\n        trace: {\r\n          info: e.errors,\r\n          message: e.message,\r\n          machineState: { cs: void 0, es: void 0, hs: void 0 }\r\n        }\r\n      });\r\n      return e\r\n    }\r\n  }\r\n}\r\n\r\n\r\n// Terminology\r\n// . A transition is uniquely defined by `(origin, event, predicate, target, action, transition index, guard index)`\r\n// For instance, the transition array `[{from: INIT_STATE, event:INIT_EVENT, to:A}, {from: A, event: Ev,\r\n// guards : [{predicate: T, to:B, action: IDENTITY}] }]` has its first transition\r\n// uniquely referenced by `(INIT_STATE, INIT_EVENT, undefined, undefined, A, 0, 0)`. The second transition would be\r\n// referenced by `(A, Ev, T, B, IDENTITY, 1, 0)`.\r\n// . We write A < B if A is a substate of B, with the implication that B is hence a compound state\r\n// . We write A !< B if A is a direct substate of B\r\n// . We write A. !< B if A is a substate of B, and A is also an atomic state\r\n// . We write A -ev-> B to denote a transition from A to B triggered by `ev`\r\n\r\n// Behaviour\r\n// B6. If an event is configured to be processed by the state machine, it must progress the machine (possibly\r\n// returning to the same state)\r\n// ENFORCED by T13, T4, T10, necessary for generative testing\r\n// B7. There is only one 'dead' state, the final state. Any other state should feature transitions which progress\r\n// the state machine.\r\n// NOT ENFORCED. Not very important in practice. Several final states may also appear, though it is weird\r\n// ROADMAP : distingush a true final state. When final state receive event, throw? Not important in practice\r\n// B8. It is possible to reach any states\r\n// NOT ENFORCED. Just a warning to issue. reachable states requires a graph structure, and a traversal\r\n","//@ts-check\r\nimport {\r\n  ACTION_IDENTITY,\r\n  AUTO_EVENT, DEBUG_MSG,\r\n  DEEP,\r\n  ERROR_MSG,\r\n  history_symbol,\r\n  INIT_EVENT, INIT_INPUT_MSG,\r\n  INIT_STATE, INPUT_MSG, INTERNAL_INPUT_MSG, INTERNAL_OUTPUTS_MSG, MACHINE_CREATION_ERROR_MSG,\r\n  OUTPUTS_MSG,\r\n  SHALLOW,\r\n  STATE_PROTOTYPE_NAME,\r\n  WARN_MSG\r\n} from \"./properties\";\r\nimport {\r\n  arrayizeOutput,\r\n  assert,\r\n  computeHistoryMaps,\r\n  destructureEvent,\r\n  emptyConsole,\r\n  emptyTracer,\r\n  findInitTransition,\r\n  get_fn_name,\r\n  getFsmStateList,\r\n  initHistoryDataStructure,\r\n  isActions,\r\n  isEventStruct,\r\n  isHistoryControlState,\r\n  keys, KinglyError,\r\n  updateHistory,\r\n  wrap,\r\n  throwKinglyErrorFactory, wrapUpdateStateFn\r\n} from \"./helpers\";\r\nimport { runContracts } from \"./contracts\"\r\n\r\nfunction alwaysTrue() {\r\n  return true\r\n};\r\n\r\n/**\r\n * @description Processes the hierarchically nested states and returns miscellaneous objects derived from it:\r\n * `is_group_state`: Hash matching keys (state names) to whether that state is a nested state\r\n * `hash_states`: Hierarchically nested object whose properties are the nested states.\r\n * - Nested states inherit (prototypal inheritance) from the containing state.\r\n * - Holds a `history` property which holds a `last_seen_state` property which holds the latest\r\n * state for that hierarchy group For instance, if A < B < C and the state machine leaves C for a\r\n * state in another branch, then `last_seen_state` will be set to C for A, B and C\r\n * - Tthe root state (NOK) is added to the whole hierarchy, i.e. all states inherit from the root\r\n * state\r\n * `states` {Object<String,Boolean>} : Hash which maps every state name with itself\r\n * `states.history` {Object<String,Function>} : Hash which maps every state name with a function\r\n * whose name is the state name\r\n * @param states\r\n * @returns {{hashStates: {}, isGroupState: Object<String,Boolean>}}\r\n */\r\nfunction buildNestedStateStructure(states) {\r\n  const root_name = \"State\";\r\n  let hashStates = {};\r\n  let isGroupState = {};\r\n\r\n  // Add the starting state\r\n  states = { nok: states };\r\n\r\n  ////////\r\n  // Helper functions\r\n  function build_state_reducer(states, curr_constructor) {\r\n    keys(states).forEach(function (state_name) {\r\n      const state_config = states[state_name];\r\n\r\n      // The hierarchical state mechanism is implemented by reusing the standard Javascript\r\n      // prototypal inheritance If A < B < C, then C has a B as prototype which has an A as\r\n      // prototype So when an event handler (transition) is put on A, that event handler will be\r\n      // visible in B and C\r\n      hashStates[state_name] = new curr_constructor();\r\n      hashStates[state_name].name = state_name;\r\n      const parent_name = (hashStates[state_name].parent_name = get_fn_name(\r\n        curr_constructor\r\n      ));\r\n      hashStates[state_name].root_name = root_name;\r\n\r\n      if (typeof state_config === \"object\") {\r\n        isGroupState[state_name] = true;\r\n        const curr_constructor_new = function () {\r\n        };\r\n        curr_constructor_new.displayName = state_name;\r\n        curr_constructor_new.prototype = hashStates[state_name];\r\n        build_state_reducer(state_config, curr_constructor_new);\r\n      }\r\n    });\r\n  }\r\n\r\n  function State() {\r\n  }\r\n\r\n  State.prototype = {\r\n    current_state_name: INIT_STATE\r\n  };\r\n\r\n  hashStates[INIT_STATE] = new State();\r\n  hashStates[STATE_PROTOTYPE_NAME] = new State();\r\n\r\n  build_state_reducer(states, State);\r\n\r\n  return {\r\n    hashStates: hashStates,\r\n    isGroupState: isGroupState\r\n  };\r\n}\r\n\r\nexport function normalizeTransitions(fsmDef) {\r\n  const { initialControlState, transitions } = fsmDef;\r\n  const initTransition = findInitTransition(transitions);\r\n\r\n  if (initialControlState) {\r\n    return transitions\r\n      .concat([{ from: INIT_STATE, event: INIT_EVENT, to: initialControlState, action: ACTION_IDENTITY }])\r\n  }\r\n  else if (initTransition) {\r\n    return transitions\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} [settings]\r\n * @returns {Error | Stateful_FSM}\r\n */\r\nexport function createStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withProtectedState\r\n}\r\n\r\n/**\r\n *\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @returns {Error | Pure_FSM}\r\n */\r\nexport function createPureStateMachine(fsmDef, settings) {\r\n  const res = createStateMachineAPIs(fsmDef, settings);\r\n  if (res instanceof Error) return res\r\n  else return res.withPureInterface\r\n}\r\n\r\n/**\r\n * @description Creates an instance of state machine from a set of states, transitions,\r\n * and accepted events. The initial extended state for the machine is included\r\n * in the machine definition.\r\n * @param {FSM_Def} fsmDef\r\n * @param {FSM_Settings} settings\r\n * @return {{withProtectedState: Stateful_FSM, withPureInterface: Pure_FSM}|Error}\r\n */\r\nexport function createStateMachineAPIs(fsmDef, settings) {\r\n  const {\r\n    states: controlStates,\r\n    events,\r\n    // transitions ,\r\n    initialExtendedState,\r\n    updateState: userProvidedUpdateStateFn,\r\n  } = fsmDef;\r\n  const { debug, devTool, displayName } = settings || {};\r\n  const checkContracts = debug && debug.checkContracts || void 0;\r\n  let console = debug && debug.console || emptyConsole;\r\n  let tracer = devTool && devTool.tracer || emptyTracer;\r\n  const throwKinglyError = throwKinglyErrorFactory(console, tracer);\r\n\r\n  // Check contracts if the API user wants to,\r\n  // but don't throw errors, return them and possibly log them\r\n  if (checkContracts) {\r\n    const e = runContracts({ fsmDef, settings }, checkContracts, { throwKinglyError, tracer });\r\n    if (e instanceof Error) return e\r\n  }\r\n\r\n  // Wrap user-provided update state function to capture errors\r\n  const wrappedUpdateState = wrapUpdateStateFn(userProvidedUpdateStateFn, { throwKinglyError, tracer });\r\n  // We also massage the shape of the user-provided transitions,\r\n  // unifying the two ways of providing an initial state for the machine\r\n  const transitions = normalizeTransitions(fsmDef);\r\n\r\n  // Create auxiliary data structures to quickly answer common queries:\r\n  // - is `stateName` a state that has an initial transition configured\r\n  //   (top-level, or compound state) : `isInitState[stateName]`\r\n  // - is `stateName` a transient state, i.e. with an configured\r\n  //   initial or eventless transitions: `isAutoState[stateName]`\r\n  // - is `stateName` a compound state: `isGroupState[stateName]`\r\n  // - what computation to run in `stateName`:\r\n  //   `hashStates[stateName][event]` has the event handler for `event`\r\n  //    NOTE: we use JS prototypal inheritance to make this work even when\r\n  //    A < ... < B. and the event handler in configured on parent A, and not on B\r\n  //    When the machine is in state B, it must answer to the event as A would\r\n  const hashStatesStruct = buildNestedStateStructure(controlStates);\r\n  // @type {Object<state_name,boolean>}\r\n  let isInitState = {};\r\n  // @type {Object<state_name,boolean>}, allows to know whether a state has an automatic transition defined\r\n  // that would be init transitions + eventless transitions\r\n  let isAutoState = {};\r\n  // @type {Object<state_name,boolean>}\r\n  const isGroupState = hashStatesStruct.isGroupState;\r\n  let hashStates = hashStatesStruct.hashStates;\r\n\r\n  // Fill in the auxiliary data structures\r\n  transitions.forEach(function (transition) {\r\n    let { from, to, action, event, guards: arr_predicate } = transition;\r\n    // CASE: ZERO OR ONE condition set\r\n    if (!arr_predicate)\r\n      arr_predicate = [{ predicate: void 0, to: to, action: action }];\r\n\r\n    // CASE: transition has a init event\r\n    // NOTE: there should ever only be one, but we don't enforce it here\r\n    if (event === INIT_EVENT) {\r\n      isInitState[from] = true;\r\n    }\r\n\r\n    let from_proto = hashStates[from];\r\n\r\n    // CASE: automatic transitions: no events - likely a transient state with only conditions\r\n    if (!event) {\r\n      event = AUTO_EVENT;\r\n      isAutoState[from] = true;\r\n    }\r\n    // CASE: automatic transitions : init event automatically fired upon entering a grouping state\r\n    if (isGroupState[from] && isInitState[from]) {\r\n      isAutoState[from] = true;\r\n    }\r\n\r\n    // NTH: this seriously needs refactoring, that is one line in ramda\r\n    from_proto[event] = arr_predicate.reduce(\r\n      (acc, guard, index) => {\r\n        const action = guard.action || ACTION_IDENTITY;\r\n        const actionName = action.name || action.displayName || \"\";\r\n        const condition_checking_fn = (function (guard, settings) {\r\n          let condition_suffix = \"\";\r\n          // We add the `current_state` because the current control state might be different from\r\n          // the `from` field here This is the case for instance when we are in a substate, but\r\n          // through prototypal inheritance it is the handler of the prototype which is called\r\n          const condition_checking_fn = function (extendedState_, event_data, current_state) {\r\n            from = current_state || from;\r\n            const predicate = guard.predicate || alwaysTrue;\r\n            const predicateName = predicate.name || predicate.displayName || \"<anonymous>\";\r\n            const to = guard.to;\r\n            const shouldTransitionBeTaken = ((extendedState, event_data, settings) => {\r\n              try {\r\n                return predicate(extendedState, event_data, settings);\r\n              }\r\n              catch (e) {\r\n                throwKinglyError({\r\n                  when: `Executing predicate function ${predicateName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn > shouldTransitionBeTaken`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index },\r\n                  message: [`Error occurred while processing event ${event} with target state ${to}`, e.message].join(\"\\n\"),\r\n                  stack: e.stack,\r\n                })\r\n              }\r\n            })(extendedState_, event_data, settings);\r\n\r\n            if (typeof shouldTransitionBeTaken !== \"boolean\") {\r\n              throwKinglyError({\r\n                when: `Executing predicate function ${predicateName}`,\r\n                location: `createStateMachine > event handler > condition_checking_fn > throwIfInvalidGuardResult`,\r\n                info: { event, guard, from, to, index, shouldTransitionBeTaken },\r\n                message: `Guard index ${index} with name ${predicateName} did not return a boolean!`,\r\n              })\r\n            }\r\n\r\n            if (shouldTransitionBeTaken) {\r\n              // CASE : guard for transition is fulfilled so we can execute the actions...\r\n              console.info(\"IN STATE \", from);\r\n              if (guard.predicate) {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `The guard ${predicateName} is fulfilled`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState_, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: guard ${predicate.name} for transition is fulfilled`);\r\n              }\r\n              else {\r\n                tracer({\r\n                  type: DEBUG_MSG,\r\n                  trace: {\r\n                    message: `Evaluating transition with no guards`,\r\n                    info: { eventData: event_data, from, action: actionName, to },\r\n                    machineState: { cs: current_state, es: extendedState, hs: history }\r\n                  }\r\n                });\r\n                console.info(`CASE: unguarded transition`);\r\n              }\r\n\r\n              console.info(\"THEN : we execute the action \" + actionName);\r\n              const actionResult = ((extendedState, eventData, settings) => {\r\n                try {\r\n                  return action(extendedState, eventData, settings);\r\n                }\r\n                catch (e) {\r\n                  throwKinglyError({\r\n                    when: `Executing action factory ${actionName}`,\r\n                    location: `createStateMachine > event handler > condition_checking_fn`,\r\n                    info: { extendedState, event, event_data, settings, guard, from, to, index, action },\r\n                    message: e.message,\r\n                    stack: e.stack,\r\n                  })\r\n                }\r\n              })(extendedState_, event_data, settings);\r\n\r\n              if (!isActions(actionResult)) {\r\n                throwKinglyError({\r\n                  when: `Executing action factory ${actionName}`,\r\n                  location: `createStateMachine > event handler > condition_checking_fn`,\r\n                  info: { extendedState, event, event_data, settings, guard, from, to, index, action, actionResult },\r\n                  message: `Action factory returned a value that does not have the expected shape!`,\r\n                })\r\n              }\r\n\r\n              const { updates, outputs } = actionResult;\r\n\r\n              // Leave the current state\r\n              leaveState(from, extendedState_, hashStates);\r\n\r\n              // Update the extendedState before entering the next state\r\n              extendedState = wrappedUpdateState(extendedState_, updates);\r\n\r\n              // ...and enter the next state (can be different from `to` if we have nesting state group)\r\n              const newControlState = enterNextState(to, updates, hashStates);\r\n              console.info(\"ENTERING NEXT STATE: \", cs);\r\n              console.info(\"with extended state: \", extendedState);\r\n\r\n              // allows for chaining and stop chaining guard\r\n              return { stop: true, outputs };\r\n            }\r\n            else {\r\n              // CASE : guard for transition is not fulfilled\r\n              tracer({\r\n                type: DEBUG_MSG,\r\n                trace: {\r\n                  message: guard.predicate ? `The guard ${predicateName} is not fulfilled!` : `Evaluated and skipped transition`,\r\n                  info: { eventData: event_data, settings, guard, from, to, index, action: actionName },\r\n                  machineState: { cs: current_state, es: extendedState, hs: history }\r\n                }\r\n              });\r\n              return { stop: false, outputs: null };\r\n            }\r\n          };\r\n\r\n          condition_checking_fn.displayName = from + condition_suffix;\r\n          return condition_checking_fn;\r\n        })(guard, settings);\r\n\r\n        return function arr_predicate_reduce_fn(extendedState_, event_data, current_state) {\r\n          const condition_checked = acc(extendedState_, event_data, current_state);\r\n          return condition_checked.stop\r\n            ? condition_checked\r\n            : condition_checking_fn(extendedState_, event_data, current_state);\r\n        };\r\n      },\r\n      function dummy() {\r\n        return { stop: false, outputs: null };\r\n      }\r\n    );\r\n  });\r\n\r\n  // Setting up the initial state of the machine in closure\r\n  // That is the control state, history state, and extended state\r\n  // NOTE: the user-provided update function by contract cannot update in place\r\n  // There is thus no need to clone the initial extended state.\r\n  const { stateList, stateAncestors } = computeHistoryMaps(controlStates);\r\n  let history = initHistoryDataStructure(stateList);\r\n  let extendedState = initialExtendedState;\r\n  let cs = INIT_STATE;\r\n\r\n  // Run the machine's initial transition\r\n  try {\r\n    start();\r\n  }\r\n  catch (e) {\r\n    // Do not break the program, errors should be passed to console and dev tool\r\n    tracer({\r\n      type: MACHINE_CREATION_ERROR_MSG,\r\n      trace: {\r\n        message: e.message,\r\n        info: { fsmDef, settings, error: e },\r\n        machineState: { cs: INIT_STATE, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    console && console.error(`An error occurred when starting the machine`, e)\r\n\r\n    return e\r\n  }\r\n\r\n  const fsmAPIs = {\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine. The function receives the input to be\r\n     *   processed by the machine, and outputs the results of the machine computation. In the general case, the machine\r\n     *   computes an array of values. The array can be empty, and when not, it may contain null values. The machine may\r\n     *   also return null (in csae of an input that the machine is not configured to react to) instead of returning an\r\n     *   array.\r\n     * @param {*} input\r\n     * @returns {FSM_Outputs|Error}\r\n     * @throws if an error is produced that is not an error recognized by Kingly. This generally means an unexpected\r\n     *   exception has occurred.\r\n     */\r\n    withProtectedState: function fsm(input) {\r\n      try {\r\n        const { eventName, eventData } = destructureEvent(input);\r\n\r\n        tracer({\r\n          type: INPUT_MSG,\r\n          trace: {\r\n            info: { eventName, eventData },\r\n            machineState: { cs: cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        const outputs = sendEvent(input, false);\r\n\r\n        debug && console.info(\"OUTPUTS:\", outputs);\r\n        tracer({\r\n          type: OUTPUTS_MSG,\r\n          trace: {\r\n            outputs,\r\n            machineState: { cs, es: extendedState, hs: history }\r\n          }\r\n        });\r\n\r\n        return outputs\r\n      }\r\n      catch (e) {\r\n        if (e instanceof KinglyError) {\r\n          // We don't break the program, but we can't continue as if nothing happened: we return the error\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return e\r\n        }\r\n        else {\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              error: e,\r\n              message: `An unknown error ocurred while running an input through the machine!`,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n          console.error(`yyield > unexpected error!`, e);\r\n          // We should only catch the errors we are responsible for!\r\n          throw e\r\n        }\r\n      }\r\n    },\r\n    /**\r\n     * @description This function encapsulates the behavior of a state machine but requires to be passed both the\r\n     *   machine internal state and an input from which to compute the machine outputs. According to the parameter\r\n     *   passed as internal state, the machine may: 1. (undefined) compute outputs from the last state of the machine,\r\n     *   1. (null) compute outputs, restarting from its initial state, 3. (truthy) compute outputs from the given state\r\n     *   of the machine\r\n     * @param {*} input\r\n     * @param {FSM_Internal_State} fsmState\r\n     * @returns {{outputs: FSM_Outputs|Error, fsmState: FSM_Internal_State}}\r\n     */\r\n    withPureInterface: function compute(input, fsmState) {\r\n      if (fsmState === void 0) {\r\n        // Don't update the state of the state machine\r\n        // This means the machine will continue processing inputs\r\n        // using its current state\r\n      }\r\n      else if (fsmState === null) {\r\n        // Reinitialize the machine\r\n        extendedState = initialExtendedState;\r\n        history = initHistoryDataStructure(stateList);\r\n        hashStates[INIT_STATE].current_state_name = INIT_STATE;\r\n        start();\r\n      }\r\n      else {\r\n        // Reset the state (available in closure) of the state machine\r\n        const { cs: _cs, hs, es } = fsmState;\r\n        extendedState = es;\r\n        history = hs;\r\n        cs = _cs;\r\n      }\r\n\r\n      // run the machine\r\n      const outputs = fsmAPIs.withProtectedState(input);\r\n      // NOTE: history does not need to be cloned here! We do not update the\r\n      // history in place => No risk of accidentally modifying the history\r\n      // of another machine\r\n      // TODO: We should however definitely clone `extendedState` How to modify the API?\r\n      // Require a clone function in settings? with a default of JSON.stringify?\r\n      // or we shift the responsibility on the API user to do the cloning?\r\n      // Good: faster in the default case, simpler library too, no cloning when not needed\r\n      // Bad: library user can forget, so footgun...\r\n      // ADR: API that forces to signal a clone function, which can be DEFAULT_CLONE\r\n      return { outputs, fsmState: { cs, hs: history, es: extendedState } }\r\n    }\r\n  };\r\n\r\n  return fsmAPIs\r\n\r\n  // Auxiliary functions\r\n  //\r\n\r\n  /**\r\n   *\r\n   * @param {function(...*): True | Error} contract\r\n   * @param {Array<*>} arrayParams\r\n   * @returns {undefined}\r\n   * @throws KinglyError in case of one or more failing contracts\r\n   */\r\n  function assertContract(contract, arrayParams) {\r\n    const hasFailed = assert(contract, arrayParams);\r\n    if (checkContracts && hasFailed) {\r\n      throwKinglyError(hasFailed)\r\n    }\r\n\r\n    return void 0\r\n  }\r\n\r\n  /**\r\n   * @description process an input (aka event) according to the machine specifications.\r\n   * @param {LabelledEvent} event_struct input to be processed by the machine\r\n   * @param {Boolean} isInternalEvent should be true iff the event is sent by Kingly, not by the\r\n   * API user. API user should always leave this undefined.\r\n   * This works around an edge case discovered through testing.\r\n   * With the fix implemented here, API users that send an INIT_EVENT will have it ignored.\r\n   * INIT_EVENT is reserved and API users should not use it. This fix is for robustness purposes.\r\n   * @returns {FSM_Outputs|null}\r\n   */\r\n  function sendEvent(event_struct, isInternalEvent) {\r\n    assertContract(isEventStruct, [event_struct]);\r\n\r\n    const { eventName, eventData } = destructureEvent(event_struct);\r\n\r\n    console.group(\"send event \" + eventName || \"\");\r\n    console.log(event_struct);\r\n\r\n    // Edge case to deal with: INIT_EVENT sent and the current state is the initial state\r\n    // This is a side-effect of our implementation that leverages JS prototypes.\r\n    // The INIT_STATE is a super-state of all states in the machine. Hence sending an INIT_EVENT\r\n    // would always execute the INIT transition by prototypal delegation.\r\n    // This led to a bug where an API user would maliciously send the reserved INIT_EVENT,\r\n    // thus resetting the machine in its initial state, with an unpredictable extended state!\r\n    // That, in turn, results from a **design mistake** that I will not correct here, which consisted\r\n    // in letting API users configure an initial control state, OR initial INIT_EVENT transitions.\r\n    // ADR: the impact is small, the fix is ok. API users have more flexibility at the\r\n    // cost of implementation complexity. But next time, pick simplicity over flexibility.\r\n    if (!isInternalEvent && eventName === INIT_EVENT && cs !== INIT_STATE) {\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { eventName, eventData },\r\n          message: `The external event INIT_EVENT can only be sent when starting the machine!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n      console.warn(`The external event INIT_EVENT can only be sent when starting the machine!`)\r\n      console.groupEnd();\r\n\r\n      return null\r\n    }\r\n\r\n    const outputs = processEvent(\r\n      hashStatesStruct.hashStates,\r\n      eventName,\r\n      eventData,\r\n      extendedState\r\n    );\r\n\r\n    console.groupEnd();\r\n\r\n    return outputs\r\n  }\r\n\r\n  function processEvent(hashStates, event, eventData, extendedState) {\r\n    const oldCurrentState = cs;\r\n    const eventHandler = hashStates[oldCurrentState][event];\r\n\r\n    // CASE : There is a transition associated to that event\r\n    if (eventHandler) {\r\n      console.log(\"found event handler!\");\r\n      console.info(\"WHEN EVENT \", event, eventData);\r\n\r\n      // The transition is evaluated:\r\n      // - no guards are satisfied => outputs = null\r\n      // - guards satisfied => outputs an array, possibly containing a null value\r\n      /** OUT: this event handler modifies the in-closure machine state (extendedState, cs, history state) */\r\n      const { stop, outputs: rawOutputs } = eventHandler(extendedState, eventData, oldCurrentState);\r\n      const newControlState = cs;\r\n      debug && !stop && console.warn(\"No guards have been fulfilled! We recommend to configure guards explicitly to\" +\r\n        \" cover the full state space!\")\r\n      const outputs = arrayizeOutput(rawOutputs);\r\n\r\n      // Two cases here:\r\n      // 1. Init handlers, when present on the new control state, must be acted on immediately\r\n      // This allows for sequence of init events in various state levels\r\n      // For instance, L1:init -> L2:init -> L3:init -> L4: stateX\r\n      // In this case, eventData will be passed on every INIT_EVENT\r\n      // 2. eventless transitions\r\n      // NOTE : the inside guard is to defend against loops occuring when an AUTO transition fails to advance and stays\r\n      // in the same control state!! But by contract that should never happen: all AUTO transitions should advance!\r\n      if (isAutoState[newControlState]) {\r\n        if (newControlState !== oldCurrentState) {\r\n          const auto_event = isInitState[newControlState]\r\n            ? INIT_EVENT\r\n            : AUTO_EVENT;\r\n\r\n          tracer({\r\n            type: INTERNAL_INPUT_MSG,\r\n            trace: {\r\n              info: { eventName: auto_event, eventData: eventData },\r\n              event: { [auto_event]: eventData },\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          const nextOutputs = sendEvent({ [auto_event]: eventData }, true);\r\n\r\n          tracer({\r\n            type: INTERNAL_OUTPUTS_MSG,\r\n            trace: {\r\n              outputs: nextOutputs,\r\n              machineState: { cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n\r\n          return [].concat(outputs).concat(nextOutputs);\r\n        }\r\n        else {\r\n          // We found an eventless transition that returns to the same control state!\r\n          // This is forbidden as this may generate infinite loops on that stationary control state\r\n          // We throw in that case, as this is a breach of contract, one which we should\r\n          // detect at configuration time.\r\n          console.error(`Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`);\r\n          tracer({\r\n            type: ERROR_MSG,\r\n            trace: {\r\n              info: { received: { [event]: eventData } },\r\n              message: `Eventless transitions (event |${event}| in state |${cs}|) cannot return to the same control state!! This is forbidden to avoid possible infinite loops.`,\r\n              machineState: { cs: cs, es: extendedState, hs: history }\r\n            }\r\n          });\r\n        }\r\n      }\r\n      else return outputs;\r\n    }\r\n    // CASE : There is no transition associated to that event from that state\r\n    else {\r\n      console.warn(`There is no transition associated to the event |${event}| in state |${cs}|!`);\r\n      tracer({\r\n        type: WARN_MSG,\r\n        trace: {\r\n          info: { received: { [event]: eventData } },\r\n          message: `There is no transition associated to the event |${event}| in state |${cs}|!`,\r\n          machineState: { cs: cs, es: extendedState, hs: history }\r\n        }\r\n      });\r\n\r\n      return null;\r\n    }\r\n  }\r\n\r\n  function leaveState(from, extendedState, hash_states) {\r\n    history = updateHistory(history, stateAncestors, hash_states[from].name);\r\n\r\n    console.info(\"left state\", wrap(from));\r\n  }\r\n\r\n  function enterNextState(to, updatedExtendedState, hash_states) {\r\n    let targetStateName;\r\n\r\n    // CASE: history state (H)\r\n    if (isHistoryControlState(to)) {\r\n      const historyType = to[DEEP] ? DEEP : to[SHALLOW] ? SHALLOW : void 0;\r\n      const historyTarget = to[historyType];\r\n\r\n      // Contract: history state MUST be associated to compound state (else there is no history to be had)\r\n      if (!isInitState[historyTarget]) {\r\n        const message = `Configured a history state unrelated to a compound state! The behaviour of the machine is thus unspecified. Please review your machine configuration`;\r\n        debug && console && console.error(message);\r\n        throwKinglyError({ message })\r\n      }\r\n\r\n      // Edge case: If there is no history for the compound state, then we evaluate the\r\n      // initial transition for that compound state, i.e. we set that state as target state\r\n      targetStateName = history[historyType][historyTarget] || historyTarget;\r\n    }\r\n    // CASE: not a history state\r\n    else if (to) {\r\n      targetStateName = hash_states[to].name;\r\n    }\r\n    // Dead branch: should never happen\r\n    else {\r\n      throwKinglyError({ message: \"enter_state : unknown case! Not a state name, and not a history state to enter!\" });\r\n    }\r\n    cs = targetStateName;\r\n\r\n    tracer({\r\n      type: DEBUG_MSG,\r\n      trace: {\r\n        message: isHistoryControlState(to)\r\n          ? `Entering history state for ${to[to.deep ? DEEP : to.shallow ? SHALLOW : void 0]}`\r\n          : `Entering state ${to}`,\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n    debug && console.info(\"AND TRANSITION TO STATE\", targetStateName);\r\n    return targetStateName;\r\n  }\r\n\r\n  function start() {\r\n    tracer({\r\n      type: INIT_INPUT_MSG,\r\n      trace: {\r\n        info: { eventName: INIT_EVENT, eventData: initialExtendedState },\r\n        event: { [INIT_EVENT]: initialExtendedState },\r\n        machineState: { cs, es: extendedState, hs: history }\r\n      }\r\n    });\r\n\r\n    return sendEvent({ [INIT_EVENT]: initialExtendedState }, true);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @typedef {Object} WebComponentFactoryParams\r\n * @property {String} name Name for the web component. Must include at least one hyphen per custom\r\n * components' specification\r\n * @property {Subject} eventHandler A factory function which returns a subject, i.e. an object which\r\n * implements the `Observer` and `Observable` interface\r\n * @property {Stateful_FSM} fsm An executable machine, i.e. a function which accepts machine inputs\r\n * @property {Object.<CommandName, CommandHandler>} commandHandlers\r\n * @property {*} effectHandlers Typically anything necessary to perform effects. Usually this is a hashmap mapping an\r\n *   effect moniker to a function performing the corresponding effect.\r\n * @property {{initialEvent, terminalEvent, NO_ACTION}} options\r\n */\r\n/**\r\n * @param {WebComponentFactoryParams} webComponentFactoryParams\r\n */\r\nexport function makeWebComponentFromFsm({ name, eventHandler, fsm, commandHandlers, effectHandlers, options }) {\r\n  class FsmComponent extends HTMLElement {\r\n    constructor() {\r\n      if (name.split('-').length <= 1) throw `makeWebComponentFromFsm : web component's name MUST include a dash! Please review the name property passed as parameter to the function!`\r\n      super();\r\n      const el = this;\r\n      this.eventSubject = eventHandler;\r\n      this.options = Object.assign({}, options);\r\n      const NO_ACTION = this.options.NO_ACTION || null;\r\n\r\n      // Set up execution of commands\r\n      this.eventSubject.subscribe({\r\n        next: eventStruct => {\r\n          const actions = fsm(eventStruct);\r\n\r\n          if (actions instanceof Error) {\r\n            // NOTE: we do not throw here, the web component will fail but\r\n            // the rest of the page may go on. We log and swallow the errors\r\n            console && console.log(actions)\r\n          }\r\n          else if (actions === NO_ACTION) return;\r\n          else {\r\n            actions.forEach(action => {\r\n              if (action === NO_ACTION) return;\r\n              const { command, params } = action;\r\n              commandHandlers[command](this.eventSubject.next, params, effectHandlers, el);\r\n            })\r\n          }\r\n          ;\r\n        }\r\n      });\r\n    }\r\n\r\n    static get observedAttributes() {\r\n      // There are no attributes\r\n      return [];\r\n    }\r\n\r\n    connectedCallback() {\r\n      this.options.initialEvent && this.eventSubject.next(this.options.initialEvent);\r\n    }\r\n\r\n    disconnectedCallback() {\r\n      this.options.terminalEvent && this.eventSubject.next(this.options.terminalEvent);\r\n      this.eventSubject.complete();\r\n    }\r\n\r\n    attributeChangedCallback(name, oldValue, newValue) {\r\n      // There are no attributes\r\n    }\r\n  }\r\n\r\n  return customElements.define(name, FsmComponent);\r\n}\r\n\r\n/**\r\n * This function works to merge outputs by simple concatenation and flattening\r\n * Every action return T or [T], and we want in output [T] always\r\n * mergeOutputsFn([a, [b]) = mergeOutputsFn([a,b]) = mergeOutputsFn([[a],b) = mergeOutputsFn([[a],[b]]) = [a,b]\r\n * If we wanted to pass [a] as value we would have to do mergeOutputsFn([[[a]],[b]]) to get [[a],b]\r\n * @param arrayOutputs\r\n * @returns {*}\r\n */\r\nexport function mergeOutputsFn(arrayOutputs) {\r\n  // NOTE : here, this array of outputs could be array x non-array ^n\r\n  // The algorithm is to concat all elements\r\n  return arrayOutputs.reduce((acc, element) => acc.concat(element), [])\r\n}\r\n\r\n/**\r\n * Construct history states `hs` from a list of states for a given state machine. The history states for a given control\r\n * state can then be referenced as follows :\r\n * - `hs.shallow(state)` will be the shallow history state associated to the `state`\r\n * - `hs.deep(state)` will be the deep history state associated to the `state`\r\n * @param {FSM_States} states\r\n * @return {HistoryStateFactory}\r\n */\r\nexport function makeHistoryStates(states) {\r\n  const stateList = Object.keys(getFsmStateList(states));\r\n  // used for referential equality comparison to discriminate history type\r\n\r\n  return (historyType, controlState) => {\r\n    if (!stateList.includes(controlState)) {\r\n      throw `makeHistoryStates: the state for which a history state must be constructed is not a configured state for the state machine under implementation!!`\r\n    }\r\n\r\n    return {\r\n      [historyType]: controlState,\r\n      type: history_symbol\r\n    }\r\n  }\r\n}\r\n\r\nexport function historyState(historyType, controlState) {\r\n  return {\r\n    [historyType]: controlState\r\n  }\r\n}\r\n","import {\r\n  HISTORY_STATE_NAME, INIT_STATE, SEP, TRANSITION_LABEL_START_SYMBOL, TRANSITION_SYMBOL\r\n} from \"./properties\"\r\nimport {\r\n  getDisplayName, format_history_transition_state_name, format_transition_label, get_all_transitions, is_entry_transition,\r\n  is_from_control_state, is_history_transition, is_to_history_control_state_of, times\r\n} from './helpers'\r\nimport { arrayTreeLenses, objectTreeLenses, postOrderTraverseTree } from \"fp-rosetree\"\r\n\r\nfunction generateStatePlantUmlHeader(state, optDisplayName) {\r\n  return optDisplayName\r\n    ? `state \"${optDisplayName}\" as ${state} <<NoContent>>`\r\n    : `state \"${getDisplayName(state)}\" as ${state} <<NoContent>>`\r\n}\r\n\r\n/**\r\n * Converts a transducer definition to a textual format for interpretation by PlantUml tools\r\n * @param {FSM_Def} fsmDef\r\n * @param {*} settings\r\n */\r\nexport function toPlantUml(fsmDef, settings) {\r\n  const { states, transitions } = fsmDef;\r\n  const { getChildren, constructTree, getLabel } = objectTreeLenses;\r\n  const stringify = path => path.join(SEP);\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const childrenTranslation = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      const translation = stateToPlantUML(controlState, childrenTranslation, transitions);\r\n      pathMap.set(stringify(path), translation);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const translationMap = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n\r\n  const mappedTree = translationMap.get('0');\r\n  translationMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Convert a state machine specs into a plantUML format, limiting its conversion scope to a given control state and\r\n * its nested hierarchy\r\n * @param {ControlState} controlState\r\n * @param {Array<String>} childrenTranslation conversion of the states nested in the given control state\r\n * @param {Array<Transition>} transitions Full set of transitions as defined in the state machine specs\r\n * CONTRACT : All control states must have different names...\r\n */\r\nfunction stateToPlantUML(controlState, childrenTranslation, transitions) {\r\n  return [\r\n    `${generateStatePlantUmlHeader(controlState, '')} {`,\r\n    childrenTranslation.join('\\n'),\r\n    format_history_states(controlState, transitions),\r\n    format_entry_transitions(controlState, transitions),\r\n    `}`,\r\n    translate_transitions(controlState, transitions)\r\n  ]\r\n    .filter(x => x !== '\\n' && x !== '')\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_history_states(controlState, transitions) {\r\n  // creates the history states as orig.dest.H\r\n  // e.g.  state \"H\" as CD_stepping_forwards.CD_Loaded_Group.H <<NoContent>>\r\n  const historyStatesObj = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_history_transition)\r\n      .filter(is_to_history_control_state_of(controlState))\r\n      .reduce((acc, transition) => {\r\n        acc[format_history_transition_state_name(transition)] = void 0;\r\n        return acc\r\n      }, accTranslation)\r\n  }, {});\r\n  const historyStates = Object.keys(historyStatesObj);\r\n\r\n  return historyStates.map(historyState => {\r\n    return `${generateStatePlantUmlHeader(historyState, HISTORY_STATE_NAME)}`\r\n  }).join('\\n')\r\n}\r\n\r\nfunction translate_transitions(controlState, transitions) {\r\n  const historyTransitionTranslation = format_history_transitions(controlState, transitions);\r\n  const standardTransitionTranslation = format_standard_transitions(controlState, transitions);\r\n\r\n  return [\r\n    historyTransitionTranslation,\r\n    standardTransitionTranslation\r\n  ]\r\n    .filter(Boolean)\r\n    .join('\\n')\r\n}\r\n\r\nfunction format_standard_transitions(controlState, transitions) {\r\n  // The only transition from initial state are INIT transitions and that's already taken care of elsewhere\r\n  if (controlState === INIT_STATE) return ''\r\n  else return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(transition => !is_entry_transition(transition))\r\n      .filter(transition => !is_history_transition(transition))\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          to,\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n  // necessary because [].join('\\n') is \"\" so I need to take those out to avoid unnecessary '\\n' down the road\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nfunction format_entry_transitions(controlState, transitions) {\r\n  const translation = transitions.reduce((accTranslation, transition) => {\r\n    const allTransitions = get_all_transitions(transition);\r\n\r\n    return allTransitions\r\n      .filter(is_entry_transition)\r\n      .filter(is_from_control_state(controlState))\r\n      .reduce((acc, transition) => {\r\n        const { from, to, predicate, action } = transition;\r\n        acc.push(\r\n          `[*] ${TRANSITION_SYMBOL} ${to} ${TRANSITION_LABEL_START_SYMBOL} ${format_transition_label(\"\", predicate, action)}`\r\n        );\r\n        return acc\r\n      }, accTranslation)\r\n  }, []);\r\n\r\n  return translation.join('\\n')\r\n}\r\n\r\nfunction format_history_transitions(controlState, transitions) {\r\n  return transitions.map(transition => {\r\n    const allTransitions = get_all_transitions(transition)\r\n\r\n    return allTransitions\r\n      .filter(is_from_control_state(controlState))\r\n      .filter(is_history_transition)\r\n      .map(({ from, event, predicate, to, action }) => {\r\n        return [\r\n          from,\r\n          TRANSITION_SYMBOL,\r\n          format_history_transition_state_name({ from, to }),\r\n          TRANSITION_LABEL_START_SYMBOL,\r\n          format_transition_label(event, predicate, action),\r\n        ].join(' ')\r\n      }).join('\\n');\r\n  })\r\n    .filter(Boolean)\r\n    .join('\\n');\r\n}\r\n\r\nexport function toDagreVisualizerFormat(fsmDef) {\r\n  // only thing to do here is to replace functions (guards and actions) by their name, and keep only\r\n  // the states and transitions properties\r\n  // ah no I also need to turn the states obj tree into an array-based tree... grrr\r\n  const { states, transitions } = fsmDef;\r\n  const { getLabel, getChildren } = objectTreeLenses;\r\n  const { constructTree } = arrayTreeLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const treeLabel = getLabel(tree);\r\n      const controlState = Object.keys(treeLabel)[0];\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(controlState, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const _translatedStates = postOrderTraverseTree(objectTreeLenses, traverse, { [INIT_STATE]: states });\r\n  const translatedStates = _translatedStates.get('0');\r\n\r\n  const translatedTransitions = transitions.map(transition => {\r\n    const { from, to, event, guards, action } = transition;\r\n    if (guards) {\r\n      const translatedGuards = guards.map(guard => {\r\n        const { predicate, to, action } = guard;\r\n        return { predicate: predicate.name, to, action: action.name }\r\n      })\r\n      return { from, event, guards: translatedGuards }\r\n    }\r\n    else {\r\n      // case {from, to event, action}\r\n      return { from, to, event, action: action.name || 'no action name?' }\r\n    }\r\n  });\r\n\r\n  return JSON.stringify({ states: translatedStates, transitions: translatedTransitions })\r\n}\r\n"],"names":["SEP","TRANSITION_SYMBOL","TRANSITION_LABEL_START_SYMBOL","HISTORY_STATE_NAME","HISTORY_PREFIX","INIT_STATE","INIT_EVENT","AUTO_EVENT","STATE_PROTOTYPE_NAME","NO_STATE_UPDATE","NO_OUTPUT","ACTION_IDENTITY","outputs","updates","SHALLOW","DEEP","WRONG_EVENT_FORMAT_ERROR","CONTRACTS_EVAL","OUTPUTS_MSG","INPUT_MSG","WARN_MSG","MACHINE_CREATION_ERROR_MSG","ERROR_MSG","INTERNAL_INPUT_MSG","INTERNAL_OUTPUTS_MSG","DEBUG_MSG","INIT_INPUT_MSG","PATH_ROOT","PRE_ORDER","clone","a","undefined","JSON","parse","stringify","merge","objA","objB","Object","assign","updatePathInTraversalState","traversalState","subTree","subTreeChildren","forEach","subTreeChild","index","traversalStateParent","get","traversalStateChild","currentChildPath","path","set","isAdded","isVisited","concat","updateVisitInTraversalState","tree","visitTree","traversalSpecs","store","lenses","traverse","empty","emptyOrEmptyConstructor","add","takeAndRemoveOne","isEmpty","getChildren","visit","seed","seedOrSeedConstructor","Map","currentStore","visitAcc","clear","breadthFirstTraverseTree","shift","length","subTrees","push","apply","preorderTraverseTree","unshift","postOrderTraverseTree","predicate","isLeaf","result","objectTreeLenses","isLeafLabel","label","getLabel","Array","isArray","keys","value","values","map","prop","[object Object]","constructTree","children","labelKey","traverseObj","obj","treeObj","root","strategy","BFS","POST_ORDER","arrayTreeLenses","noop","emptyConsole","log","warn","info","debug","error","trace","group","groupEnd","emptyTracer","isControlState","x","isHistoryControlState","isEvent","isActionFactory","times","fn","n","Number","call","is_history_transition","transition","to","startsWith","is_entry_transition","event","is_from_control_state","controlState","from","is_to_history_control_state_of","state","substring","is_history_control_state_of","format_transition_label","_event","action","name","format_history_transition_state_name","get_all_transitions","guards","computeHistoryMaps","control_states","stateList","stateAncestors","acc","treeLabel","parentPath","slice","parentControlState","ancestors","reduce","_","reduceTransitions","reduceFn","transitions","transitionStruct","transitionIndex","gen","guard","guardIndex","_typeof","getHistoryUnderlyingState","history","getHistoryType","initHistoryDataStructure","initHistory","findInitTransition","find","assert","contract","arrayParams","contractName","isFulfilledOrError","when","message","join","isEventStruct","trueOrError","Error","cause","destructureEvent","eventName","eventData","KinglyError","m","console","tracer","stack","_this","errors","location","fullMsg","isInconditionalTransition","isValidGuard","areCconditionalTransitions","every","fsmContracts","injected","fsmDef","settings","statesType","statesTree","states","initTransition","statesTransitionsMap","stateEventTransitionsMaps","getStateEventTransitionsMaps","eventTransitionsMaps","getEventTransitionsMaps","ancestorMap","getAncestorMap","statesPath","pathStr","getStatesPath","historyStatesMap","flatTransition","underlyingControlState","getHistoryStatesMap","targetStatesMap","getTargetStatesMap","description","contracts","shouldThrow","events","isValidTransitions","initialExtendedState","isValidStates","isValidEvents","isFulfilled","blame","initialControlState","indexOf","declaredStates","targetStates","wrongTransitions","filter","Boolean","howMany","duplicatedStates","statesHashMap","reservedStates","eventList","declaredEventList","eventsDeclaredButNotTriggeringTransitions","declaredEvent","eventsNotDeclaredButTriggeringTransitions","triggeringEvent","ev","originStateList","targetStateList","declaredStateList","statesDeclaredButNotTriggeringTransitions","declaredState","statesNotDeclaredButTriggeringTransitions","stateInTransition","initTransitions","atomicInitTransitions","atomicState","compoundStates","compoundStatesInitTransitions","compoundState","allHaveInitTransitions","hasEntryTransitions","allHaveValidInitTransitions","targetState","entryTransitions","failingOriginControlStates","wrongSelfTransitions","statesTransitionsInfo","wrongEventConfig","eventTransitionsInfo","wrongStateConfig","ancestorState","invalidTransitions","entries","historyState","flatTransitions","wrongHistoryStates","originState","fsmContractChecker","contractsDef","contractsDescription","args","failingContracts","computedArgs","contractsEval","fullArgs","blameMessageHeader","makeContractHandler","alwaysTrue","buildNestedStateStructure","root_name","hashStates","isGroupState","State","nok","prototype","current_state_name","build_state_reducer","curr_constructor","state_name","state_config","parent_name","exec","toString","curr_constructor_new","displayName","createStateMachineAPIs","controlStates","userProvidedUpdateStateFn","updateState","devTool","checkContracts","throwKinglyError","throwKinglyErrorFactory","e","type","machineState","cs","es","hs","runContracts","wrappedUpdateState","extendedState","fnName","wrapUpdateStateFn","normalizeTransitions","hashStatesStruct","isInitState","isAutoState","arr_predicate","from_proto","actionName","condition_checking_fn","extendedState_","event_data","current_state","predicateName","shouldTransitionBeTaken","actionResult","hash_states","_history","state_from_name","oldAncestor","newAncestor","updateHistory","str","leaveState","updatedExtendedState","targetStateName","historyType","historyTarget","deep","shallow","enterNextState","stop","condition_checked","start","fsmAPIs","withProtectedState","input","sendEvent","withPureInterface","fsmState","_cs","event_struct","isInternalEvent","hasFailed","oldCurrentState","eventHandler","received","rawOutputs","newControlState","output","auto_event","nextOutputs","processEvent","generateStatePlantUmlHeader","optDisplayName","replace","res","fsm","commandHandlers","effectHandlers","options","FsmComponent","split","el","eventSubject","NO_ACTION","subscribe","next","eventStruct","actions","command","params","HTMLElement","initialEvent","this","terminalEvent","complete","oldValue","newValue","customElements","define","translationMap","pathMap","translation","childrenTranslation","historyStatesObj","accTranslation","allTransitions","format_history_states","format_entry_transitions","historyTransitionTranslation","format_history_transitions","standardTransitionTranslation","format_standard_transitions","translate_transitions","stateToPlantUML","getChildrenNumber","mappedTree","translatedStates","translatedTransitions"],"mappings":"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"}