{"version":3,"sources":["index.js"],"names":["visitTree","breadthFirstTraverseTree","preorderTraverseTree","postOrderTraverseTree","reduceTree","forEachInTree","mapOverTree","pruneWhen","getHashedTreeLenses","mapOverHashTree","mapOverObj","traverseObj","switchTreeDataStructure","PATH_ROOT","POST_ORDER","PRE_ORDER","BFS","SEP","clone","a","undefined","JSON","parse","stringify","merge","objA","objB","Object","assign","times","fn","n","Array","apply","length","map","Number","call","path","join","updatePathInTraversalState","traversalState","subTree","subTreeChildren","forEach","subTreeChild","index","traversalStateParent","get","traversalStateChild","currentChildPath","set","isAdded","isVisited","concat","updateVisitInTraversalState","tree","traversalSpecs","store","lenses","traverse","emptyOrEmptyConstructor","empty","add","takeAndRemoveOne","isEmpty","getChildren","visit","seedOrSeedConstructor","seed","Map","currentStore","visitAcc","clear","shift","subTrees","push","unshift","isLeaf","predicate","decoratedLenses","result","strategy","strategies","action","treeTraveerse","accumulator","mapFn","constructTree","getLabel","getChildrenNumber","treeTraverse","pathMap","mappedLabel","mappedChildren","mappedTree","pruneLenses","prunedTree","x","sep","makeChildCursor","parentCursor","childIndex","cursor","hash","label","children","value","reduce","acc","child","obj","isLeafLabel","objectTreeLenses","isArray","keys","values","prop","labelKey","mapKeyfn","key","mapValuefn","leafValue","rootKey","rootKeyMap","mapped","isEmptyObject","root","treeObj","traverseFn","decoratedTraverse","visitAllButRoot","traversedTreeObj","constructor","arrayTreeLenses","originLenses","targetLenses","newTreeStruct"],"mappings":"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","file":"functional_rose_tree.map","sourcesContent":["const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\nexport const SEP = \".\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a) {\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge(objA, objB) {\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times(fn, n) {\r\n  return Array.apply(null, { length: n }).map(Number.call, Number).map(fn)\r\n}\r\n\r\nconst stringify = path => path.join(SEP);\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty: emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren } = lenses;\r\n  const { visit, seed: seedOrSeedConstructor } = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor);\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor);\r\n\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat([tree])\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        return predicate(tree, traversalState)\r\n        ? visit(result, traversalState, tree)\r\n          : result\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, getLabel : function, constructTree: function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(SEP);\r\n  const treeTraverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraverse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n// Examples of lenses\r\n\r\n// HashedTreeLenses\r\nexport function getHashedTreeLenses(sep) {\r\n  function makeChildCursor(parentCursor, childIndex, sep) {\r\n    return [parentCursor, childIndex].join(sep)\r\n  }\r\n\r\n  return {\r\n    getLabel: tree => {\r\n      const { cursor, hash } = tree;\r\n      return { label: hash[cursor], hash, cursor }\r\n    },\r\n    getChildren: tree => {\r\n      const { cursor, hash } = tree;\r\n      let childIndex = 0;\r\n      let children = [];\r\n\r\n      while ( makeChildCursor(cursor, childIndex, sep) in hash ) {\r\n        children.push({ cursor: makeChildCursor(cursor, childIndex, sep), hash })\r\n        childIndex++;\r\n      }\r\n\r\n      return children\r\n    },\r\n    constructTree: (label, children) => {\r\n      const { label: value, hash, cursor } = label;\r\n\r\n      return {\r\n        cursor: cursor,\r\n        hash: merge(\r\n          children.reduce((acc, child) => merge(acc, child.hash), {}),\r\n          { [cursor]: value }\r\n        )\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function mapOverHashTree(sep, mapFn, obj) {\r\n  const lenses = getHashedTreeLenses(sep);\r\n\r\n  return mapOverTree(lenses, ({ label, hash, cursor }) => ({\r\n    label: mapFn(label), hash, cursor\r\n  }), obj);\r\n}\r\n\r\n// Object as a tree\r\nfunction isLeafLabel(label) {\r\n  return objectTreeLenses.getChildren(label).length === 0\r\n}\r\n\r\nexport const objectTreeLenses = {\r\n  isLeafLabel,\r\n  getLabel: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      return tree;\r\n    }\r\n    else {\r\n      throw `getLabel > unexpected object tree value`\r\n    }\r\n  },\r\n  getChildren: tree => {\r\n    if (typeof tree === 'object' && !Array.isArray(tree) && Object.keys(tree).length === 1) {\r\n      let value = Object.values(tree)[0];\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        return Object.keys(value).map(prop => ({ [prop]: value[prop] }))\r\n      }\r\n      else {\r\n        return []\r\n      }\r\n    }\r\n    else {\r\n      throw `getChildren > unexpected value`\r\n    }\r\n  },\r\n  constructTree: (label, children) => {\r\n    const labelKey = label && Object.keys(label) && Object.keys(label)[0];\r\n\r\n    return children.length === 0\r\n      ? label\r\n      : {\r\n      [labelKey]: Object.assign.apply(null, children)\r\n    }\r\n  },\r\n};\r\n\r\nexport function mapOverObj({ key: mapKeyfn, leafValue: mapValuefn }, obj) {\r\n  const rootKey = 'root';\r\n  const rootKeyMap = mapKeyfn(rootKey);\r\n\r\n  const mapped =  mapOverTree(objectTreeLenses, (tree) => {\r\n    const key = Object.keys(tree)[0];\r\n    const value = tree[key];\r\n\r\n    return {\r\n      [mapKeyfn(key)]: isLeafLabel(objectTreeLenses.getLabel(tree)) && !isEmptyObject(value)\r\n        ? mapValuefn(value)\r\n        : value\r\n    }\r\n  }, { root: obj });\r\n\r\n  return mapped[rootKeyMap];\r\n}\r\n\r\nexport function traverseObj(traverse, obj){\r\n  const treeObj = {root : obj};\r\n  const {strategy, seed, visit} = traverse;\r\n  const traverseFn = {\r\n    BFS : breadthFirstTraverseTree,\r\n    PRE_ORDER : preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  }[strategy] || preorderTraverseTree;\r\n  const decoratedTraverse = {\r\n    seed,\r\n    visit : function visitAllButRoot(visitAcc, traversalState, tree){\r\n      const {path} = traversalState.get(tree);\r\n\r\n      return JSON.stringify(path)=== JSON.stringify(PATH_ROOT)\r\n      ? visitAcc\r\n        : visit(visitAcc, traversalState, tree)\r\n    }\r\n  };\r\n\r\n  const traversedTreeObj = traverseFn(objectTreeLenses, decoratedTraverse, treeObj);\r\n\r\n  return traversedTreeObj\r\n}\r\n\r\nfunction isEmptyObject(obj) {\r\n  return obj && Object.keys(obj).length === 0 && obj.constructor === Object\r\n}\r\n\r\n// Arrays as trees\r\nexport const arrayTreeLenses = {\r\n  getLabel: tree => {\r\n    return Array.isArray(tree) ? tree[0] : tree\r\n  },\r\n  getChildren: tree => {\r\n    return Array.isArray(tree)  ? tree[1] : []\r\n  },\r\n  constructTree: (label, children) => {\r\n    return children && Array.isArray(children) && children.length > 0 ? [label, children] : label\r\n  },\r\n}\r\n\r\n// Conversion\r\nexport function switchTreeDataStructure(originLenses, targetLenses, tree) {\r\n  const { getLabel, getChildren } = originLenses;\r\n  const { constructTree } = targetLenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n\r\n  const traverse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      const label = getLabel(tree);\r\n      const children = times(\r\n        index => pathMap.get(stringify(path.concat(index))),\r\n        getChildrenNumber(tree, traversalState)\r\n      );\r\n      pathMap.set(stringify(path), constructTree(label, children));\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n\r\n  const newTreeStruct = postOrderTraverseTree(originLenses, traverse, tree);\r\n  return newTreeStruct.get(stringify(PATH_ROOT));\r\n}\r\n"]}